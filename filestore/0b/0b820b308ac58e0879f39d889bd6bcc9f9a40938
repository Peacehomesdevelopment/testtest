)]}'
{"version": 3, "sources": ["/web/static/src/module_loader.js", "/web_editor/static/src/js/editor/odoo-editor/src/OdooEditor.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/align.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/commands.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/deleteBackward.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/deleteForward.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/enter.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/shiftEnter.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/shiftTab.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/tab.js", "/web_editor/static/src/js/editor/odoo-editor/src/commands/toggleList.js", "/web_editor/static/src/js/editor/odoo-editor/src/powerbox/Powerbox.js", "/web_editor/static/src/js/editor/odoo-editor/src/powerbox/patienceDiff.js", "/web_editor/static/src/js/editor/odoo-editor/src/tablepicker/TablePicker.js", "/web_editor/static/src/js/editor/odoo-editor/src/utils/constants.js", "/web_editor/static/src/js/editor/odoo-editor/src/utils/sanitize.js", "/web_editor/static/src/js/editor/odoo-editor/src/utils/serialize.js", "/web_editor/static/src/js/editor/odoo-editor/src/utils/utils.js"], "mappings": "AAAA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClOA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjqKA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACt8BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/RA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1OA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7IA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1GA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvQA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3JA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;ACJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5SA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/**\n *------------------------------------------------------------------------------\n * Odoo Web Boostrap Code\n *------------------------------------------------------------------------------\n */\n(function () {\n    \"use strict\";\n\n    class ModuleLoader {\n        /** @type {Map<string,{fn: Function, deps: string[]}>} mapping name => deps/fn */\n        factories = new Map();\n        /** @type {Set<string>} names of modules waiting to be started */\n        jobs = new Set();\n        /** @type {Set<string>} names of failed modules */\n        failed = new Set();\n\n        /** @type {Map<string,any>} mapping name => value */\n        modules = new Map();\n\n        bus = new EventTarget();\n\n        checkErrorProm = null;\n\n        /**\n         * @param {string} name\n         * @param {string[]} deps\n         * @param {Function} factory\n         */\n        define(name, deps, factory) {\n            if (typeof name !== \"string\") {\n                throw new Error(`Invalid name definition: ${name} (should be a string)\"`);\n            }\n            if (!(deps instanceof Array)) {\n                throw new Error(`Dependencies should be defined by an array: ${deps}`);\n            }\n            if (typeof factory !== \"function\") {\n                throw new Error(`Factory should be defined by a function ${factory}`);\n            }\n            if (!this.factories.has(name)) {\n                this.factories.set(name, {\n                    deps,\n                    fn: factory,\n                    ignoreMissingDeps: globalThis.__odooIgnoreMissingDependencies,\n                });\n                this.addJob(name);\n                this.checkErrorProm ||= Promise.resolve().then(() => {\n                    this.checkAndReportErrors();\n                    this.checkErrorProm = null;\n                });\n            }\n        }\n\n        addJob(name) {\n            this.jobs.add(name);\n            this.startModules();\n        }\n\n        findJob() {\n            for (const job of this.jobs) {\n                if (this.factories.get(job).deps.every((dep) => this.modules.has(dep))) {\n                    return job;\n                }\n            }\n            return null;\n        }\n\n        startModules() {\n            let job;\n            while ((job = this.findJob())) {\n                this.startModule(job);\n            }\n        }\n\n        startModule(name) {\n            const require = (name) => this.modules.get(name);\n            this.jobs.delete(name);\n            const factory = this.factories.get(name);\n            let value = null;\n            try {\n                value = factory.fn(require);\n            } catch (error) {\n                this.failed.add(name);\n                throw new Error(`Error while loading \"${name}\":\\n${error}`);\n            }\n            this.modules.set(name, value);\n            this.bus.dispatchEvent(\n                new CustomEvent(\"module-started\", { detail: { moduleName: name, module: value } })\n            );\n        }\n\n        findErrors() {\n            // cycle detection\n            const dependencyGraph = new Map();\n            for (const job of this.jobs) {\n                dependencyGraph.set(job, this.factories.get(job).deps);\n            }\n            function visitJobs(jobs, visited = new Set()) {\n                for (const job of jobs) {\n                    const result = visitJob(job, visited);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return null;\n            }\n\n            function visitJob(job, visited) {\n                if (visited.has(job)) {\n                    const jobs = Array.from(visited).concat([job]);\n                    const index = jobs.indexOf(job);\n                    return jobs\n                        .slice(index)\n                        .map((j) => `\"${j}\"`)\n                        .join(\" => \");\n                }\n                const deps = dependencyGraph.get(job);\n                return deps ? visitJobs(deps, new Set(visited).add(job)) : null;\n            }\n\n            // missing dependencies\n            const missing = new Set();\n            for (const job of this.jobs) {\n                const factory = this.factories.get(job);\n                if (factory.ignoreMissingDeps) {\n                    continue;\n                }\n                for (const dep of factory.deps) {\n                    if (!this.factories.has(dep)) {\n                        missing.add(dep);\n                    }\n                }\n            }\n\n            return {\n                failed: [...this.failed],\n                cycle: visitJobs(this.jobs),\n                missing: [...missing],\n                unloaded: [...this.jobs].filter((j) => !this.factories.get(j).ignoreMissingDeps),\n            };\n        }\n\n        async checkAndReportErrors() {\n            const { failed, cycle, missing, unloaded } = this.findErrors();\n            if (!failed.length && !unloaded.length) {\n                return;\n            }\n\n            function domReady(cb) {\n                if (document.readyState === \"complete\") {\n                    cb();\n                } else {\n                    document.addEventListener(\"DOMContentLoaded\", cb);\n                }\n            }\n\n            function list(heading, names) {\n                const frag = document.createDocumentFragment();\n                if (!names || !names.length) {\n                    return frag;\n                }\n                frag.textContent = heading;\n                const ul = document.createElement(\"ul\");\n                for (const el of names) {\n                    const li = document.createElement(\"li\");\n                    li.textContent = el;\n                    ul.append(li);\n                }\n                frag.appendChild(ul);\n                return frag;\n            }\n\n            domReady(() => {\n                // Empty body\n                while (document.body.childNodes.length) {\n                    document.body.childNodes[0].remove();\n                }\n                const container = document.createElement(\"div\");\n                container.className =\n                    \"o_module_error position-fixed w-100 h-100 d-flex align-items-center flex-column bg-white overflow-auto modal\";\n                container.style.zIndex = \"10000\";\n                const alert = document.createElement(\"div\");\n                alert.className = \"alert alert-danger o_error_detail fw-bold m-auto\";\n                container.appendChild(alert);\n                alert.appendChild(\n                    list(\n                        \"The following modules failed to load because of an error, you may find more information in the devtools console:\",\n                        failed\n                    )\n                );\n                alert.appendChild(\n                    list(\n                        \"The following modules could not be loaded because they form a dependency cycle:\",\n                        cycle && [cycle]\n                    )\n                );\n                alert.appendChild(\n                    list(\n                        \"The following modules are needed by other modules but have not been defined, they may not be present in the correct asset bundle:\",\n                        missing\n                    )\n                );\n                alert.appendChild(\n                    list(\n                        \"The following modules could not be loaded because they have unmet dependencies, this is a secondary error which is likely caused by one of the above problems:\",\n                        unloaded\n                    )\n                );\n                document.body.appendChild(container);\n            });\n        }\n    }\n\n    if (!globalThis.odoo) {\n        globalThis.odoo = {};\n    }\n    const odoo = globalThis.odoo;\n    if (odoo.debug && !new URLSearchParams(location.search).has(\"debug\")) {\n        // remove debug mode if not explicitely set in url\n        odoo.debug = \"\";\n    }\n\n    const loader = new ModuleLoader();\n    odoo.define = loader.define.bind(loader);\n\n    odoo.loader = loader;\n})();\n", "/** @odoo-module **/\n\nimport './commands/deleteBackward.js';\nimport './commands/deleteForward.js';\nimport './commands/enter.js';\nimport './commands/shiftEnter.js';\nimport './commands/shiftTab.js';\nimport './commands/tab.js';\nimport './commands/toggleList.js';\nimport './commands/align.js';\n\nimport { sanitize } from './utils/sanitize.js';\nimport { serializeNode, unserializeNode, serializeSelection } from './utils/serialize.js';\nimport {\n    closestBlock,\n    commonParentGet,\n    containsUnremovable,\n    DIRECTIONS,\n    ensureFocus,\n    getCursorDirection,\n    getFurthestUneditableParent,\n    getListMode,\n    getOuid,\n    insertText,\n    isColorGradient,\n    nodeSize,\n    preserveCursor,\n    setCursorStart,\n    setSelection,\n    toggleClass,\n    closestElement,\n    isVisible,\n    isHtmlContentSupported,\n    rgbToHex,\n    isFontAwesome,\n    ICON_SELECTOR,\n    getInSelection,\n    getDeepRange,\n    getRowIndex,\n    getColumnIndex,\n    ancestors,\n    firstLeaf,\n    previousLeaf,\n    nextLeaf,\n    isUnremovable,\n    fillEmpty,\n    isEmptyBlock,\n    URL_REGEX,\n    isSelectionFormat,\n    YOUTUBE_URL_GET_VIDEO_ID,\n    unwrapContents,\n    peek,\n    rightPos,\n    getAdjacentPreviousSiblings,\n    getAdjacentNextSiblings,\n    isBlock,\n    getTraversedNodes,\n    getSelectedNodes,\n    descendants,\n    hasValidSelection,\n    hasTableSelection,\n    pxToFloat,\n    parseHTML,\n    splitTextNode,\n    isEditorTab,\n    isMacOS,\n    isProtected,\n    isArtificialVoidElement,\n    cleanZWS,\n    isZWS,\n    setCursorEnd,\n    paragraphRelatedElements,\n    getDeepestPosition,\n    leftPos,\n    isNotAllowedContent,\n    EMAIL_REGEX,\n    prepareUpdate,\n    boundariesOut,\n    getFontSizeDisplayValue,\n    rightLeafOnlyNotBlockPath,\n    lastLeaf,\n    isUnbreakable,\n} from './utils/utils.js';\nimport { editorCommands } from './commands/commands.js';\nimport { Powerbox } from './powerbox/Powerbox.js';\nimport { TablePicker } from './tablepicker/TablePicker.js';\n\nexport * from './utils/utils.js';\nimport { UNBREAKABLE_ROLLBACK_CODE, UNREMOVABLE_ROLLBACK_CODE } from './utils/constants.js';\n/* global DOMPurify */\n\nconst BACKSPACE_ONLY_COMMANDS = ['oDeleteBackward', 'oDeleteForward'];\nconst BACKSPACE_FIRST_COMMANDS = BACKSPACE_ONLY_COMMANDS.concat(['oEnter', 'oShiftEnter']);\n\n// 60 seconds\nconst HISTORY_SNAPSHOT_INTERVAL = 1000 * 60;\n// 10 seconds\nconst HISTORY_SNAPSHOT_BUFFER_TIME = 1000 * 10;\n\nconst KEYBOARD_TYPES = { VIRTUAL: 'VIRTUAL', PHYSICAL: 'PHYSICAL', UNKNOWN: 'UKNOWN' };\n\nexport const AVATAR_SIZE = 25;\n\nconst IS_KEYBOARD_EVENT_UNDO = ev => ev.key === 'z' && (ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_REDO = ev => ev.key === 'y' && (ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_BOLD = ev => ev.key === 'b' && (ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_ITALIC = ev => ev.key === 'i' && (ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_UNDERLINE = ev => ev.key === 'u' && (ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_STRIKETHROUGH = ev => ev.key === '5' && (ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_LEFT_ARROW = ev => ev.key === 'ArrowLeft' && !(ev.ctrlKey || ev.metaKey);\nconst IS_KEYBOARD_EVENT_RIGHT_ARROW = ev => ev.key === 'ArrowRight' && !(ev.ctrlKey || ev.metaKey);\n\nconst CLIPBOARD_BLACKLISTS = {\n    unwrap: ['.Apple-interchange-newline', 'DIV'], // These elements' children will be unwrapped.\n    remove: ['META', 'STYLE', 'SCRIPT'], // These elements will be removed along with their children.\n};\nexport const CLIPBOARD_WHITELISTS = {\n    nodes: [\n        // Style\n        'P',\n        'H1',\n        'H2',\n        'H3',\n        'H4',\n        'H5',\n        'H6',\n        'BLOCKQUOTE',\n        'PRE',\n        // List\n        'UL',\n        'OL',\n        'LI',\n        // Inline style\n        'I',\n        'B',\n        'U',\n        'S',\n        'EM',\n        'FONT',\n        'STRONG',\n        // Table\n        'TABLE',\n        'THEAD',\n        'TH',\n        'TBODY',\n        'TR',\n        'TD',\n        // Miscellaneous\n        'IMG',\n        'BR',\n        'A',\n        '.fa',\n    ],\n    classes: [\n        // Media\n        /^float-/,\n        'd-block',\n        'mx-auto',\n        'img-fluid',\n        'img-thumbnail',\n        'rounded',\n        'rounded-circle',\n        'table',\n        'table-bordered',\n        /^padding-/,\n        /^shadow/,\n        // Odoo colors\n        /^text-o-/,\n        /^bg-o-/,\n        // Odoo lists\n        'o_checked',\n        'o_checklist',\n        'oe-nested',\n        // Miscellaneous\n        /^btn/,\n        /^fa/,\n    ],\n    attributes: ['class', 'href', 'src', 'target'],\n    styledTags: ['SPAN', 'B', 'STRONG', 'I', 'S', 'U', 'FONT', 'TD'],\n};\n\n// Commands that don't require a DOM selection but take an argument instead.\nconst SELECTIONLESS_COMMANDS = ['addRow', 'addColumn', 'removeRow', 'removeColumn', 'resetSize'];\n\nconst EDITABLE_LINK_SELECTOR = 'a:not(.nav-link):not([contenteditable=\"false\"])';\n\nfunction defaultOptions(defaultObject, object) {\n    const newObject = Object.assign({}, defaultObject, object);\n    for (const [key, value] of Object.entries(object)) {\n        if (typeof value === 'undefined') {\n            newObject[key] = defaultObject[key];\n        }\n    }\n    return newObject;\n}\nfunction getImageFiles(dataTransfer) {\n    return [...dataTransfer.items]\n        .filter(item => item.kind === 'file' && item.type.includes('image/'))\n        .map((item) => item.getAsFile());\n}\nfunction getImageUrl (file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n\n        reader.readAsDataURL(file);\n        reader.onloadend = (e) => {\n            if (reader.error) {\n                return reject(reader.error);\n            }\n            resolve(e.target.result);\n        };\n    });\n}\nexport class OdooEditor extends EventTarget {\n    constructor(editable, options = {}) {\n        super();\n\n        this.options = defaultOptions(\n            {\n                controlHistoryFromDocument: false,\n                getContextFromParentRect: () => {\n                    return { top: 0, left: 0 };\n                },\n                getScrollContainerRect: () => document.body.getBoundingClientRect(),\n                toSanitize: true,\n                isRootEditable: true,\n                placeholder: false,\n                showEmptyElementHint: true,\n                defaultLinkAttributes: {},\n                plugins: [],\n                getUnremovableElements: () => [],\n                getReadOnlyAreas: () => [],\n                getContentEditableAreas: () => [],\n                getPowerboxElement: () => {\n                    const selection = document.getSelection();\n                    if (selection.isCollapsed && selection.rangeCount) {\n                        return closestElement(selection.anchorNode, 'P, DIV');\n                    }\n                },\n                preHistoryUndo: () => {},\n                isHintBlacklisted: () => false,\n                filterMutationRecords: (records) => records,\n                /**\n                 * In case an external asynchronous post processing has to be\n                 * applied on some nodes after an external step (i.e. render\n                 * an OWL Component), the owner of the post-processing will\n                 * return a Promise through this hook resolved when it is done.\n                 * Further collaborative external steps will be buffered as\n                 * long as that promise is not resolved, to avoid a situation\n                 * where the editor tries to apply mutations inside a node that\n                 * is currently being rendered (not ready).\n                 *\n                 * @param {Element} editable\n                 * @returns {Promise|null} Promise that will be resolved when\n                 *          the rendering is done, or null if there is no\n                 *          rendering to do. The editor will buffer new external\n                 *          steps (collaborative) until the promise is resolved.\n                 */\n                postProcessExternalSteps: () => null,\n                onPostSanitize: () => {},\n                direction: 'ltr',\n                _t: string => string,\n                allowCommandVideo: true,\n                renderingClasses: [],\n                allowInlineAtRoot: false,\n                useResponsiveFontSizes: true,\n                showResponsiveFontSizesBadges: false,\n                showExtendedTextStylesOptions: false,\n                // TODO probably move `getCSSVariableValue` and\n                // `convertNumericToUnit` as odoo-editor utils to avoid this\n                getCSSVariableValue: () => null,\n                convertNumericToUnit: x => x,\n            },\n            options,\n        );\n\n        // --------------\n        // Set properties\n        // --------------\n\n        this.document = options.document || document;\n        this.isDestroyed = false;\n\n        this.isMobile = matchMedia('(max-width: 767px)').matches;\n        this.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\n        this.isPrepareUpdateLocked = false;\n\n        // Keyboard type detection, happens only at the first keydown event.\n        this.keyboardType = KEYBOARD_TYPES.UNKNOWN;\n\n        // Wether we should check for unbreakable the next history step.\n        this._checkStepUnbreakable = true;\n\n        // All dom listeners currently active.\n        this._domListeners = [];\n\n        // Set of labels that which prevent the automatic step mechanism if\n        // it contains at least one element.\n        this._observerTimeoutUnactive = new Set();\n        // Set of labels that which prevent the observer to be active if\n        // it contains at least one element.\n        this._observerUnactiveLabels = new Set();\n\n        // The state of the dom.\n        this._currentMouseState = 'mouseup';\n\n        this._onKeyupResetContenteditableNodes = [];\n\n        // Track if we need to rollback mutations in case unbreakable or unremovable are being added or removed.\n        this._toRollback = false;\n\n        // Map that from an node id to the dom node.\n        this._idToNodeMap = new Map();\n\n        // Instanciate plugins.\n        this._plugins = [];\n        for (const plugin of this.options.plugins) {\n            this._pluginAdd(plugin);\n        }\n\n        // -------------------\n        // Alter the editable\n        // -------------------\n\n        if (editable.innerHTML.trim() === '') {\n            editable.innerHTML = '<p><br></p>';\n        }\n        this.initElementForEdition(editable);\n\n        // Convention: root node is ID root.\n        editable.oid = 'root';\n        this._idToNodeMap.set(1, editable);\n        if (this.options.toSanitize) {\n            sanitize(editable);\n            this.options.onPostSanitize(editable);\n        }\n        this.editable = editable;\n        this.editable.classList.add(\"odoo-editor-editable\");\n        this.editable.setAttribute('dir', this.options.direction);\n\n        // Set contenteditable before clone as FF updates the content at this point.\n        this._activateContenteditable();\n\n        this._currentStep = {\n            selection: {},\n            mutations: [],\n        };\n\n        this._setLinkZws();\n\n        this._collabClientId = this.options.collaborationClientId;\n        this._collabClientAvatarUrl = this.options.collaborationClientAvatarUrl;\n\n        // Collaborator selection and caret display.\n        this._collabSelectionInfos = new Map();\n        this._collabSelectionColor = `hsl(${(Math.random() * 360).toFixed(0)}, 75%, 50%)`;\n        this._avatarsOverlaps = {}\n\n        // This main container is used to contain a tree of sub containers.\n        // By having one parent that contains a tree of containers, it is easy\n        // to change the z-index of any container by changing their place in the\n        // tree rather than tweaking a z-index number.\n        this.mainAbsoluteContainer = this.document.createElement('div');\n        this.mainAbsoluteContainer.classList.add('oe-absolute-container');\n        this.editable.before(this.mainAbsoluteContainer);\n\n        // This container contains the users selections.\n        this._selectionsContainer = this.makeAbsoluteContainer('oe-selections-container');\n        // This container contains the users avatars.\n        this._avatarsContainer = this.makeAbsoluteContainer('oe-avatars-container');\n        // This container contains the users counter that overlap the users avatars.\n        this._avatarsCountersContainer = this.makeAbsoluteContainer('oe-avatars-counters-container');\n\n        // Promise for extra rendering, collaborative external steps will be\n        // buffered (delayed) until it is resolved.\n        this._postProcessExternalStepsPromise = null;\n        this._externalStepsBuffer = [];\n\n        this.idSet(editable);\n        this._historyStepsActive = true;\n        this.historyReset();\n        if (this.options.initialHistoryId) {\n            this.historySetInitialId(this.options.initialHistoryId);\n        }\n\n        this._pluginCall('start', [editable]);\n        this._pluginCall('sanitizeElement', [editable]);\n\n        // ------\n        // Tables\n        // ------\n\n        // Create the table picker for the Powerbox.\n        this.powerboxTablePicker = new TablePicker({\n            document: this.document,\n            floating: true,\n            getContextFromParentRect: this.options.getContextFromParentRect,\n        });\n        document.body.appendChild(this.powerboxTablePicker.el);\n        this.powerboxTablePicker.addEventListener('cell-selected', ev => {\n            this.execCommand('insertTable', {\n                rowNumber: ev.detail.rowNumber,\n                colNumber: ev.detail.colNumber,\n            });\n        });\n        // Create the table UI.\n        this._tableUiContainer = this.document.createElement('div');\n        this._tableUiContainer.classList.add('o_table_ui_container');\n        const parser = new DOMParser();\n        for (const direction of ['row', 'column']) {\n            // Create the containers and the menu toggler.\n            const iconClass = (direction === 'row') ? 'fa-ellipsis-v' : 'fa-ellipsis-h';\n            const ui = parser.parseFromString(`<div class=\"o_table_ui o_${direction}_ui\" style=\"visibility: hidden;\">\n                <div>\n                    <span class=\"o_table_ui_menu_toggler fa ${iconClass}\"></span>\n                    <div class=\"o_table_ui_menu\"></div>\n                </div>\n            </div>`, 'text/html').body.firstElementChild;\n            const uiMenu = ui.querySelector('.o_table_ui_menu');\n\n            // Create the move buttons.\n            if (direction === 'column') {\n                uiMenu.append(...parser.parseFromString(`\n                    <div class=\"o_move_left\"><span class=\"fa fa-chevron-left\"></span>` + this.options._t('Move left') + `</div>\n                    <div class=\"o_move_right\"><span class=\"fa fa-chevron-right\"></span>` + this.options._t('Move right') + `</div>\n                `, 'text/html').body.children);\n                this.addDomListener(uiMenu.querySelector('.o_move_left'), 'click', this._onTableMoveLeftClick);\n                this.addDomListener(uiMenu.querySelector('.o_move_right'), 'click', this._onTableMoveRightClick);\n            } else {\n                uiMenu.append(...parser.parseFromString(`\n                    <div class=\"o_move_up\"><span class=\"fa fa-chevron-left\" style=\"transform: rotate(90deg);\"></span>` + this.options._t('Move up') + `</div>\n                    <div class=\"o_move_down\"><span class=\"fa fa-chevron-right\" style=\"transform: rotate(90deg);\"></span>` + this.options._t('Move down') + `</div>\n                `, 'text/html').body.children);\n                this.addDomListener(uiMenu.querySelector('.o_move_up'), 'click', this._onTableMoveUpClick);\n                this.addDomListener(uiMenu.querySelector('.o_move_down'), 'click', this._onTableMoveDownClick);\n            }\n\n            // Create the add buttons.\n            if (direction === 'column') {\n                uiMenu.append(...parser.parseFromString(`\n                    <div class=\"o_insert_left\"><span class=\"fa fa-plus\"></span>` + this.options._t('Insert left') + `</div>\n                    <div class=\"o_insert_right\"><span class=\"fa fa-plus\"></span>` + this.options._t('Insert right') +`</div>\n                `, 'text/html').body.children);\n                this.addDomListener(uiMenu.querySelector('.o_insert_left'), 'click', () => this.execCommand('addColumn', 'before', this._columnUiTarget));\n                this.addDomListener(uiMenu.querySelector('.o_insert_right'), 'click', () => this.execCommand('addColumn', 'after', this._columnUiTarget));\n            } else {\n                uiMenu.append(...parser.parseFromString(`\n                    <div class=\"o_insert_above\"><span class=\"fa fa-plus\"></span>` + this.options._t('Insert above') + `</div>\n                    <div class=\"o_insert_below\"><span class=\"fa fa-plus\"></span>` + this.options._t('Insert below') + `</div>\n                `, 'text/html').body.children);\n                this.addDomListener(uiMenu.querySelector('.o_insert_above'), 'click', () => this.execCommand('addRow', 'before', this._rowUiTarget));\n                this.addDomListener(uiMenu.querySelector('.o_insert_below'), 'click', () => this.execCommand('addRow', 'after', this._rowUiTarget));\n            }\n\n            // Add the delete button.\n            if (direction === 'column') {\n                uiMenu.append(parser.parseFromString(`<div class=\"o_delete_column\"><span class=\"fa fa-trash\"></span>` + this.options._t('Delete') + `</div>\n                `, 'text/html').body.firstChild)\n                this.addDomListener(uiMenu.querySelector('.o_delete_column'), 'click', this._onTableDeleteColumnClick);\n            } else {\n                uiMenu.append(parser.parseFromString(`<div class=\"o_delete_row\"><span class=\"fa fa-trash\"></span>` + this.options._t('Delete') + `</div>\n                `, 'text/html').body.firstChild)\n                this.addDomListener(uiMenu.querySelector('.o_delete_row'), 'click', this._onTableDeleteRowClick);\n            }\n\n            // Reset the size of the table\n            uiMenu.append(parser.parseFromString(`<div class=\"o_reset_table_size\"><span class=\"fa fa-table\"></span>` + this.options._t('Reset Size') + `</div>\n                `, 'text/html').body.firstChild)\n            this.addDomListener(uiMenu.querySelector('.o_reset_table_size'), 'click', () => this.execCommand('resetSize', this._tableUiTarget));\n\n            this[`_${direction}Ui`] = ui;\n            this._tableUiContainer.append(ui);\n            this.addDomListener(ui.querySelector('.o_table_ui_menu_toggler'), 'click', this._onTableMenuTogglerClick);\n            this.editable.before(this._tableUiContainer);\n        }\n\n        // --------\n        // Powerbox\n        // --------\n\n        this.powerbox = new Powerbox({\n            editable: this.editable,\n            getContextFromParentRect: this.options.getContextFromParentRect,\n            commandFilters: this.options.powerboxFilters,\n            onShow: () => {\n                this.powerboxTablePicker.hide();\n            },\n            beforeCommand: () => {\n                if (this._isPowerboxOpenOnInput) {\n                    this.historyRevertUntil(this._powerboxBeforeStepIndex);\n                    this.historyStep(true);\n                    this._historyStepsStates.set(peek(this._historySteps).id, 'consumed');\n                    ensureFocus(this.editable);\n                    getDeepRange(this.editable, { select: true });\n                }\n            },\n            afterCommand: () => {\n                this.historyStep(true);\n                this._isPowerboxOpenOnInput = false;\n            },\n            categories: [\n                { name: this.options._t('Structure'), priority: 70 },\n                { name: this.options._t('Format'), priority: 60 },\n                { name: this.options._t('Widgets'), priority: 30 },\n                ...(this.options.categories || []),\n            ],\n            commands: [\n                {\n                    category: this.options._t('Structure'),\n                    name: this.options._t('Bulleted list'),\n                    priority: 110,\n                    description: this.options._t('Create a simple bulleted list'),\n                    fontawesome: 'fa-list-ul',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('toggleList', 'UL');\n                    },\n                },\n                {\n                    category: this.options._t('Structure'),\n                    name: this.options._t('Numbered list'),\n                    priority: 100,\n                    description: this.options._t('Create a list with numbering'),\n                    fontawesome: 'fa-list-ol',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('toggleList', 'OL');\n                    },\n                },\n                {\n                    category: this.options._t('Structure'),\n                    name: this.options._t('Checklist'),\n                    priority: 90,\n                    description: this.options._t('Track tasks with a checklist'),\n                    fontawesome: 'fa-check-square-o',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('toggleList', 'CL');\n                    },\n                },\n                {\n                    category: this.options._t('Structure'),\n                    name: this.options._t('Table'),\n                    priority: 80,\n                    description: this.options._t('Insert a table'),\n                    fontawesome: 'fa-table',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        if(this.isMobile){\n                            this.execCommand('insertTable', {\n                                rowNumber: this.powerboxTablePicker.rowNumber,\n                                colNumber: this.powerboxTablePicker.colNumber,\n                            });\n                        } else {\n                            this.powerboxTablePicker.show();\n                        }\n                    },\n                },\n                {\n                    category: this.options._t('Format'),\n                    name: this.options._t('Heading 1'),\n                    priority: 50,\n                    description: this.options._t('Big section heading'),\n                    fontawesome: 'fa-header',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('setTag', 'H1');\n                    },\n                },\n                {\n                    category: this.options._t('Format'),\n                    name: this.options._t('Heading 2'),\n                    priority: 40,\n                    description: this.options._t('Medium section heading'),\n                    fontawesome: 'fa-header',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('setTag', 'H2');\n                    },\n                },\n                {\n                    category: this.options._t('Format'),\n                    name: this.options._t('Heading 3'),\n                    priority: 30,\n                    description: this.options._t('Small section heading'),\n                    fontawesome: 'fa-header',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('setTag', 'H3');\n                    },\n                },\n                {\n                    category: this.options._t('Format'),\n                    name: this.options._t('Switch direction'),\n                    priority: 20,\n                    description: this.options._t('Switch the text\\'s direction'),\n                    fontawesome: 'fa-exchange',\n                    callback: () => {\n                        this.execCommand('switchDirection');\n                    },\n                },\n                {\n                    category: this.options._t('Format'),\n                    name: this.options._t('Text'),\n                    priority: 10,\n                    description: this.options._t('Paragraph block'),\n                    fontawesome: 'fa-paragraph',\n                    isDisabled: () => !this.isSelectionInBlockRoot(),\n                    callback: () => {\n                        this.execCommand('setTag', 'P');\n                    },\n                },\n                {\n                    category: this.options._t('Widgets'),\n                    name: this.options._t('3 Stars'),\n                    priority: 20,\n                    description: this.options._t('Insert a rating over 3 stars'),\n                    fontawesome: 'fa-star-o',\n                    callback: () => {\n                        let html = '\\u200B<span contenteditable=\"false\" class=\"o_stars o_three_stars\">';\n                        html += Array(3).fill().map(() => '<i class=\"fa fa-star-o\"></i>').join('');\n                        html += '</span>\\u200B';\n                        this.execCommand('insert', parseHTML(this.document, html));\n                    },\n                },\n                {\n                    category: this.options._t('Widgets'),\n                    name: this.options._t('5 Stars'),\n                    priority: 10,\n                    description: this.options._t('Insert a rating over 5 stars'),\n                    fontawesome: 'fa-star',\n                    callback: () => {\n                        let html = '\\u200B<span contenteditable=\"false\" class=\"o_stars o_five_stars\">';\n                        html += Array(5).fill().map(() => '<i class=\"fa fa-star-o\"></i>').join('');\n                        html += '</span>\\u200B';\n                        this.execCommand('insert', parseHTML(this.document, html));\n                    },\n                },\n                ...(this.options.commands || []),\n                ...(!this.options.commands || !this.options.commands.find(c =>  c.name === this.options._t('Separator')) ? [\n                    {\n                        category: this.options._t('Structure'),\n                        name: this.options._t('Separator'),\n                        priority: 40,\n                        description: this.options._t('Insert a horizontal rule separator'),\n                        fontawesome: 'fa-minus',\n                        isDisabled: () => !this.isSelectionInBlockRoot(),\n                        callback: () => {\n                            this.execCommand('insertHorizontalRule');\n                        },\n                    }] : []),\n            ],\n        });\n\n        // -----------\n        // Bind events\n        // -----------\n\n        this.observerActive();\n\n        this.addDomListener(this.editable, 'keydown', this._onKeyDown);\n        this.addDomListener(this.editable, 'input', this._onInput);\n        this.addDomListener(this.editable, 'beforeinput', this._onBeforeInput);\n        this.addDomListener(this.editable, 'mousedown', this._onMouseDown);\n        this.addDomListener(this.editable, 'mouseup', this._onMouseup);\n        this.addDomListener(this.editable, 'mousemove', this._onMousemove);\n        this.addDomListener(this.editable, 'paste', this._onPaste);\n        this.addDomListener(this.editable, 'dragstart', this._onDragStart);\n        this.addDomListener(this.editable, 'drop', this._onDrop);\n        this.addDomListener(this.editable, 'copy', this._onClipboardCopy);\n        this.addDomListener(this.editable, 'cut', this._onClipboardCut);\n\n        this.addDomListener(this.document, 'selectionchange', this._onSelectionChange);\n        this.addDomListener(this.document, 'selectionchange', this._handleCommandHint);\n        this.addDomListener(this.document, 'keydown', this._onDocumentKeydown);\n        this.addDomListener(this.document, 'keyup', this._onDocumentKeyup);\n        this.addDomListener(this.document, 'mouseup', this._onDocumentMouseup);\n        this.addDomListener(this.document, 'click', this._onDocumentClick);\n        this.addDomListener(this.document, 'scroll', this._onScroll, true);\n\n        this.multiselectionRefresh = this.multiselectionRefresh.bind(this);\n        this._resizeObserver = new ResizeObserver(this.multiselectionRefresh);\n        this._resizeObserver.observe(this.document.body);\n        this._resizeObserver.observe(this.editable);\n        this.addDomListener(this.editable, 'scroll', this.multiselectionRefresh);\n\n        if (this._collabClientId) {\n            this._snapshotInterval = setInterval(() => {\n                this._historyMakeSnapshot();\n            }, HISTORY_SNAPSHOT_INTERVAL);\n        }\n\n        // -------\n        // Toolbar\n        // -------\n\n        if (this.options.toolbar) {\n            this.setupToolbar(this.options.toolbar);\n        }\n        // placeholder hint\n        if (editable.textContent === '' && this.options.placeholder) {\n            this._makeHint(editable.firstChild, this.options.placeholder, true);\n        }\n    }\n    /**\n     * Releases anything that was initialized.\n     *\n     * TODO: properly implement this.\n     */\n    destroy() {\n        this.observerUnactive();\n        this._removeDomListener();\n        this.powerbox.destroy();\n        this.powerboxTablePicker.el.remove();\n        this.mainAbsoluteContainer.remove();\n        this._resizeObserver.disconnect();\n        clearInterval(this._snapshotInterval);\n        this._pluginCall('destroy', []);\n        this.isDestroyed = true;\n        // Remove table UI\n        this._rowUi.remove();\n        this._columnUi.remove();\n    }\n\n    setupToolbar(toolbar) {\n        this.toolbar = toolbar;\n        this.autohideToolbar = this.options.autohideToolbar;\n        if (!this.options.showExtendedTextStylesOptions) {\n            this.toolbar.querySelectorAll(\"[data-extended-text-style]\")\n                .forEach(el => el.classList.add(\"d-none\"));\n        }\n        this.bindExecCommand(this.toolbar);\n        // Ensure anchors in the toolbar don't trigger a hash change.\n        const toolbarAnchors = this.toolbar.querySelectorAll('a');\n        toolbarAnchors.forEach(a => a.addEventListener('click', e => e.preventDefault()));\n        for (const colorLabel of this.toolbar.querySelectorAll('label')) {\n            colorLabel.addEventListener('mousedown', ev => {\n                // Hack to prevent loss of focus (done by preventDefault) while still opening\n                // color picker dialog (which is also prevented by preventDefault on chrome,\n                // except when click detail is 2, which happens on a double-click but isn't\n                // triggered by a dblclick event)\n                if (ev.detail < 2) {\n                    ev.preventDefault();\n                    ev.currentTarget.dispatchEvent(new MouseEvent('click', { detail: 2 }));\n                }\n            });\n            colorLabel.addEventListener('input', ev => {\n                this.document.execCommand(ev.target.name, false, ev.target.value);\n                this.updateColorpickerLabels();\n            });\n        }\n        const fontSizeInput = this.toolbar.querySelector('input#fontSizeCurrentValue');\n        this.addDomListener(this.toolbar, 'click', ev => {\n            if (fontSizeInput && !fontSizeInput.readOnly && ev.target.closest('#font-size .dropdown-toggle')) {\n                // If the click opened the font size dropdown, select the input content.\n                fontSizeInput.select();\n            } else if (!this.isSelectionInEditable() && ev.target.nodeName !== 'INPUT') {\n                // Otherwise, if we lost the selection in the editable, restore it.\n                this.historyResetLatestComputedSelection(true);\n            }\n        });\n\n        const applyFontSizeREM = pxStrValue => {\n            const pxValue = parseFloat(pxStrValue);\n            const remValue = this.options.convertNumericToUnit(pxValue, \"px\", \"rem\");\n            this.execCommand(\"setFontSize\", `${remValue}rem`);\n        };\n\n        // Handle the font size input.\n        if (fontSizeInput) {\n            const debouncedOnInputChange = (() => {\n                let handle;\n                return () => new Promise(resolve => {\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        handle = null;\n                        const fontSize = parseInt(fontSizeInput.value);\n                        if (fontSize > 0) {\n                            if (!this.isSelectionInEditable()) {\n                                this.historyResetLatestComputedSelection(true);\n                            }\n                            applyFontSizeREM(fontSize);\n                            fontSizeInput.blur();\n                        }\n                        resolve();\n                    }, 50);\n                });\n            })();\n            this.addDomListener(fontSizeInput, 'change', debouncedOnInputChange);\n        }\n\n        // Handle the font size dropdown.\n        const fontSizeDropdown = this.toolbar.querySelector('#font-size');\n        if (fontSizeDropdown) {\n            this.computeFontSizeSelectorValues(fontSizeDropdown);\n\n            const applyFontSizeChoice = optionEl => {\n                if (!this.isSelectionInEditable()) {\n                    this.historyResetLatestComputedSelection(true);\n                }\n                if (this.options.useResponsiveFontSizes) {\n                    const fontSizeClassName = optionEl.dataset.applyClass;\n                    this.execCommand(\"setFontSize\", undefined);\n                    this.execCommand(\"setFontSizeClassName\", fontSizeClassName);\n                } else {\n                    applyFontSizeREM(optionEl.dataset.value);\n                }\n            };\n            fontSizeDropdown.querySelectorAll('.dropdown-item').forEach(item => {\n                this.addDomListener(item, 'mousedown', ev => {\n                    applyFontSizeChoice(ev.currentTarget);\n                });\n                this.addDomListener(item, 'keydown', ev => {\n                    if (ev.key !== 'Enter') {\n                        return;\n                    }\n                    applyFontSizeChoice(ev.currentTarget);\n                });\n            });\n        }\n\n        this._updateToolbar();\n    }\n\n    /**\n     * Sets the px value for every font size dropdown item.\n     */\n    computeFontSizeSelectorValues(fontSizeDropdownEl) {\n        fontSizeDropdownEl = fontSizeDropdownEl || this.toolbar.querySelector(\"#font-size\");\n\n        let previousItem = null;\n        let previousValue = -1;\n        const style = this.document.defaultView.getComputedStyle(this.document.body);\n        for (const itemEl of fontSizeDropdownEl.querySelectorAll(\"[data-dynamic-value]\")) {\n            const variableName = itemEl.dataset.dynamicValue;\n            const strValue = this.options.getCSSVariableValue(variableName, style);\n            const remValue = parseFloat(strValue);\n            const pxValue = this.options.convertNumericToUnit(remValue, \"rem\", \"px\");\n            // Change the text node value only to preserve the badge element\n            const roundedValue = Math.round(pxValue);\n            itemEl.dataset.value = roundedValue;\n            itemEl.firstChild.textContent = roundedValue;\n\n            // If same value as the previous one, hide the previous one\n            if (previousItem) {\n                previousItem.parentElement.classList.toggle('d-none', Math.abs(pxValue - previousValue) < 0.001);\n            }\n            previousItem = itemEl;\n            previousValue = pxValue;\n        }\n\n        for (const badgeEl of fontSizeDropdownEl.querySelectorAll(\".o_we_font_size_badge\")) {\n            badgeEl.classList.toggle(\"d-none\", !this.options.showResponsiveFontSizesBadges);\n        }\n    }\n\n    resetContent(value) {\n        value = value || '<p><br></p>';\n        this.editable.innerHTML = value;\n        this.sanitize(this.editable);\n        this.historyStep(true);\n        // The unbreakable protection mechanism detects an anomaly and attempts\n        // to trigger a rollback when the content is reset using `innerHTML`.\n        // Prevent this rollback as it would otherwise revert the new content.\n        this._toRollback = false;\n        // Placeholder hint.\n        if (this.editable.textContent === '' && this.options.placeholder) {\n            this._makeHint(this.editable.firstChild, this.options.placeholder, true);\n        }\n        this.multiselectionRefresh();\n    }\n\n    sanitize(target) {\n        this.observerFlush();\n        let record;\n        if (!target) {\n            // If the target is not given,\n            // find the closest common ancestor to all the nodes referenced\n            // in the mutations from the last step.\n            for (record of this._currentStep.mutations) {\n                const node = this.idFind(record.parentId || record.id) || this.editable;\n                if (!this.editable.contains(node)) {\n                    continue;\n                }\n                target = target\n                    ? commonParentGet(target, node, this.editable)\n                    : node;\n            }\n        }\n        if (!target) {\n            return false;\n        }\n\n        // If the common ancestor is in a nested list, make sure to sanitize\n        // that list's parent <li> instead, so there is enough context to\n        // potentially merge sibling nested lists\n        // (eg, <ol>\n        //          <li class=\"oe-nested\"><ul>...</ul></li>\n        //          <li class=\"oe-nested\"><ul>...</ul></li>\n        //      </ol>: these two lists should be merged together so the common\n        // ancestor should be the <ol> element).\n        const nestedListAncestor = closestElement(target, '.oe-nested');\n        if (nestedListAncestor && nestedListAncestor.parentElement) {\n            target = nestedListAncestor.parentElement;\n        }\n\n        // sanitize and mark current position as sanitized\n        sanitize(target, this.editable);\n        this._pluginCall('sanitizeElement',\n                         [target.parentElement || target]);\n        this.options.onPostSanitize(target);\n    }\n\n    addDomListener(element, eventName, callback, useCapture) {\n        const boundCallback = callback.bind(this);\n        this._domListeners.push([element, eventName, boundCallback]);\n        element.addEventListener(eventName, boundCallback, useCapture);\n    }\n\n    /**\n     * Make an absolute container to organise floating elements inside it's own\n     * box and z-index isolation.\n     *\n     * @param {string} containerId An id to add to the container in order to make\n     *              the container more visible in the devtool and potentially\n     *              add css rules for the container and it's children.\n     */\n    makeAbsoluteContainer(containerId) {\n        const container = this.document.createElement('div');\n        container.className = `oe-absolute-container`;\n        container.setAttribute('data-oe-absolute-container-id', containerId);\n        this.mainAbsoluteContainer.append(container);\n        return container;\n    }\n\n    _generateId() {\n        // No need for secure random number.\n        return Math.floor(Math.random() * Math.pow(2,52)).toString();\n    }\n\n    // Assign IDs to src, and dest if defined\n    idSet(node, testunbreak = false) {\n        if (!node.oid) {\n            node.oid = this._generateId();\n        }\n        // In case the id was created by another collaboration client.\n        this._idToNodeMap.set(node.oid, node);\n        // Rollback if node.ouid changed. This ensures that nodes never change\n        // unbreakable ancestors.\n        node.ouid = node.ouid || getOuid(node, true);\n        if (testunbreak && !(node.nodeType === Node.TEXT_NODE && !node.length)) {\n            const ouid = getOuid(node);\n            if (!this._toRollback && ouid && ouid !== node.ouid) {\n                this._toRollback = UNBREAKABLE_ROLLBACK_CODE;\n            }\n        }\n\n        let childNode = node.firstChild;\n        while (childNode) {\n            this.idSet(childNode, testunbreak);\n            childNode = childNode.nextSibling;\n        }\n    }\n\n    idFind(id) {\n        return this._idToNodeMap.get(id);\n    }\n\n    serializeNode(node, mutatedNodes) {\n        return this._collabClientId ? serializeNode(node, mutatedNodes) : node;\n    }\n\n    unserializeNode(node) {\n        return this._collabClientId ? unserializeNode(node) : node;\n    }\n\n    automaticStepActive(label) {\n        this._observerTimeoutUnactive.delete(label);\n    }\n    automaticStepUnactive(label) {\n        this._observerTimeoutUnactive.add(label);\n    }\n    automaticStepSkipStack() {\n        this.automaticStepUnactive('skipStack');\n        setTimeout(() => this.automaticStepActive('skipStack'));\n    }\n    observerUnactive(label) {\n        this._observerUnactiveLabels.add(label);\n        if (this.observer) {\n            clearTimeout(this.observerTimeout);\n            this.observerFlush();\n            this.dispatchEvent(new Event('observerUnactive'));\n            this.observer.disconnect();\n        }\n    }\n    observerFlush() {\n        const records = this.observer.takeRecords();\n        this.observerIdSet(records);\n        this.observerApply(this.filterMutationRecords(records));\n    }\n    observerActive(label) {\n        this._observerUnactiveLabels.delete(label);\n        if (this._observerUnactiveLabels.size !== 0) return;\n\n        if (!this.observer) {\n            this.observer = new MutationObserver(records => {\n                this.observerIdSet(records);\n                records = this.filterMutationRecords(records);\n                if (!records.length) return;\n                this.dispatchEvent(new Event('contentChanged'));\n                clearTimeout(this.observerTimeout);\n                if (this._observerTimeoutUnactive.size === 0) {\n                    this.observerTimeout = setTimeout(() => {\n                        this.historyStep();\n                    }, 100);\n                }\n                this.observerApply(records);\n            });\n        }\n        this.dispatchEvent(new Event('preObserverActive'));\n        this.observer.observe(this.editable, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeOldValue: true,\n            characterData: true,\n            characterDataOldValue: true,\n        });\n        this.dispatchEvent(new Event('observerActive'));\n    }\n\n    observerIdSet(records) {\n        for (const record of records) {\n            if (record.type === 'childList') {\n                this.idSet(record.target);\n            }\n        }\n    }\n\n    observerApply(records) {\n        // There is a case where node A is added and node B is a descendant of\n        // node A where node B was not in the observed tree) then node B is\n        // added into another node. In that case, we need to keep track of node\n        // B so when serializing node A, we strip node B from the node A tree to\n        // avoid the duplication of node A.\n        const mutatedNodes = new Set();\n        for (const record of records) {\n            if (record.type === 'childList') {\n                for (const node of record.addedNodes) {\n                    this.idSet(node, this._checkStepUnbreakable);\n                    mutatedNodes.add(node.oid);\n                }\n                for (const node of record.removedNodes) {\n                    this.idSet(node, this._checkStepUnbreakable);\n                    mutatedNodes.delete(node.oid);\n                }\n            }\n        }\n        for (const record of records) {\n            switch (record.type) {\n                case 'characterData': {\n                    this._currentStep.mutations.push({\n                        'type': 'characterData',\n                        'id': record.target.oid,\n                        'text': record.target.textContent,\n                        'oldValue': record.oldValue,\n                    });\n                    break;\n                }\n                case 'attributes': {\n                    this._currentStep.mutations.push({\n                        'type': 'attributes',\n                        'id': record.target.oid,\n                        'attributeName': record.attributeName,\n                        'value': record.target.getAttribute(record.attributeName),\n                        'oldValue': record.oldValue,\n                    });\n                    break;\n                }\n                case 'childList': {\n                    record.addedNodes.forEach(added => {\n                        if (!this._toRollback && containsUnremovable(added)) {\n                            this._toRollback = UNREMOVABLE_ROLLBACK_CODE;\n                        }\n                        const mutation = {\n                            'type': 'add',\n                        };\n                        if (!record.nextSibling && record.target.oid) {\n                            mutation.append = record.target.oid;\n                        } else if (record.nextSibling && record.nextSibling.oid) {\n                            mutation.before = record.nextSibling.oid;\n                        } else if (!record.previousSibling && record.target.oid) {\n                            mutation.prepend = record.target.oid;\n                        } else if (record.previousSibling && record.previousSibling.oid) {\n                            mutation.after = record.previousSibling.oid;\n                        } else {\n                            return false;\n                        }\n                        mutation.id = added.oid;\n                        mutation.node = this.serializeNode(added, mutatedNodes);\n                        this._currentStep.mutations.push(mutation);\n                    });\n                    record.removedNodes.forEach(removed => {\n                        if (!this._toRollback && containsUnremovable(removed)) {\n                            this._toRollback = UNREMOVABLE_ROLLBACK_CODE;\n                        }\n                        this._currentStep.mutations.push({\n                            'type': 'remove',\n                            'id': removed.oid,\n                            'parentId': record.target.oid,\n                            'node': this.serializeNode(removed),\n                            'nextId': record.nextSibling ? record.nextSibling.oid : undefined,\n                            'previousId': record.previousSibling\n                                ? record.previousSibling.oid\n                                : undefined,\n                        });\n                    });\n                    break;\n                }\n            }\n        }\n        if (records.length) {\n            this.dispatchEvent(new Event('observerApply'));\n        }\n    }\n    filterMutationRecords(records) {\n        // Save the first attribute in a cache to compare only the first\n        // attribute record of node to its latest state.\n        const attributeCache = new Map();\n        const filteredRecords = [];\n\n        for (const record of records) {\n            if (record.type === 'attributes') {\n                // Skip the attributes change on the dom.\n                if (record.target === this.editable) continue;\n                if (record.attributeName === 'contenteditable') {\n                    continue;\n                }\n\n                attributeCache.set(record.target, attributeCache.get(record.target) || {});\n                if (record.attributeName === 'class') {\n                    const classBefore = (record.oldValue && record.oldValue.split(' ')) || [];\n                    const classAfter = (record.target.className && record.target.className.split && record.target.className.split(' ')) || [];\n                    const excludedClasses = [];\n                    for (const klass of classBefore) {\n                        if (!classAfter.includes(klass)) {\n                            excludedClasses.push(klass);\n                        }\n                    }\n                    for (const klass of classAfter) {\n                        if (!classBefore.includes(klass)) {\n                            excludedClasses.push(klass);\n                        }\n                    }\n                    if (excludedClasses.length && excludedClasses.every(c => this.options.renderingClasses.includes(c))) {\n                        continue;\n                    }\n                }\n                if (\n                    typeof attributeCache.get(record.target)[record.attributeName] === 'undefined'\n                ) {\n                    const oldValue = record.oldValue === undefined ? null : record.oldValue;\n                    attributeCache.get(record.target)[record.attributeName] =\n                        oldValue !== record.target.getAttribute(record.attributeName);\n                }\n                if (!attributeCache.get(record.target)[record.attributeName]) {\n                    continue;\n                }\n            }\n            const closestProtectedCandidate = closestElement(record.target, '[data-oe-protected]');\n            if (closestProtectedCandidate) {\n                const protectedValue = closestProtectedCandidate.dataset.oeProtected;\n                switch (protectedValue) {\n                    case \"true\":\n                    case \"\":\n                        if (\n                            record.type !== \"attributes\" ||\n                            record.target !== closestProtectedCandidate ||\n                            isProtected(closestProtectedCandidate.parentElement)\n                        ) {\n                            continue;\n                        }\n                        break;\n                    case \"false\":\n                        if (\n                            record.type === \"attributes\" &&\n                            record.target === closestProtectedCandidate &&\n                            isProtected(closestProtectedCandidate.parentElement)\n                        ) {\n                            continue;\n                        }\n                        break;\n                }\n            }\n            filteredRecords.push(record);\n        }\n        return this.options.filterMutationRecords(filteredRecords);\n    }\n\n    // History\n    // -------------------------------------------------------------------------\n\n    historyReset() {\n        this._historyClean();\n        const firstStep = this._historyGetSnapshotStep();\n        this._firstStepId = firstStep.id;\n        this._historySnapshots = [{ step: firstStep }];\n        this._historySteps.push(firstStep);\n        // The historyIds carry the ids of the steps that were dropped when\n        // doing a snapshot.\n        // Those historyIds are used to compare if the last step saved in the\n        // server is present in the current historySteps or historyIds to\n        // ensure it is the same history branch.\n        this._historyIds = [];\n    }\n    /**\n     * Set the initial document history id.\n     *\n     * To prevent a saving a document with a diverging history, we store the\n     * last history id in the first node of the document to the database.\n     * This method provide the initial document history id to the editor.\n     */\n    historySetInitialId(id) {\n        this._historyIds.unshift(id);\n    }\n    /**\n     * Get all the history ids for the current history branch.\n     *\n     * See `_historyIds` in `historyReset`.\n     */\n    historyGetBranchIds() {\n        return this._historyIds.concat(this._historySteps.map(s => s.id));\n    }\n    historyGetSnapshotSteps() {\n        // If the current snapshot has no time, it means that there is the no\n        // other snapshot that have been made (either it is the one created upon\n        // initialization or reseted by historyResetFromSteps).\n        if (!this._historySnapshots[0].time) {\n            return { steps: this._historySteps, historyIds: this.historyGetBranchIds() };\n        }\n        const steps = [];\n        let snapshot;\n        if (this._historySnapshots[0].time + HISTORY_SNAPSHOT_BUFFER_TIME < Date.now()) {\n            snapshot = this._historySnapshots[0];\n        } else {\n            // this._historySnapshots[1] has being created at least 1 minute ago\n            // (HISTORY_SNAPSHOT_INTERVAL) or it is the first step.\n            snapshot = this._historySnapshots[1];\n        }\n        let index = this._historySteps.length - 1;\n        while (this._historySteps[index].id !== snapshot.step.id) {\n            steps.push(this._historySteps[index]);\n            index--;\n        }\n        steps.push(snapshot.step);\n        steps.reverse();\n\n        return { steps, historyIds: this.historyGetBranchIds() };\n    }\n    historyResetFromSteps(steps, historyIds) {\n        this._historyIds = historyIds;\n        this.observerUnactive();\n        for (const node of [...this.editable.childNodes]) {\n            node.remove();\n        }\n        this._historyClean();\n        for (const step of steps) {\n            this.historyApply(step.mutations);\n        }\n        this._historySnapshots = [{ step: steps[0] }];\n        this._historySteps = steps;\n\n        this._postProcessExternalStepsPromise = this.options.postProcessExternalSteps(this.editable);\n\n        this._handleCommandHint();\n        this.multiselectionRefresh();\n        this.observerActive();\n        this.dispatchEvent(new Event('historyResetFromSteps'));\n    }\n    historyGetSteps() {\n        return this._historySteps;\n    }\n    historyGetMissingSteps({fromStepId, toStepId}) {\n        const fromIndex = this._historySteps.findIndex(x => x.id === fromStepId);\n        const toIndex = toStepId ? this._historySteps.findIndex(x => x.id === toStepId) : this._historySteps.length;\n        if (fromIndex === -1 || toIndex === -1) {\n            return -1;\n        }\n        return this._historySteps.slice(fromIndex + 1, toIndex);\n    }\n\n    // One step completed: apply to vDOM, setup next history step\n    historyStep(skipRollback = false, { stepId } = {}) {\n        if (!this._historyStepsActive) {\n            return;\n        }\n        this._resetLinkZws();\n        this.sanitize();\n        // check that not two unBreakables modified\n        if (this._toRollback) {\n            if (!skipRollback) this.historyRollback();\n            this._toRollback = false;\n        }\n\n        // push history\n        const currentStep = this._currentStep;\n        if (!currentStep.mutations.length) {\n            return false;\n        }\n\n        currentStep.id = stepId || this._generateId();\n        const previousStep = peek(this._historySteps);\n        currentStep.clientId = this._collabClientId;\n        currentStep.previousStepId = previousStep.id;\n\n        this._historySteps.push(currentStep);\n        if (this.options.onHistoryStep) {\n            this.options.onHistoryStep(currentStep);\n        }\n        this._setLinkZws();\n        this._currentStep = {\n            selection: {},\n            mutations: [],\n        };\n        this._checkStepUnbreakable = true;\n        this._recordHistorySelection();\n        this.dispatchEvent(new Event('historyStep'));\n        this.multiselectionRefresh();\n    }\n    // apply changes according to some records\n    historyApply(records) {\n        for (const record of records) {\n            if (record.type === 'characterData') {\n                const node = this.idFind(record.id);\n                if (node) {\n                    node.textContent = record.text;\n                }\n            } else if (record.type === 'attributes') {\n                const node = this.idFind(record.id);\n                if (node) {\n                    let value = record.value;\n                    if (typeof value === 'string' && record.attributeName === 'class') {\n                        value = value.split(' ').filter(c => !this.options.renderingClasses.includes(c)).join(' ');\n                    }\n                    if (this._collabClientId) {\n                        this._safeSetAttribute(node, record.attributeName, value);\n                    } else {\n                        node.setAttribute(record.attributeName, value);\n                    }\n                }\n            } else if (record.type === 'remove') {\n                const toremove = this.idFind(record.id);\n                if (toremove) {\n                    toremove.remove();\n                }\n            } else if (record.type === 'add') {\n                let node = this.idFind(record.oid) || this.unserializeNode(record.node);\n                if (this._collabClientId) {\n                    const fakeNode = document.createElement('fake-el');\n                    fakeNode.appendChild(node);\n                    DOMPurify.sanitize(fakeNode, { IN_PLACE: true });\n                    node = fakeNode.childNodes[0];\n                    if (!node) {\n                        continue;\n                    }\n                }\n\n                this.idSet(node, true);\n\n                if (record.append && this.idFind(record.append)) {\n                    this.idFind(record.append).append(node);\n                } else if (record.before && this.idFind(record.before)) {\n                    this.idFind(record.before).before(node);\n                } else if (record.after && this.idFind(record.after)) {\n                    this.idFind(record.after).after(node);\n                } else {\n                    continue;\n                }\n            }\n        }\n    }\n    historyRollback(until = 0) {\n        const step = this._currentStep;\n        this.observerFlush();\n        this.historyRevert(step, { until });\n        this.observerFlush();\n        step.mutations = step.mutations.slice(0, until);\n        this._toRollback = false;\n    }\n    /**\n     * Undo the current non-recorded draft step.\n     */\n    historyRevertCurrentStep() {\n        this.observerFlush();\n        this.historyRevert(this._currentStep, {sideEffect: false});\n        this.observerFlush();\n        // Clear current step from all previous changes.\n        this._currentStep.mutations = [];\n\n        this._activateContenteditable();\n        this.historySetSelection(this._currentStep);\n    }\n    /**\n     * Undo a step of the history.\n     *\n     * this._historyStepsState is a map from it's location (index) in this.history to a state.\n     * The state can be on of:\n     * undefined: the position has never been undo or redo.\n     * \"redo\": The position is considered as a redo of another.\n     * \"undo\": The position is considered as a undo of another.\n     * \"consumed\": The position has been undone and is considered consumed.\n     */\n    historyUndo() {\n        this.options.preHistoryUndo();\n        // The last step is considered an uncommited draft so always revert it.\n        const lastStep = this._currentStep;\n        this.historyRevert(lastStep);\n        // Clean the last step otherwise if no other step is created after, the\n        // mutations of the revert itself will be added to the same step and\n        // grow exponentially at each undo.\n        lastStep.mutations = [];\n\n        const pos = this._getNextUndoIndex();\n        if (pos > 0) {\n            // Consider the position consumed.\n            this._historyStepsStates.set(this._historySteps[pos].id, 'consumed');\n            this.historyRevert(this._historySteps[pos]);\n            // Consider the last position of the history as an undo.\n            const stepId = this._generateId();\n            this._historyStepsStates.set(stepId, 'undo');\n            this.historyStep(true, { stepId });\n            this.dispatchEvent(new Event('historyUndo'));\n        }\n    }\n    /**\n     * Redo a step of the history.\n     *\n     * @see historyUndo\n     */\n    historyRedo() {\n        // Current step is considered an uncommitted draft, so revert it,\n        // otherwise a redo would not be possible.\n        this.historyRevert(this._currentStep);\n        // At this point, _currentStep.mutations contains the current step's\n        // mutations plus the ones that revert it, with net effect zero.\n        this._currentStep.mutations = [];\n\n        const pos = this._getNextRedoIndex();\n        if (pos > 0) {\n            this._historyStepsStates.set(this._historySteps[pos].id, 'consumed');\n            this.historyRevert(this._historySteps[pos]);\n            this.historySetSelection(this._historySteps[pos]);\n            const stepId = this._generateId();\n            this._historyStepsStates.set(stepId, 'redo');\n            this.historyStep(true, { stepId });\n            this.dispatchEvent(new Event('historyRedo'));\n        }\n    }\n    /**\n     * Check wether undoing is possible.\n     */\n    historyCanUndo() {\n        return this._getNextUndoIndex() > 0;\n    }\n    /**\n     * Check wether redoing is possible.\n     */\n    historyCanRedo() {\n        return this._getNextRedoIndex() > 0;\n    }\n    historySize() {\n        return this._historySteps.length;\n    }\n\n    historyRevert(step, { until = 0, sideEffect = true } = {} ) {\n        // apply dom changes by reverting history steps\n        for (let i = step.mutations.length - 1; i >= until; i--) {\n            const mutation = step.mutations[i];\n            if (!mutation) {\n                break;\n            }\n            switch (mutation.type) {\n                case 'characterData': {\n                    const node = this.idFind(mutation.id);\n                    if (node) node.textContent = mutation.oldValue;\n                    break;\n                }\n                case 'attributes': {\n                    const node = this.idFind(mutation.id);\n                    if (node) {\n                        if (mutation.oldValue) {\n                            let value = mutation.oldValue;\n                            if (typeof value === 'string' && mutation.attributeName === 'class') {\n                                value = value.split(' ').filter(c => !this.options.renderingClasses.includes(c)).join(' ');\n                            }\n                            if (this._collabClientId) {\n                                this._safeSetAttribute(node, mutation.attributeName, value);\n                            } else {\n                                node.setAttribute(mutation.attributeName, value);\n                            }\n                        } else {\n                            node.removeAttribute(mutation.attributeName);\n                        }\n                    }\n                    break;\n                }\n                case 'remove': {\n                    let nodeToRemove = this.idFind(mutation.id);\n                    if (!nodeToRemove) {\n                        nodeToRemove = this.unserializeNode(mutation.node);\n                        const fakeNode = document.createElement('fake-el');\n                        fakeNode.appendChild(nodeToRemove);\n                        DOMPurify.sanitize(fakeNode, { IN_PLACE: true });\n                        nodeToRemove = fakeNode.childNodes[0];\n                        if (!nodeToRemove) {\n                            continue;\n                        }\n                        this.idSet(nodeToRemove);\n                    }\n                    if (mutation.nextId && this.idFind(mutation.nextId)?.isConnected) {\n                        const node = this.idFind(mutation.nextId);\n                        node && node.before(nodeToRemove);\n                    } else if (mutation.previousId && this.idFind(mutation.previousId)?.isConnected) {\n                        const node = this.idFind(mutation.previousId);\n                        node && node.after(nodeToRemove);\n                    } else {\n                        const node = this.idFind(mutation.parentId);\n                        node && node.append(nodeToRemove);\n                    }\n                    break;\n                }\n                case 'add': {\n                    const node = this.idFind(mutation.id);\n                    if (node) {\n                        node.remove();\n                        node.ouid = undefined;\n                    }\n                }\n            }\n        }\n        if (sideEffect) {\n            this.historySetSelection(step);\n        }\n    }\n    /**\n     * Ensure that a callback is called without triggering a rollback.\n     *\n     * If a rollback was set before the callback, do not reset it.\n     */\n    withoutRollback(callback) {\n        const priorRollback = this._toRollback;\n        callback();\n        this.observerFlush();\n        if (!priorRollback) {\n            this._toRollback = false;\n        }\n    }\n    /**\n     * Place the selection on the last known selection position from the history\n     * steps.\n     *\n     * @param {boolean} [limitToEditable=false] When true returns the latest selection that\n     *     happened within the editable.\n     * @returns {boolean}\n     */\n    historyResetLatestComputedSelection(limitToEditable) {\n        const computedSelection = limitToEditable\n            ? this._latestComputedSelectionInEditable\n            : this._latestComputedSelection;\n        if (computedSelection && computedSelection.anchorNode) {\n            const anchorNode = this.idFind(computedSelection.anchorNode.oid);\n            const focusNode = this.idFind(computedSelection.focusNode.oid) || anchorNode;\n            if (anchorNode) {\n                setSelection(\n                    anchorNode,\n                    computedSelection.anchorOffset,\n                    focusNode,\n                    computedSelection.focusOffset,\n                );\n                return true;\n            }\n        }\n        return false;\n    }\n    historySetSelection(step) {\n        if (step.selection && step.selection.anchorNodeOid) {\n            const anchorNode = this.idFind(step.selection.anchorNodeOid);\n            const focusNode = this.idFind(step.selection.focusNodeOid) || anchorNode;\n            if (anchorNode) {\n                setSelection(\n                    anchorNode,\n                    step.selection.anchorOffset,\n                    focusNode,\n                    step.selection.focusOffset !== undefined\n                        ? step.selection.focusOffset\n                        : step.selection.anchorOffset,\n                    false,\n                );\n                // If a table must be selected, ensure it's in the same tick.\n                this._handleSelectionInTable();\n            }\n        }\n    }\n    unbreakableStepUnactive() {\n        if (this._toRollback === UNBREAKABLE_ROLLBACK_CODE) {\n            this._toRollback = false;\n        }\n        this._checkStepUnbreakable = false;\n    }\n    historyPauseSteps() {\n        this._historyStepsActive = false;\n    }\n    historyUnpauseSteps() {\n        this._historyStepsActive = true;\n    }\n    /**\n     * Stash the mutations of the current step to re-apply them later.\n     */\n    historyStash() {\n        if (!this._historyStashedMutations) {\n            this._historyStashedMutations = [];\n        }\n        this._historyStashedMutations.push(...this._currentStep.mutations);\n        this._currentStep.mutations = [];\n    }\n    /**\n     * Unstash the previously stashed mutations into the current step.\n     */\n    historyUnstash() {\n        if (!this._currentStep.mutations) {\n            this._currentStep.mutations = [];\n        }\n        this._currentStep.mutations.unshift(...this._historyStashedMutations);\n        this._historyStashedMutations = [];\n    }\n    _historyClean() {\n        this._historySteps = [];\n        this._currentStep = {\n            selection: {\n                anchorNodeOid: undefined,\n                anchorOffset: undefined,\n                focusNodeOid: undefined,\n                focusOffset: undefined,\n            },\n            mutations: [],\n            id: undefined,\n            clientId: undefined,\n        };\n        this._historyStepsStates = new Map();\n    }\n    _historyGetSnapshotStep() {\n        return {\n            selection: {\n                anchorNode: undefined,\n                anchorOffset: undefined,\n                focusNode: undefined,\n                focusOffset: undefined,\n            },\n            mutations: Array.from(this.editable.childNodes).map(node => ({\n                type: 'add',\n                append: 1,\n                id: node.oid,\n                node: this.serializeNode(node),\n            })),\n            id: this._generateId(),\n            clientId: this.clientId,\n            previousStepId: undefined,\n        };\n    }\n    _historyMakeSnapshot() {\n        if (\n            !this._lastSnapshotHistoryLength ||\n            this._lastSnapshotHistoryLength < this._historySteps.length\n        ) {\n            this._lastSnapshotHistoryLength = this._historySteps.length;\n            const step = this._historyGetSnapshotStep();\n            step.id = this._historySteps[this._historySteps.length - 1].id;\n            const snapshot = {\n                time: Date.now(),\n                step: step,\n            };\n            this._historySnapshots = [snapshot, this._historySnapshots[0]];\n        }\n    }\n    /**\n     * Insert a step from another collaborator.\n     */\n    _historyAddExternalStep(newStep) {\n        let index = this._historySteps.length - 1;\n        while (index >= 0 && this._historySteps[index].id !== newStep.previousStepId) {\n            // Skip steps that are already in the list.\n            if (this._historySteps[index].id === newStep.id) {\n                return;\n            }\n            index--;\n        }\n\n        // When the previousStepId is not present in the this._historySteps it\n        // could be either:\n        // - the previousStepId is before a snapshot of the same history\n        // - the previousStepId has not been received because clients were\n        //   disconnected at that time\n        // - the previousStepId is in another history (in case two totally\n        //   differents this._historySteps (but it should not arise)).\n        if (index < 0) {\n            if (this.options.onHistoryMissingParentSteps) {\n                const historySteps = this._historySteps;\n                let index = historySteps.length - 1;\n                // Get the last known step that we are sure the missing step\n                // client has. It could either be a step that has the same\n                // clientId or the first step.\n                while(index !== 0) {\n                    if (historySteps[index].clientId === newStep.clientId) {\n                        break;\n                    }\n                    index--;\n                }\n                const fromStepId = historySteps[index].id;\n                this.options.onHistoryMissingParentSteps({\n                    step: newStep,\n                    fromStepId: fromStepId,\n                });\n            }\n            return;\n        }\n\n        let concurentSteps = [];\n        index++;\n        while (index < this._historySteps.length) {\n            if (this._historySteps[index].previousStepId === newStep.previousStepId) {\n                if (this._historySteps[index].id.localeCompare(newStep.id) === 1) {\n                    break;\n                } else {\n                    concurentSteps = [this._historySteps[index].id];\n                }\n            } else {\n                if (concurentSteps.includes(this._historySteps[index].previousStepId)) {\n                    concurentSteps.push(this._historySteps[index].id);\n                } else {\n                    break;\n                }\n            }\n            index++;\n        }\n\n        const stepsAfterNewStep = this._historySteps.slice(index);\n\n        for (const stepToRevert of stepsAfterNewStep.slice().reverse()) {\n            this.historyRevert(stepToRevert, { sideEffect: false });\n        }\n        this.historyApply(newStep.mutations);\n        this._historySteps.splice(index, 0, newStep);\n        for (const stepToApply of stepsAfterNewStep) {\n            this.historyApply(stepToApply.mutations);\n        }\n    }\n    collaborationSetClientId(id) {\n        this._collabClientId = id;\n    }\n\n    /**\n     * Apply external steps coming from the collaboration. Buffer them if\n     * _postProcessExternalStepsPromise is not null until it is resolved (since\n     * steps could potentially concern elements currently being rendered\n     * asynchronously).\n     *\n     * @param {Object} newSteps External steps to be applied\n     */\n    onExternalHistorySteps(newSteps) {\n        if (this._postProcessExternalStepsPromise) {\n            this._externalStepsBuffer.push(...newSteps);\n        }\n        this.observerUnactive();\n        this._computeHistorySelection();\n\n        let stepIndex = 0;\n        for (const newStep of newSteps) {\n            this._historyAddExternalStep(newStep);\n            stepIndex++;\n            this._postProcessExternalStepsPromise = this.options.postProcessExternalSteps(this.editable);\n            if (this._postProcessExternalStepsPromise) {\n                this._postProcessExternalStepsPromise.then(() => {\n                    this._postProcessExternalStepsPromise = undefined;\n                    this.onExternalHistorySteps(this._externalStepsBuffer);\n                });\n                this._externalStepsBuffer = newSteps.slice(stepIndex);\n                break;\n            }\n        }\n\n        this.observerActive();\n        this.historyResetLatestComputedSelection();\n        this._handleCommandHint();\n        this.multiselectionRefresh();\n        this.dispatchEvent(new Event('onExternalHistorySteps'));\n    }\n\n    // Multi selection\n    // -------------------------------------------------------------------------\n\n    onExternalMultiselectionUpdate(selection) {\n        const { clientId } = selection;\n        const currentInfo = this._collabSelectionInfos.get(clientId);\n        if (currentInfo) {\n            currentInfo.selection = selection;\n        } else {\n            this._collabSelectionInfos.set(clientId, { selection });\n        }\n        this._drawClientSelection(selection);\n        this._drawClientAvatar(selection);\n        this._updateAvatarCounters();\n    }\n\n    multiselectionRefresh() {\n        for (const { selection } of this._collabSelectionInfos.values()) {\n            this._drawClientSelection(selection);\n            this._drawClientAvatar(selection);\n        }\n        this._updateAvatarCounters();\n    }\n\n    _drawClientSelection({ selection, color, clientId, clientName = this.options._t('Anonymous') }) {\n        this._multiselectionRemoveClient(clientId);\n        let clientRects;\n\n        let anchorNode = this.idFind(selection.anchorNodeOid);\n        let focusNode = this.idFind(selection.focusNodeOid);\n        let anchorOffset = selection.anchorOffset;\n        let focusOffset = selection.focusOffset;\n        if (!anchorNode || !focusNode) {\n            anchorNode = this.editable.children[0];\n            focusNode = this.editable.children[0];\n            anchorOffset = 0;\n            focusOffset = 0;\n        }\n\n        [anchorNode, anchorOffset] = getDeepestPosition(anchorNode, anchorOffset);\n        [focusNode, focusOffset] = getDeepestPosition(focusNode, focusOffset);\n\n        const direction = getCursorDirection(\n            anchorNode,\n            anchorOffset,\n            focusNode,\n            focusOffset,\n        );\n        const range = new Range();\n        try {\n            if (direction === DIRECTIONS.RIGHT) {\n                range.setStart(anchorNode, anchorOffset);\n                range.setEnd(focusNode, focusOffset);\n            } else {\n                range.setStart(focusNode, focusOffset);\n                range.setEnd(anchorNode, anchorOffset);\n            }\n\n            clientRects = Array.from(range.getClientRects());\n        } catch {\n            // Changes in the dom might prevent the range to be instantiated\n            // (because of a removed node for example), in which case we ignore\n            // the range.\n            clientRects = [];\n        }\n        if (!clientRects.length) {\n            return;\n        }\n\n        // Draw rects (in case the selection is not collapsed).\n        const containerRect = this._selectionsContainer.getBoundingClientRect();\n        const indicators = clientRects.map(({ x, y, width, height }) => {\n            const rectElement = this.document.createElement('div');\n            rectElement.style = `\n                position: absolute;\n                top: ${y - containerRect.y}px;\n                left: ${x - containerRect.x}px;\n                width: ${width}px;\n                height: ${height}px;\n                background-color: ${color};\n                opacity: 0.25;\n                pointer-events: none;\n            `;\n            rectElement.setAttribute('data-selection-client-id', clientId);\n            return rectElement;\n        });\n\n        // Draw carret.\n        const caretElement = this.document.createElement('div');\n        caretElement.style = `border-left: 2px solid ${color}; position: absolute;`;\n        caretElement.setAttribute('data-selection-client-id', clientId);\n        caretElement.className = 'oe-collaboration-caret';\n\n        // Draw carret top square.\n        const caretTopSquare = this.document.createElement('div');\n        caretTopSquare.className = 'oe-collaboration-caret-top-square';\n        caretTopSquare.style['background-color'] = color;\n        caretTopSquare.setAttribute('data-client-name', clientName);\n        caretElement.append(caretTopSquare);\n\n        if (direction === DIRECTIONS.LEFT) {\n            const rect = clientRects[0];\n            caretElement.style.height = `${rect.height * 1.2}px`;\n            caretElement.style.top = `${rect.y - containerRect.y}px`;\n            caretElement.style.left = `${rect.x - containerRect.x}px`;\n        } else {\n            const rect = peek(clientRects);\n            caretElement.style.height = `${rect.height * 1.2}px`;\n            caretElement.style.top = `${rect.y - containerRect.y}px`;\n            caretElement.style.left = `${rect.right - containerRect.x}px`;\n        }\n        this._selectionsContainer.append(caretElement, ...indicators);\n    }\n\n    _drawClientAvatar({ selection, clientId, clientAvatarUrl = '', clientName = this.options._t('Anonymous') }) {\n        const anchorNode = this.idFind(selection.anchorNodeOid);\n        const focusNode = this.idFind(selection.focusNodeOid);\n        if (!anchorNode || !focusNode) {\n            return;\n        }\n        const anchorBlock = closestBlock(anchorNode);\n        if (!anchorBlock) return;\n\n        const containerRect = this._avatarsContainer.getBoundingClientRect();\n\n        // Draw user avatar.\n        const selectionInfo = this._collabSelectionInfos.get(clientId) || {};\n        let avatarElement = selectionInfo.avatarElement;\n        if (!avatarElement) {\n            avatarElement = this.document.createElement('div');\n            avatarElement.className = 'oe-collaboration-caret-avatar';\n            avatarElement.style.display = 'none';\n            const image = this.document.createElement('img');\n            avatarElement.append(image);\n            image.onload = () => avatarElement.style.removeProperty('display');\n            image.setAttribute('src', clientAvatarUrl);\n        }\n        // Avoid re-appending the element in the dom.\n        if (!avatarElement.parentElement) {\n            this._avatarsContainer.append(avatarElement);\n        }\n        // Make sure data is up to date.\n        selectionInfo.avatarElement = avatarElement;\n        selectionInfo.clientName = clientName;\n        selectionInfo.avatarTargetElement = anchorBlock;\n        this._collabSelectionInfos.set(clientId, selectionInfo);\n\n        const anchorBlockRect = anchorBlock.getBoundingClientRect();\n        const top = anchorBlockRect.y - containerRect.y;\n        avatarElement.style.top = top + 'px';\n        const closestList = closestElement(anchorNode, 'ul, ol'); // Prevent overlap bullets.\n        const anchorX = closestList ? closestList.getBoundingClientRect().x : anchorBlockRect.x;\n        const left = anchorX - containerRect.x - AVATAR_SIZE;\n        avatarElement.style.left = left + 'px';\n        selectionInfo.avatarPositionKey = `${left}|${top}`;\n    }\n\n    _updateAvatarCounters() {\n        this._avatarsOverlaps = {};\n        for (const info of this._collabSelectionInfos.values()) {\n            const key =  info.avatarPositionKey;\n            this._avatarsOverlaps[key] = this._avatarsOverlaps[key] || new Set();\n            this._avatarsOverlaps[key].add(info);\n        }\n\n        // Render avatars overlap.\n        this._avatarsCountersContainer.replaceChildren();\n        for (const [overlapKey, infos] of Object.entries(this._avatarsOverlaps)) {\n            const size = infos.size;\n            if (size > 1) {\n                const [left, top] = overlapKey.split('|').map((n) => parseInt(n, 10));\n                const div = document.createElement('div');\n                div.className = 'oe-overlapping-counter';\n                div.style.left = left + 10 + 'px';\n                div.style.top = top + 10 + 'px';\n                div.innerText = size;\n                this._avatarsCountersContainer.append(div);\n            }\n        }\n    }\n\n    multiselectionRemove(clientId) {\n        const selectionInfo = this._collabSelectionInfos.get(clientId);\n        if (selectionInfo && selectionInfo.avatarElement) {\n            selectionInfo.avatarElement.remove();\n        }\n        this._multiselectionRemoveClient(clientId)\n        this._collabSelectionInfos.delete(clientId);\n        this._updateAvatarCounters();\n    }\n\n    _multiselectionRemoveClient(clientId) {\n        const elements = this._selectionsContainer.querySelectorAll(\n            `[data-selection-client-id=\"${clientId}\"]`,\n        );\n        for (const element of elements) {\n            element.remove();\n        }\n    }\n\n    _setLinkZws() {\n        this._resetLinkZws();\n        const selection = this.document.getSelection();\n        if (!selection.isCollapsed) {\n            return;\n        }\n        const linkInSelection = getInSelection(this.document, EDITABLE_LINK_SELECTOR);\n        const isLinkSelection = selection.anchorNode === linkInSelection;\n        let commonAncestorContainer = selection.rangeCount && selection.getRangeAt(0).commonAncestorContainer;\n        if (commonAncestorContainer) {\n            // Consider all the links in the closest block that contains the\n            // whole selection, limiting to the editable.\n            if (!this.editable.contains(commonAncestorContainer)) {\n                commonAncestorContainer = this.editable;\n            }\n            let block = closestBlock(commonAncestorContainer);\n            if (!block || !this.editable.contains(block)) {\n                block = this.editable;\n            }\n            let links = [...block.querySelectorAll(EDITABLE_LINK_SELECTOR)];\n            // Consider the links at the edges of the sibling blocks, limiting\n            // to the editable.\n            if (this.editable.contains(block)) {\n                links.push(\n                    closestElement(previousLeaf(block, this.editable, true), EDITABLE_LINK_SELECTOR),\n                    closestElement(nextLeaf(block, this.editable, true), EDITABLE_LINK_SELECTOR),\n                );\n            }\n            const offset = selection.anchorOffset;\n            let didAddZwsInLinkInSelection = false;\n            for (const link of links) {\n                if (\n                    link &&\n                    link.textContent.trim() !== '' &&\n                    // Only add the ZWS for simple (possibly styled) text links.\n                    ![link, ...link.querySelectorAll('*')].some(isBlock)\n                ) {\n                    this._insertLinkZws('start', link);\n                    // Only add the ZWS at the end if the link is in selection.\n                    if (link === linkInSelection) {\n                        this._insertLinkZws('end', link);\n                        this.observerUnactive('_setLinkZws_o_link_in_selection');\n                        link.classList.add('o_link_in_selection');\n                        this.observerActive('_setLinkZws_o_link_in_selection');\n                        didAddZwsInLinkInSelection = true;\n                    }\n                    const zwsAfter = this._insertLinkZws('after', link);\n                    if (!zwsAfter.parentElement || !zwsAfter.parentElement.isContentEditable) {\n                        this.observerUnactive('_setLinkZws_zwsAfter_remove');\n                        zwsAfter.remove();\n                        this.observerActive('_setLinkZws_zwsAfter_remove');\n                    }\n                }\n            }\n            if (isLinkSelection && offset && didAddZwsInLinkInSelection) {\n                // Correct the offset if the link is in selection, to account\n                // for the added ZWS.\n                setSelection(linkInSelection, Math.min(offset + 1, linkInSelection.childNodes.length));\n            }\n        }\n    }\n\n    /**\n     * Same as @see _applyCommand, except that also simulates all the\n     * contenteditable behaviors we let happen, e.g. the backspace handling\n     * we then rollback.\n     *\n     * TODO this uses document.execCommand (which is deprecated) and relies on\n     * the fact that using a command through it leads to the same result as\n     * executing that command through a user keyboard on the unaltered editable\n     * section with standard contenteditable attribute. This is already a huge\n     * assomption.\n     *\n     * @param {string} method\n     * @returns {?}\n     */\n    execCommand(...args) {\n        this._computeHistorySelection();\n        return this._applyCommand(...args);\n    }\n\n    /**\n     * Find all descendants of `element` with a `data-call` attribute and bind\n     * them on click to the execution of the command matching that\n     * attribute.\n     */\n    bindExecCommand(element) {\n        for (const buttonEl of element.querySelectorAll('[data-call]')) {\n            buttonEl.addEventListener('click', ev => {\n                if (!this.isSelectionInEditable()) {\n                    this.historyResetLatestComputedSelection(true);\n                }\n                const arg1 = buttonEl.dataset.arg1;\n                const args = arg1 && arg1.split(\",\") || [];\n                this.execCommand(buttonEl.dataset.call, ...args);\n\n                ev.preventDefault();\n                this._updateToolbar();\n            });\n        }\n    }\n\n    /**\n     * Remove any custom table selection from the editor.\n     *\n     * @returns {boolean} true if a table was deselected\n     */\n    deselectTable() {\n        this.observerUnactive('deselectTable');\n        let didDeselectTable = false;\n        for (const td of this.editable.querySelectorAll('.o_selected_table, .o_selected_td')) {\n            td.classList.remove('o_selected_td', 'o_selected_table');\n            if (!td.classList.length) {\n                td.removeAttribute('class');\n            }\n            didDeselectTable = true;\n        }\n        this.observerActive('deselectTable');\n        return didDeselectTable;\n    }\n\n    /**\n     * `activateContenteditable` serves as an interface for external use,\n     * allowing users to conveniently trigger `_activateContenteditable`\n     * from outside the odooEditor.\n     */\n    activateContenteditable() {\n        this._activateContenteditable();\n    }\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    _removeDomListener() {\n        for (const [element, eventName, boundCallback] of this._domListeners) {\n            element.removeEventListener(eventName, boundCallback);\n        }\n        this._domListeners = [];\n    }\n\n    // EDITOR COMMANDS\n    // ===============\n\n    deleteRange(sel) {\n        if (this.deleteTableRange()) {\n            return;\n        }\n        if (!this.editable.childElementCount) {\n            // Ensure the editable has content.\n            const p = document.createElement('p');\n            p.append(document.createElement('br'));\n            this.editable.append(p);\n            setSelection(p, 0);\n            return;\n        }\n        let range = getDeepRange(this.editable, {\n            sel,\n            splitText: true,\n            select: true,\n            correctTripleClick: true,\n        });\n        if (!range) return;\n        // Expand the range to fully include all contentEditable=False elements.\n        const commonAncestorContainer = this.editable.contains(range.commonAncestorContainer) ?\n            range.commonAncestorContainer :\n            this.editable;\n        const startUneditable = getFurthestUneditableParent(range.startContainer, commonAncestorContainer);\n        if (startUneditable) {\n            let leaf = previousLeaf(startUneditable);\n            if (leaf) {\n                range.setStart(leaf, nodeSize(leaf));\n            } else {\n                range.setStart(commonAncestorContainer, 0);\n            }\n        }\n        const endUneditable = getFurthestUneditableParent(range.endContainer, commonAncestorContainer);\n        if (endUneditable) {\n            let leaf = nextLeaf(endUneditable);\n            if (leaf) {\n                range.setEnd(leaf, 0);\n            } else {\n                range.setEnd(commonAncestorContainer, nodeSize(commonAncestorContainer));\n            }\n        }\n        let insertedZws;\n        let { startContainer: start, startOffset, endContainer: end, endOffset } = range;\n        const startBlock = closestBlock(start);\n        const endBlock = closestBlock(end);\n        const [firstLeafOfStartBlock, lastLeafOfEndBlock] = [firstLeaf(startBlock), lastLeaf(endBlock)];\n        if (sel && !sel.isCollapsed && !range.startOffset && !range.startContainer.previousSibling) {\n            // Insert a zero-width space before the selection if the selection\n            // is non-collapsed and at the beginning of its parent, so said\n            // parent will have content after extraction. This ensures that the\n            // parent will not be removed by \"tricking\" `range.extractContents`.\n            // Eg, <h1><font>[...]</font></h1> will preserve the styles of the\n            // <font> node. If it remains empty, it will be cleaned up later by\n            // the sanitizer.\n            const zws = document.createTextNode('\\u200B');\n            range.startContainer.before(zws);\n            insertedZws = zws;\n        }\n        // Do not join blocks in the following cases:\n        // 1. start and end share a common ancestor block with the range\n        // 2. selection spans multiple TDs\n        // 3. selection starts at beginning of startBlock and ends at end of\n        //    endBlock\n        const doJoin =\n            !(startBlock === closestBlock(range.commonAncestorContainer) &&\n                endBlock === closestBlock(range.commonAncestorContainer))\n            && (startBlock.tagName !== 'TD' && endBlock.tagName !== 'TD')\n            && !(firstLeafOfStartBlock === start && lastLeafOfEndBlock === end);\n        let next = nextLeaf(end, this.editable);\n\n        // Get the boundaries of the range so as to get the state to restore.\n        if (end.nodeType === Node.TEXT_NODE) {\n            splitTextNode(end, endOffset);\n            endOffset = nodeSize(end);\n        }\n        if (start.nodeType === Node.TEXT_NODE) {\n            splitTextNode(start, startOffset);\n            startOffset = 0;\n        }\n        const restoreUpdate = prepareUpdate(\n            ...boundariesOut(start).slice(0, 2),\n            ...boundariesOut(end).slice(2, 4),\n            { allowReenter: false, label: 'deleteRange' });\n\n        // Let the DOM split and delete the range.\n        const contents = range.extractContents();\n\n        setSelection(start, nodeSize(start));\n        const startLi = closestElement(start, 'li');\n        // Uncheck a list item with empty text in multi-list selection.\n        if (startLi && startLi.classList.contains('o_checked') &&\n            startLi.textContent === '\\u200B' && closestElement(end, 'li') !== startLi) {\n            startLi.classList.remove('o_checked');\n        }\n        range = getDeepRange(this.editable, { sel });\n        // Restore unremovables removed by extractContents.\n        [...contents.querySelectorAll('*')].filter(isUnremovable).forEach(n => {\n            closestBlock(range.endContainer).after(n);\n            n.textContent = '';\n        });\n        // If the end container was fully selected, extractContents may have\n        // emptied it without removing it. Ensure it's gone.\n        const isRemovableInvisible = node =>\n            !isVisible(node) && !isZWS(node) && !isUnremovable(node);\n        const endIsStart = end === start;\n        while (end && isRemovableInvisible(end) && !end.contains(range.endContainer)) {\n            const parent = end.parentNode;\n            end.remove();\n            end = parent;\n        }\n        // Same with the start container\n        while (\n            start &&\n            !isBlock(start) && isRemovableInvisible(start) &&\n            !(endIsStart && start.contains(range.startContainer))\n        ) {\n            const parent = start.parentNode;\n            start.remove();\n            start = parent;\n        }\n        // Ensure empty blocks be given a <br> child.\n        if (start) {\n            fillEmpty(closestBlock(start));\n        }\n        fillEmpty(closestBlock(range.endContainer));\n        let joinWith = range.endContainer;\n        const rightLeaf = rightLeafOnlyNotBlockPath(joinWith).next().value;\n        if (rightLeaf && rightLeaf.nodeValue === ' ') {\n            joinWith = rightLeaf;\n        }\n        // Rejoin blocks that extractContents may have split in two.\n        while (\n            doJoin &&\n            next &&\n            !(next.previousSibling && next.previousSibling === joinWith) &&\n            this.editable.contains(next) && (closestElement(joinWith,'TD') === closestElement(next, 'TD'))\n        ) {\n            const restore = preserveCursor(this.document);\n            this.observerFlush();\n            const res = this._protect(() => {\n                next.oDeleteBackward();\n                if (!this.editable.contains(joinWith)) {\n                    this._toRollback = UNREMOVABLE_ROLLBACK_CODE; // tried to delete too far -> roll it back.\n                } else {\n                    next = firstLeaf(next);\n                }\n            }, this._currentStep.mutations.length);\n            if ([UNBREAKABLE_ROLLBACK_CODE, UNREMOVABLE_ROLLBACK_CODE].includes(res)) {\n                restore();\n                break;\n            }\n        }\n        // If the oDeleteBackward loop emptied the start block and the range\n        // ends in another element (rangeStart !== rangeEnd), we delete the\n        // start block and move the cursor to the end block.\n        if (\n            startBlock &&\n            startBlock.textContent === '\\u200B' &&\n            endBlock &&\n            startBlock !== endBlock &&\n            !isEmptyBlock(endBlock) &&\n            paragraphRelatedElements.includes(endBlock.nodeName)\n        ) {\n            startBlock.remove();\n            setSelection(endBlock, 0);\n            fillEmpty(endBlock);\n        }\n        if (insertedZws) {\n            // Remove the zero-width space (zws) that was added to preserve the\n            // parent styles, then call `fillEmpty` to properly add a flagged\n            // zws if still needed.\n            const el = closestElement(insertedZws);\n            const next = insertedZws.nextSibling;\n            insertedZws.remove();\n            el && fillEmpty(el);\n            setSelection(next, 0);\n        }\n        if (joinWith) {\n            const el = closestElement(joinWith);\n            el && fillEmpty(el);\n        }\n        const restoreCursor = preserveCursor(this.document);\n        restoreUpdate();\n        restoreCursor();\n    }\n\n    /**\n     * Handle range deletion in cases that involve custom table selections.\n     * Return true if nodes removed _inside_ a table, false otherwise (or if the\n     * table itself was removed).\n     *\n     * @param {Selection} sel\n     * @returns {boolean}\n     */\n    deleteTableRange() {\n        const selectedTds = this.editable.querySelectorAll('.o_selected_td');\n        const fullySelectedTables = [...this.editable.querySelectorAll('.o_selected_table')].filter(table => (\n            [...table.querySelectorAll('td')].every(td => td.classList.contains('o_selected_td'))\n        ));\n        if (selectedTds.length && !fullySelectedTables.length) {\n            this.historyPauseSteps();\n            // A selection within a table has to be handled differently so it\n            // takes into account the custom table cell selections, and doesn't\n            // break the table. If the selection includes a table cell but also\n            // elements that are out of a table, the whole table will be\n            // selected so its deletion can be handled separately.\n            const rows = [...closestElement(selectedTds[0], 'tr').parentElement.children].filter(child => child.nodeName === 'TR');\n            const firstRowCells = [...rows[0].children].filter(child => child.nodeName === 'TD' || child.nodeName === 'TH');\n            const areFullColumnsSelected = getRowIndex(selectedTds[0]) === 0 && getRowIndex(selectedTds[selectedTds.length - 1]) === rows.length - 1;\n            const areFullRowsSelected = getColumnIndex(selectedTds[0]) === 0 && getColumnIndex(selectedTds[selectedTds.length - 1]) === firstRowCells.length - 1;\n            if (areFullColumnsSelected || areFullRowsSelected) {\n                // If some full columns are selected, remove them.\n                if (areFullColumnsSelected) {\n                    const startIndex = getColumnIndex(selectedTds[0]);\n                    let endIndex = getColumnIndex(selectedTds[selectedTds.length - 1]);\n                    let currentIndex = startIndex;\n                    while (currentIndex <= endIndex) {\n                        this.execCommand('removeColumn', firstRowCells[currentIndex]);\n                        currentIndex++;\n                    }\n                }\n                // If some full rows are selected, remove them.\n                if (areFullRowsSelected) {\n                    const startIndex = getRowIndex(selectedTds[0]);\n                    let endIndex = getRowIndex(selectedTds[selectedTds.length - 1]);\n                    let currentIndex = startIndex;\n                    while (currentIndex <= endIndex) {\n                        this.execCommand('removeRow', rows[currentIndex]);\n                        currentIndex++;\n                    }\n                }\n            } else {\n                // If no full row or column is selected, empty the selected cells.\n                for (const td of selectedTds) {\n                    [...td.childNodes].forEach(child => child.remove());\n                    td.append(document.createElement('br'));\n                }\n            }\n            this.historyUnpauseSteps();\n            this.historyStep();\n            return true;\n        } else if (fullySelectedTables.length) {\n            fullySelectedTables.forEach(table => table.remove());\n        }\n        this._toggleTableUi();\n        return false;\n    }\n\n    /**\n     * Displays the text colors (foreground ink and background highlight)\n     * based on the current text cursor position. For gradients, displays\n     * the average color of the gradient.\n     *\n     * @param {object} [params]\n     * @param {string} [params.foreColor] - forces the 'foreColor' in the\n     *     toolbar instead of determining it from the cursor position\n     * @param {string} [params.hiliteColor] - forces the 'hiliteColor' in the\n     *     toolbar instead of determining it from the cursor position\n     */\n    updateColorpickerLabels(params = {}) {\n        function hexFromColor(color) {\n            if (isColorGradient(color)) {\n                // For gradients, compute the average color\n                color = color.match(/gradient(.*)/)[0];\n                let r = 0, g = 0, b = 0, count = 0;\n                for (const entry of color.matchAll(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/g)) {\n                    count++;\n                    r += parseInt(entry[1], 10);\n                    g += parseInt(entry[2], 10);\n                    b += parseInt(entry[3], 10);\n                }\n                color = `rgb(${Math.round(r / count)}, ${Math.round(g / count)}, ${Math.round(b / count)})`;\n            }\n            return rgbToHex(color);\n        }\n        let foreColor = params.foreColor;\n        let hiliteColor = params.hiliteColor;\n\n        // Determine colors at cursor position\n        const sel = this.document.getSelection();\n        if (sel.rangeCount && (!foreColor || !hiliteColor)) {\n            const endContainer = closestElement(sel.getRangeAt(0).endContainer);\n            const computedStyle = getComputedStyle(endContainer);\n            const backgroundImage = computedStyle.backgroundImage;\n            const hasGradient = isColorGradient(backgroundImage);\n            const hasTextGradientClass = endContainer.classList.contains('text-gradient');\n            if (!foreColor) {\n                if (hasGradient && hasTextGradientClass) {\n                    foreColor = backgroundImage;\n                } else {\n                    foreColor = this.document.queryCommandValue('foreColor');\n                }\n            }\n            if (!hiliteColor) {\n                if (hasGradient && !hasTextGradientClass) {\n                    hiliteColor = backgroundImage;\n                } else {\n                    let ancestor = endContainer;\n                    while (ancestor && !hiliteColor) {\n                        hiliteColor = ancestor.style.backgroundColor;\n                        ancestor = ancestor.parentElement;\n                    }\n                    if (!hiliteColor) {\n                        hiliteColor = computedStyle.backgroundColor;\n                    }\n                }\n            }\n        }\n\n        // display colors in toolbar buttons\n        foreColor = hexFromColor(foreColor);\n        this.toolbar.style.setProperty('--fore-color', foreColor);\n        const foreColorInput = this.toolbar.querySelector('#foreColor input');\n        if (foreColorInput) {\n            foreColorInput.value = foreColor;\n        }\n\n        hiliteColor = hexFromColor(hiliteColor);\n        this.toolbar.style.setProperty('--hilite-color', hiliteColor);\n        const hiliteColorInput = this.toolbar.querySelector('#hiliteColor input');\n        if (hiliteColorInput) {\n            hiliteColorInput.value = hiliteColor.length <= 7 ? hiliteColor : hexFromColor(hiliteColor);\n        }\n    }\n\n    /**\n     * Applies the given command to the current selection. This does *NOT*:\n     * 1) update the history cursor\n     * 2) protect the unbreakables or unremovables\n     * 3) sanitize the result\n     * 4) create new history entry\n     * 5) follow the exact same operations that would be done following events\n     *    that would lead to that command\n     *\n     * For points 1 -> 4, @see _applyCommand\n     * For points 1 -> 5, @see execCommand\n     *\n     * @private\n     * @param {string} method\n     * @returns {?}\n     */\n    _applyRawCommand(method, ...args) {\n        const sel = this.document.getSelection();\n        if (sel.anchorNode && isProtected(sel.anchorNode)) {\n            return;\n        }\n        if (\n            !(SELECTIONLESS_COMMANDS.includes(method) && args.length) && (\n                !this.editable.contains(sel.anchorNode) ||\n                (sel.anchorNode !== sel.focusNode && !this.editable.contains(sel.focusNode))\n            )\n        ) {\n            // Do not apply commands out of the editable area.\n            return false;\n        }\n        this._resetLinkZws();\n        if (!sel.isCollapsed && BACKSPACE_FIRST_COMMANDS.includes(method)) {\n            let range = getDeepRange(this.editable, {sel, splitText: true, select: true, correctTripleClick: true});\n            if (range &&\n                range.startContainer === range.endContainer &&\n                range.endContainer.nodeType === Node.TEXT_NODE &&\n                range.cloneContents().textContent === '\\u200B'\n            ) {\n                // We Collapse the selection and bypass deleteRange\n                // if the range content is only one ZWS.\n                sel.collapseToStart();\n                if (BACKSPACE_ONLY_COMMANDS.includes(method)) {\n                    this._applyRawCommand(method);\n                }\n                return;\n            }\n            this.deleteRange(sel);\n            if (BACKSPACE_ONLY_COMMANDS.includes(method)) {\n                return true;\n            }\n        }\n        if (editorCommands[method]) {\n            return editorCommands[method](this, ...args);\n        }\n        if (method.startsWith('justify')) {\n            const mode = method.split('justify').join('').toLocaleLowerCase();\n            return this._align(mode === 'full' ? 'justify' : mode);\n        }\n        return sel.anchorNode[method](sel.anchorOffset, ...args);\n    }\n\n    /**\n     * Same as @see _applyRawCommand but adapt history, protects unbreakables\n     * and removables and sanitizes the result.\n     *\n     * @private\n     * @param {string} method\n     * @returns {?}\n     */\n    _applyCommand(...args) {\n        this._recordHistorySelection(true);\n        const result = this._protect(() => this._applyRawCommand(...args));\n        this.historyStep();\n        this._handleCommandHint();\n        return result;\n    }\n    /**\n     * @private\n     * @param {function} callback\n     * @param {number} [rollbackCounter]\n     * @returns {?}\n     */\n    _protect(callback, rollbackCounter) {\n        try {\n            const result = callback.call(this);\n            this.observerFlush();\n            if (this._toRollback) {\n                const torollbackCode = this._toRollback;\n                this.historyRollback(rollbackCounter);\n                return torollbackCode; // UNBREAKABLE_ROLLBACK_CODE || UNREMOVABLE_ROLLBACK_CODE\n            } else {\n                return result;\n            }\n        } catch (error) {\n            if (error === UNBREAKABLE_ROLLBACK_CODE || error === UNREMOVABLE_ROLLBACK_CODE) {\n                this.historyRollback(rollbackCounter);\n                return error;\n            } else {\n                throw error;\n            }\n        }\n    }\n    _resetLinkZws(element = this.editable) {\n        this.observerUnactive('_resetLinkZws');\n        element.querySelectorAll('[data-o-link-zws]').forEach(zws => zws.remove());\n        element.querySelectorAll('.o_link_in_selection').forEach(link => link.classList.remove('o_link_in_selection'));\n        this.observerActive('_resetLinkZws');\n    }\n    _activateContenteditable() {\n        this.observerUnactive('_activateContenteditable');\n        this.editable.setAttribute('contenteditable', this.options.isRootEditable);\n\n        const editableAreas = this.options.getContentEditableAreas(this);\n        for (const node of editableAreas) {\n            if (!node.isContentEditable) {\n                if (isArtificialVoidElement(node) || node.nodeName === 'IMG') {\n                    node.classList.add('o_editable_media');\n                } else {\n                    node.setAttribute('contenteditable', true);\n                }\n            }\n        }\n        for (const node of this.options.getReadOnlyAreas()) {\n            node.setAttribute('contenteditable', false);\n        }\n        for (const element of this.options.getUnremovableElements()) {\n            element.classList.add(\"oe_unremovable\");\n        }\n        this.observerActive('_activateContenteditable');\n    }\n    _stopContenteditable() {\n        this.observerUnactive('_stopContenteditable');\n        if (this.options.isRootEditable) {\n            this.editable.setAttribute('contenteditable', !this.options.isRootEditable);\n        }\n        for (const node of this.options.getContentEditableAreas(this)) {\n            if (node.getAttribute('contenteditable') === 'true') {\n                node.setAttribute('contenteditable', false);\n            }\n        }\n        this.observerActive('_stopContenteditable');\n    }\n\n    // TABLE MANAGEMENT\n    // ================\n\n    /**\n     * Handle the selection of table cells rectangularly (as opposed to line by\n     * line from left to right then top to bottom). If such a special selection\n     * was indeed applied, return true (and false otherwise).\n     *\n     * @private\n     * @param {MouseEvent|undefined} [ev]\n     * @returns {boolean}\n     */\n    _handleSelectionInTable(ev=undefined) {\n        const selection = this.document.getSelection();\n        // Selection could be gone if the document comes from an iframe that has been removed.\n        const anchorNode = selection && selection.rangeCount && selection.getRangeAt(0) && selection.anchorNode;\n        if (anchorNode && !ancestors(anchorNode).includes(this.editable)) {\n            return false;\n        }\n        const traversedNodes = getTraversedNodes(this.editable);\n        if (this._isResizingTable || !traversedNodes.some(node => !!closestElement(node, 'td') && !isProtected(node))) {\n            return false;\n        }\n        let range;\n        if (selection.rangeCount > 1) {\n            // Firefox selection in table works with multiple ranges.\n            const startRange = getDeepRange(this.editable, {range: selection.getRangeAt(0)});\n            const endRange = getDeepRange(this.editable, {range: selection.getRangeAt(selection.rangeCount - 1)});\n            range = this.document.createRange();\n            range.setStart(startRange.startContainer, 0);\n            range.setEnd(endRange.startContainer, 0);\n        } else {\n            // We need the triple click correction only for a bug in firefox\n            // where it gives a selection of a full cell as tr 0 tr 1. The\n            // correction makes it so it gives us the cell and not its neighbor.\n            // In all other cases we don't want to make that correction so as to\n            // avoid flicker when hovering borders.\n            range = getDeepRange(this.editable, { correctTripleClick: anchorNode && anchorNode.nodeName === 'TR' });\n        }\n        const startTd = closestElement(range.startContainer, 'td');\n        const endTd = closestElement(range.endContainer, 'td');\n        let appliedCustomSelection = false;\n        // Get the top table ancestors at range bounds.\n        const startTable = ancestors(range.startContainer, this.editable).filter(node => node.nodeName === 'TABLE').pop();\n        const endTable = ancestors(range.endContainer, this.editable).filter(node => node.nodeName === 'TABLE').pop();\n        if (startTd !== endTd && startTable === endTable) {\n            if (!isProtected(startTable)) {\n                // The selection goes through at least two different cells ->\n                // select cells.\n                this._selectTableCells(range);\n                appliedCustomSelection = true;\n            }\n        } else if (!traversedNodes.every(node => node.parentElement && closestElement(node.parentElement, 'table'))) {\n            // The selection goes through a table but also outside of it ->\n            // select the whole table.\n            this.observerUnactive('handleSelectionInTable');\n            const traversedTables = new Set(\n                traversedNodes\n                    .map((node) => closestElement(node, \"table\"))\n                    .filter((node) => !isProtected(node))\n            );\n            for (const table of traversedTables) {\n                // Don't apply several nested levels of selection.\n                if (table && !ancestors(table, this.editable).some(node => [...traversedTables].includes(node))) {\n                    table.classList.toggle('o_selected_table', true);\n                    for (const td of [...table.querySelectorAll('td')].filter(td => closestElement(td, 'table') === table)) {\n                        td.classList.toggle('o_selected_td', true);\n                    }\n                    appliedCustomSelection = true;\n                }\n            }\n            this.observerActive('handleSelectionInTable');\n        } else if (ev && startTd && !isProtected(startTd)) {\n            // We're redirected from a mousemove event.\n            const selectedNodes = getSelectedNodes(this.editable);\n            const areCellContentsFullySelected = descendants(startTd).filter(d => !isBlock(d)).every(child => selectedNodes.includes(child));\n            if (areCellContentsFullySelected) {\n                const SENSITIVITY = 5;\n                const rangeRect = range.getBoundingClientRect();\n                const isMovingAwayFromSelection = ev.clientX > rangeRect.x + rangeRect.width + SENSITIVITY // moving right\n                    || ev.clientX < rangeRect.x - SENSITIVITY; // moving left\n                if (isMovingAwayFromSelection) {\n                    // A cell is fully selected and the mouse is moving away\n                    // from the selection, within said cell -> select the cell.\n                    this._selectTableCells(range);\n                    appliedCustomSelection = true;\n                }\n            } else if (!isVisible(startTd) &&\n                ev.clientX - (this._lastMouseClickPosition ? this._lastMouseClickPosition[0] : ev.clientX) >= 15\n            ) {\n                // Handle selecting an empty cell.\n                this._selectTableCells(range);\n                appliedCustomSelection = true;\n            }\n        }\n        return appliedCustomSelection;\n    }\n    /**\n     * Helper function to `_handleSelectionInTable`. Do the actual selection of\n     * cells in a table based on the current range.\n     *\n     * @private\n     * @see _handleSelectionInTable\n     * @param {Range} range\n     */\n    _selectTableCells(range) {\n        this.observerUnactive('_selectTableCells');\n        const table = closestElement(range.commonAncestorContainer, 'table');\n        const alreadyHadSelection = table.classList.contains('o_selected_table');\n        this.deselectTable(); // Undo previous selection.\n        table.classList.toggle('o_selected_table', true);\n        const columns = [...table.querySelectorAll('td')].filter(td => closestElement(td, 'table') === table);\n        const startCol = [range.startContainer, ...ancestors(range.startContainer, this.editable)]\n            .find(node => node.nodeName === 'TD' && closestElement(node, 'table') === table) || columns[0];\n        const endCol = [range.endContainer, ...ancestors(range.endContainer, this.editable)]\n            .find(node => node.nodeName === 'TD' && closestElement(node, 'table') === table) || columns[columns.length - 1];\n        const [startRow, endRow] = [closestElement(startCol, 'tr'), closestElement(endCol, 'tr')];\n        const [startColIndex, endColIndex] = [getColumnIndex(startCol), getColumnIndex(endCol)];\n        const [startRowIndex, endRowIndex] = [getRowIndex(startRow), getRowIndex(endRow)];\n        const [minRowIndex, maxRowIndex] = [Math.min(startRowIndex, endRowIndex), Math.max(startRowIndex, endRowIndex)];\n        const [minColIndex, maxColIndex]  = [Math.min(startColIndex, endColIndex), Math.max(startColIndex, endColIndex)];\n        // Create an array of arrays of tds (each of which is a row).\n        const grid = [...table.querySelectorAll('tr')]\n            .filter(tr => closestElement(tr, 'table') === table)\n            .map(tr => [...tr.children].filter(child => child.nodeName === 'TD'));\n        for (const tds of grid.filter((_, index) => index >= minRowIndex && index <= maxRowIndex)) {\n            for (const td of tds.filter((_, index) => index >= minColIndex && index <= maxColIndex)) {\n                td.classList.toggle('o_selected_td', true);\n            }\n        }\n        if (!alreadyHadSelection) {\n            this.toolbarShow();\n        }\n        this.observerActive('_selectTableCells');\n    }\n    /**\n     * If the mouse is hovering over one of the borders of a table cell element,\n     * return the side of that border ('left'|'top'|'right'|'bottom').\n     * Otherwise, return false.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     * @returns {boolean}\n     */\n    _isHoveringTdBorder(ev) {\n        if (ev.target && ev.target.nodeName === 'TD' && ev.target.isContentEditable) {\n            const SENSITIVITY = 5;\n            const targetRect = ev.target.getBoundingClientRect();\n            if (ev.clientX <= targetRect.x + SENSITIVITY) {\n                return 'left';\n            } else if (ev.clientY <= targetRect.y + SENSITIVITY) {\n                return 'top';\n            } else if (ev.clientX >= targetRect.x + ev.target.clientWidth - SENSITIVITY) {\n                return 'right';\n            } else if (ev.clientY >= targetRect.y + ev.target.clientHeight - SENSITIVITY) {\n                return 'bottom';\n            }\n        }\n        return false;\n    }\n    /**\n     * Change the cursor to a resizing cursor, in the direction specified. If no\n     * direction is specified, return the cursor to its default.\n     *\n     * @private\n     * @param {'col'|'row'|false} direction 'col'/'row' to hint column/row,\n     *                                      false to remove the hints\n     */\n    _toggleTableResizeCursor(direction) {\n        this.editable.classList.remove('o_col_resize', 'o_row_resize');\n        if (direction === 'col') {\n            this.editable.classList.add('o_col_resize');\n        } else if (direction === 'row') {\n            this.editable.classList.add('o_row_resize');\n        }\n    }\n    /**\n     * Resizes a table in the given direction, by \"pulling\" the border between\n     * the given targets (ordered left to right or top to bottom).\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _resizeTable(ev, direction, target1, target2) {\n        ev.preventDefault();\n        const position = target1 ? (target2 ? 'middle' : 'last') : 'first';\n        let [item, neighbor] = [target1 || target2, target2];\n        const table = closestElement(item, 'table');\n        const [sizeProp, positionProp, clientPositionProp] = direction === 'col' ? ['width', 'x', 'clientX'] : ['height', 'y', 'clientY'];\n\n        // Preserve current sizes.\n        const tableRect = table.getBoundingClientRect();\n        table.style[sizeProp] = tableRect[sizeProp] + 'px';\n        const unsizedItemsSelector = `${direction === 'col' ? 'td' : 'tr'}:not([style*=${sizeProp}])`;\n        for (const unsizedItem of table.querySelectorAll(unsizedItemsSelector)) {\n            unsizedItem.style[sizeProp] = unsizedItem.getBoundingClientRect()[sizeProp] + 'px';\n        }\n\n        // TD widths should only be applied in the first row. Change targets and\n        // clean the rest.\n        if (direction === 'col') {\n            let hostCell = closestElement(table, 'td');\n            const hostCells = [];\n            while (hostCell) {\n                hostCells.push(hostCell);\n                hostCell = closestElement(hostCell.parentElement, 'td');\n            }\n            const nthColumn = getColumnIndex(item);\n            const firstRow = [...table.querySelector('tr').children];\n            [item, neighbor] = [firstRow[nthColumn], firstRow[nthColumn + 1]];\n            for (const td of hostCells) {\n                if (td !== item && td !== neighbor && closestElement(td, 'table') === table && getColumnIndex(td) !== 0) {\n                    td.style.removeProperty(sizeProp);\n                }\n            }\n        }\n\n        const MIN_SIZE = 33; // TODO: ideally, find this value programmatically.\n        switch (position) {\n            case 'first': {\n                const marginProp = direction === 'col' ? 'marginLeft' : 'marginTop';\n                const itemRect = item.getBoundingClientRect();\n                const tableStyle = getComputedStyle(table);\n                const currentMargin = pxToFloat(tableStyle[marginProp]);\n                const sizeDelta = itemRect[positionProp] - ev[clientPositionProp];\n                const newMargin = currentMargin - sizeDelta;\n                const currentSize = itemRect[sizeProp];\n                const newSize = currentSize + sizeDelta;\n                if (newMargin >= 0 && newSize > MIN_SIZE) {\n                    const tableRect = table.getBoundingClientRect();\n                    // Check if a nested table would overflow its parent cell.\n                    const hostCell = closestElement(table.parentElement, 'td');\n                    const childTable = item.querySelector('table');\n                    if (direction === 'col' &&\n                        (hostCell && tableRect.right + sizeDelta > hostCell.getBoundingClientRect().right - 5 ||\n                        childTable && childTable.getBoundingClientRect().right > itemRect.right + sizeDelta - 5)) {\n                        break;\n                    }\n                    table.style[marginProp] = newMargin + 'px';\n                    item.style[sizeProp] = newSize + 'px';\n                    table.style[sizeProp] = tableRect[sizeProp] + sizeDelta + 'px';\n                }\n                break;\n            }\n            case 'middle': {\n                const [itemRect, neighborRect] = [item.getBoundingClientRect(), neighbor.getBoundingClientRect()];\n                const [currentSize, newSize] = [itemRect[sizeProp], ev[clientPositionProp] - itemRect[positionProp]];\n                const editableStyle = getComputedStyle(this.editable);\n                const sizeDelta = newSize - currentSize;\n                const currentNeighborSize = neighborRect[sizeProp];\n                const newNeighborSize = currentNeighborSize - sizeDelta;\n                const maxWidth = this.editable.clientWidth - pxToFloat(editableStyle.paddingLeft) - pxToFloat(editableStyle.paddingRight);\n                const tableRect = table.getBoundingClientRect();\n                if (newSize > MIN_SIZE &&\n                        // prevent resizing horizontally beyond the bounds of\n                        // the editable:\n                        (direction === 'row' ||\n                        newNeighborSize > MIN_SIZE ||\n                        tableRect[sizeProp] + sizeDelta < maxWidth)) {\n\n                    // Check if a nested table would overflow its parent cell.\n                    const childTable = item.querySelector('table');\n                    if (direction === 'col' &&\n                        childTable && childTable.getBoundingClientRect().right > itemRect.right + sizeDelta - 5) {\n                        break\n                    }\n                    item.style[sizeProp] = newSize + 'px';\n                    if (direction === 'col') {\n                        neighbor.style[sizeProp] = (newNeighborSize > MIN_SIZE ? newNeighborSize : currentNeighborSize) + 'px';\n                    } else {\n                        table.style[sizeProp] = tableRect[sizeProp] + sizeDelta + 'px';\n                    }\n                }\n                break;\n            }\n            case 'last': {\n                const itemRect = item.getBoundingClientRect();\n                const sizeDelta = ev[clientPositionProp] - (itemRect[positionProp] + itemRect[sizeProp]); // todo: rephrase\n                const currentSize = itemRect[sizeProp];\n                const newSize = currentSize + sizeDelta;\n                if ((newSize >= 0 || direction === 'row') && newSize > MIN_SIZE) {\n                    const tableRect = table.getBoundingClientRect();\n                    // Check if a nested table would overflow its parent cell.\n                    const hostCell = closestElement(table.parentElement, 'td');\n                    const childTable = item.querySelector('table');\n                    if (direction === 'col' &&\n                        (hostCell && tableRect.right + sizeDelta > hostCell.getBoundingClientRect().right - 5 ||\n                        childTable && childTable.getBoundingClientRect().right > itemRect.right + sizeDelta - 5)) {\n                        break\n                    }\n                    table.style[sizeProp] = tableRect[sizeProp] + sizeDelta + 'px';\n                    item.style[sizeProp] = newSize + 'px';\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Show/hide and position the table row/column manipulation UI.\n     *\n     * @private\n     * @param {HTMLTableRowElement} [row=false]\n     * @param {HTMLTableCellElement} [column=false]\n     */\n    _toggleTableUi(row=false, column=false) {\n        if (row) {\n            this._rowUi.style.visibility = 'visible';\n            this._rowUiTarget = row;\n            this._positionTableUi(row);\n        } else {\n            this._rowUi.style.visibility = 'hidden';\n        }\n        if (column) {\n            this._columnUi.style.visibility = 'visible';\n            this._columnUiTarget = column;\n            this._positionTableUi(column);\n        } else {\n            this._columnUi.style.visibility = 'hidden';\n        }\n        if (row || column) {\n            this._tableUiTarget = closestElement(row || column, 'table');\n            this._tableUiTarget && this._tableUiTarget.addEventListener('mouseleave', () => this._toggleTableUi(), { once: true });\n        }\n    }\n    /**\n     * Position the table row/column tools (depending on whether a row or a cell\n     * is passed as argument).\n     *\n     * @private\n     * @param {HTMLTableRowElement|HTMLTableCellElement} element\n     */\n    _positionTableUi(element) {\n        if (!element.isConnected) {\n            return;\n        }\n        const tableUiContainerRect = this._tableUiContainer.getBoundingClientRect();\n        const isRtl = this.options.direction === 'rtl';\n        const isRow = element.nodeName === 'TR';\n        const ui = isRow ? this._rowUi : this._columnUi;\n        const elementRect = element.getBoundingClientRect();\n        const wrappedUi = ui.firstElementChild;\n        const table = closestElement(element, 'table');\n        const tableRect = table && table.getBoundingClientRect();\n        const resetTableSize = ui.querySelector('.o_reset_table_size');\n        if (table && !table.hasAttribute('style')) {\n            resetTableSize.classList.add('d-none');\n        } else {\n            resetTableSize.classList.remove('d-none');\n        }\n\n        let left;\n        let top;\n        if (isRow) {\n            if (isRtl) {\n                left = tableRect.right - tableUiContainerRect.x;\n            } else {\n                left = elementRect.left - tableUiContainerRect.left - wrappedUi.clientWidth;\n            }\n        } else if (isRtl) {\n            left = elementRect.left - tableUiContainerRect.left + wrappedUi.clientWidth;\n        } else {\n            left = elementRect.left - tableUiContainerRect.left - (isRow ? wrappedUi.clientWidth : 0);\n        }\n        top = elementRect.top - tableUiContainerRect.top - (isRow ? 0 : wrappedUi.clientHeight);\n\n        ui.style.left = left + 'px';\n        ui.style.top = top + 'px';\n        wrappedUi.style[isRow ? 'height' : 'width'] = elementRect[isRow ? 'height' : 'width'] + 'px';\n\n    }\n\n    // HISTORY\n    // =======\n\n    /**\n     * @private\n     * @returns {Object}\n     */\n    _computeHistorySelection() {\n        const sel = this.document.getSelection();\n        if (!(sel && sel.anchorNode)) {\n            return this._latestComputedSelection;\n        }\n        this._latestComputedSelection = {\n            anchorNode: sel.anchorNode,\n            anchorOffset: sel.anchorOffset,\n            focusNode: sel.focusNode,\n            focusOffset: sel.focusOffset,\n        };\n        if (this.isSelectionInEditable(sel)) {\n            this._latestComputedSelectionInEditable = this._latestComputedSelection;\n        }\n        return this._latestComputedSelection;\n    }\n    /**\n     * @private\n     * @param {boolean} [useCache=false]\n     */\n    _recordHistorySelection(useCache = false) {\n        this._currentStep.selection =\n            serializeSelection(\n                useCache ? this._latestComputedSelection : this._computeHistorySelection(),\n            ) || {};\n    }\n    /**\n     * Return true if the latest computed selection was inside an empty inline tag\n     *\n     * @private\n     * @return {boolean}\n     */\n    _isLatestComputedSelectionInsideEmptyInlineTag() {\n        if (!this._latestComputedSelection) {\n            return false;\n        }\n        const anchorNode = this._latestComputedSelection.anchorNode;\n        const focusNode = this._latestComputedSelection.focusNode;\n        const parentTextContent = anchorNode.parentElement? anchorNode.parentElement.textContent : null;\n        return anchorNode === focusNode && (parentTextContent === '' || parentTextContent === '\\u200B')\n    }\n    /**\n     * Get the step index in the history to undo.\n     * Return -1 if no undo index can be found.\n     */\n    _getNextUndoIndex() {\n        // Go back to first step that can be undone (\"redo\" or undefined).\n        for (let index = this._historySteps.length - 1; index >= 0; index--) {\n            if (\n                this._historySteps[index] &&\n                this._historySteps[index].clientId === this._collabClientId\n            ) {\n                const state = this._historyStepsStates.get(this._historySteps[index].id);\n                if (state === 'redo' || !state) {\n                    return index;\n                }\n            }\n        }\n        // There is no steps left to be undone, return an index that does not\n        // point to any step\n        return -1;\n    }\n    /**\n     * Get the step index in the history to redo.\n     * Return -1 if no redo index can be found.\n     */\n    _getNextRedoIndex() {\n        // We cannot redo more than what is consumed.\n        // Check if we have no more \"consumed\" than \"redo\" until we get to an\n        // \"undo\"\n        let totalConsumed = 0;\n        for (let index = this._historySteps.length - 1; index >= 0; index--) {\n            if (\n                this._historySteps[index] &&\n                this._historySteps[index].clientId === this._collabClientId\n            ) {\n                const state = this._historyStepsStates.get(this._historySteps[index].id);\n                switch (state) {\n                    case 'undo':\n                        return totalConsumed <= 0 ? index : -1;\n                    case 'redo':\n                        totalConsumed -= 1;\n                        break;\n                    case 'consumed':\n                        totalConsumed += 1;\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n        }\n        return -1;\n    }\n    historyRevertUntil (toStepIndex) {\n        const lastStep = this._currentStep;\n        this.historyRevert(lastStep);\n        let stepIndex = this._historySteps.length - 1;\n        while (stepIndex > toStepIndex) {\n            const step = this._historySteps[stepIndex];\n            const stepState = this._historyStepsStates.get(step.id);\n            if (step.clientId === this._collabClientId && stepState !== 'consumed') {\n                this.historyRevert(this._historySteps[stepIndex]);\n                this._historyStepsStates.set(''+step.id, 'consumed');\n            }\n            stepIndex--;\n        }\n    }\n\n    // TOOLBAR\n    // =======\n\n    toolbarHide() {\n        this._updateToolbar(false);\n    }\n    toolbarShow() {\n        this._updateToolbar(true);\n    }\n    /**\n     * @private\n     * @param {boolean} [show]\n     */\n    _updateToolbar(show) {\n        if (!this.toolbar) {\n            return;\n        }\n        if (!this.autohideToolbar && this.toolbar.style.visibility !== 'visible') {\n            this.toolbar.style.visibility = 'visible';\n        }\n\n        const sel = this.document.getSelection();\n        if (!hasTableSelection(this.editable)) {\n            if (this.editable.classList.contains('o_col_resize') || this.editable.classList.contains('o_row_resize')) {\n                show = false;\n            }\n            if (!sel.anchorNode) {\n                show = false;\n            } else {\n                const selAncestors = [sel.anchorNode, ...ancestors(sel.anchorNode, this.editable)];\n                const isInStars = selAncestors.some(node => node.classList && node.classList.contains('o_stars'));\n                if (isInStars) {\n                    show = false;\n                }\n            }\n        }\n        if (this.autohideToolbar && !this.toolbar.contains(sel.anchorNode)) {\n            if (!this.isMobile) {\n                if (this.powerboxTablePicker.el.style.display === 'block') {\n                    this.toolbar.style.visibility = 'hidden';\n                    return;\n                }\n                if (show !== undefined) {\n                    this.toolbar.style.visibility = show ? 'visible' : 'hidden';\n                }\n                if (show === false) {\n                    for (const menu of this.toolbar.querySelectorAll('.dropdown-menu.show')) {\n                        menu.parentElement?.querySelector('[data-bs-toggle=\"dropdown\"]')?.click();\n                    };\n                    return;\n                }\n            }\n        }\n        if (!this.isSelectionInEditable(sel)) {\n            return;\n        }\n        const paragraphDropdownButton = this.toolbar.querySelector('#paragraphDropdownButton');\n        if (paragraphDropdownButton) {\n            for (const commandState of [\n                'justifyLeft',\n                'justifyRight',\n                'justifyCenter',\n                'justifyFull',\n            ]) {\n                const button = this.toolbar.querySelector('#' + commandState);\n                const direction = commandState === 'justifyFull'\n                    ? 'justify' : commandState.replace('justify', '').toLowerCase();\n                let isStateTrue = false;\n                const link = sel.anchorNode && closestElement(sel.anchorNode, 'a');\n                const linkBlock = link && closestBlock(link);\n                if (linkBlock) {\n                    // We don't support links with a width that is larger than\n                    // their contents so an alignment within the link is not\n                    // visible. Since the editor applies alignments to a node's\n                    // closest block, we show the alignment of the link's\n                    // closest block.\n                    const alignment = getComputedStyle(linkBlock).textAlign;\n                    isStateTrue = alignment === direction;\n                } else {\n                    isStateTrue = this.document.queryCommandState(commandState)\n                }\n                button.classList.toggle('active', isStateTrue);\n                const newClass = `fa-align-${direction}`;\n                paragraphDropdownButton.classList.toggle(newClass, isStateTrue);\n            }\n        }\n        if (sel.rangeCount) {\n            // queryCommandState does not take stylesheets into account\n            for (const format of ['bold', 'italic', 'underline', 'strikeThrough', 'switchDirection']) {\n                const formatButton = this.toolbar.querySelector(`#${format.toLowerCase()}`);\n                if (formatButton) {\n                    formatButton.classList.toggle('active', isSelectionFormat(this.editable, format));\n                }\n            }\n\n            const fontSizeEl = this.toolbar.querySelector(\"#fontSizeCurrentValue\");\n            if (fontSizeEl) {\n                fontSizeEl.value = Math.round(getFontSizeDisplayValue(sel,\n                    this.options.getCSSVariableValue,\n                    this.options.convertNumericToUnit\n                ));\n            }\n\n            const table = getInSelection(this.document, 'table');\n            const toolbarButton = this.toolbar.querySelector('.toolbar-edit-table');\n            if (toolbarButton) {\n                this.toolbar.querySelector('.toolbar-edit-table').style.display = table\n                    ? 'block'\n                    : 'none';\n            }\n        }\n        this.updateColorpickerLabels();\n        const listUIClasses = {UL: 'fa-list-ul', OL: 'fa-list-ol', CL: 'fa-tasks'};\n        const block = closestBlock(sel.anchorNode);\n        let activeLabel = undefined;\n        for (const [style, cssSelector, isList] of [\n            // TODO we might want to review this list to not mention o_xxx\n            // classes but be a setting instead? Probably after current\n            // refactorings being made in master.\n            ['paragraph', 'p:not(.small, .lead, .o_small)', false],\n            ['pre', 'pre', false],\n            ['heading1', 'h1:not(.display-1, .display-2, .display-3, .display-4)', false],\n            ['heading2', 'h2', false],\n            ['heading3', 'h3', false],\n            ['heading4', 'h4', false],\n            ['heading5', 'h5', false],\n            ['heading6', 'h6', false],\n            ['display-1', 'h1.display-1', false],\n            ['display-2', 'h1.display-2', false],\n            ['display-3', 'h1.display-3', false],\n            ['display-4', 'h1.display-4', false],\n            ['blockquote', 'blockquote', false],\n            // Note: this button will apply the \"o_small\" class but as an\n            // approximation, we display \"Small\" if this actually use the\n            // Bootstrap \"small\" class.\n            ['small', '.small, .o_small', false],\n            ['light', '.lead', false],\n            ['unordered', 'UL', true],\n            ['ordered', 'OL', true],\n            ['checklist', 'CL', true],\n        ]) {\n            const button = this.toolbar.querySelector('#' + style);\n            if (button && !block) {\n                button.classList.toggle('active', false);\n            } else if (button) {\n                const isActive = isList\n                    ? block.tagName === 'LI' && getListMode(block.parentElement) === cssSelector\n                    : block.matches(cssSelector);\n                button.classList.toggle('active', isActive);\n\n                if (!isList && isActive) {\n                    activeLabel = button.textContent;\n                }\n            }\n        }\n        if (block) {\n            const listMode = getListMode(block.parentElement);\n            const listDropdownButton = this.toolbar.querySelector('#listDropdownButton');\n            if (listDropdownButton) {\n                if (listMode) {\n                    listDropdownButton.classList.remove('fa-list-ul', 'fa-list-ol', 'fa-tasks');\n                    listDropdownButton.classList.add(listUIClasses[listMode]);\n                }\n                listDropdownButton.closest('button').classList.toggle('active', block.tagName === 'LI');\n            }\n        }\n\n        const styleSection = this.toolbar.querySelector('#style');\n        if (styleSection) {\n            if (!activeLabel) {\n                // If no element from the text style dropdown was marked as active,\n                // mark the paragraph one as active and use its label.\n                const firstButtonEl = styleSection.querySelector('#paragraph');\n                firstButtonEl.classList.add('active');\n                activeLabel = firstButtonEl.textContent;\n            }\n            styleSection.querySelector('button span').textContent = activeLabel;\n        }\n\n        const isInMedia = this.toolbar.classList.contains('oe-media');\n        const linkNode = getInSelection(this.document, 'a');\n        const linkButton = this.toolbar.querySelector('#create-link');\n        linkButton && linkButton.classList.toggle('active', !!linkNode);\n        // Hide unlink button if no link in selection, always hide on media\n        // elements.\n        const unlinkButton = this.toolbar.querySelector('#unlink');\n        unlinkButton?.classList.toggle('d-none', isInMedia || !linkNode);\n        const undoButton = this.toolbar.querySelector('#undo');\n        undoButton && undoButton.classList.toggle('disabled', !this.historyCanUndo());\n        const redoButton = this.toolbar.querySelector('#redo');\n        redoButton && redoButton.classList.toggle('disabled', !this.historyCanRedo());\n\n        // Hide create-link button if selection spans several blocks, always\n        // hide on media elements.\n        const range = getDeepRange(this.editable, { sel, correctTripleClick: true });\n        const spansBlocks = [...range.commonAncestorContainer.childNodes].some(isBlock);\n        linkButton?.classList.toggle('d-none', spansBlocks || isInMedia);\n\n        // Hide link button group if it has no visible button.\n        const linkBtnGroup = this.toolbar.querySelector('#link.btn-group');\n        linkBtnGroup?.classList.toggle('d-none', !linkBtnGroup.querySelector('.btn:not(.d-none)'));\n        if (this.autohideToolbar && !this.isMobile && !this.toolbar.contains(sel.anchorNode)) {\n            this._positionToolbar();\n        }\n    }\n\n    updateToolbarPosition() {\n        if (\n            this.autohideToolbar &&\n            !this.isMobile &&\n            getComputedStyle(this.toolbar).visibility === 'visible'\n        ) {\n            this._positionToolbar();\n        }\n    }\n\n    _positionToolbar() {\n        const OFFSET = 10;\n        let isBottom = false;\n        // Toolbar display must not be none in order to calculate width and height.\n        this.toolbar.classList.toggle('d-none', false);\n        this.toolbar.style.maxWidth = window.innerWidth - OFFSET * 2 + 'px';\n        const sel = this.document.getSelection();\n        const range = sel.getRangeAt(0);\n        const isSelForward =\n            sel.anchorNode === range.startContainer && sel.anchorOffset === range.startOffset;\n        const startRect = range.startContainer.getBoundingClientRect && range.startContainer.getBoundingClientRect();\n        const selRect = range.getBoundingClientRect();\n        // In some undetermined circumstance in chrome, the selection rect is\n        // wrongly defined and result with all the values for x, y, width, and\n        // height to be 0. In that case, use the rect of the startContainer if\n        // possible.\n        const isSelectionPotentiallyBugged = [selRect.x, selRect.y, selRect.width, selRect.height].every( x => x === 0 );\n        let correctedSelectionRect = isSelectionPotentiallyBugged && startRect ? startRect : selRect;\n        const selAncestors = [sel.anchorNode, ...ancestors(sel.anchorNode, this.editable)];\n        // If a table is selected, we want to position the toolbar in function\n        // of the table, rather than follow the DOM selection.\n        const selectedTable = selAncestors.find(node => node.classList && node.classList.contains('o_selected_table'));\n        if (selectedTable) {\n            correctedSelectionRect = selectedTable.getBoundingClientRect();\n        }\n        const toolbarWidth = this.toolbar.offsetWidth;\n        const toolbarHeight = this.toolbar.offsetHeight;\n        const editorRect = this.editable.getBoundingClientRect();\n        const parentContextRect = this.options.getContextFromParentRect();\n        const scrollContainerRect = this.options.getScrollContainerRect();\n        const editorTopPos = Math.max(0, editorRect.top);\n        const scrollX = document.defaultView.scrollX;\n        const scrollY = document.defaultView.scrollY;\n\n        // Get left position.\n        let left = correctedSelectionRect.left + OFFSET;\n        // Ensure the toolbar doesn't overflow the editor on the left.\n        left = Math.max(OFFSET, left);\n        // Ensure the toolbar doesn't overflow the editor on the right.\n        left = Math.min(window.innerWidth - OFFSET - toolbarWidth, left);\n        // Offset left to compensate for parent context position (eg. Iframe).\n        const adjustedLeft = left + parentContextRect.left;\n        this.toolbar.style.left = scrollX + adjustedLeft + 'px';\n\n        // Get top position.\n        let top = correctedSelectionRect.top - toolbarHeight - OFFSET;\n        // Ensure the toolbar doesn't overflow the editor or scroll container on the top.\n        if (top < editorTopPos || top + parentContextRect.top - scrollContainerRect.top < OFFSET / 2) {\n            // Position the toolbar below the selection.\n            top = correctedSelectionRect.bottom + OFFSET;\n            isBottom = true;\n        }\n        // Offset top to compensate for parent context position (eg. Iframe).\n        top += parentContextRect.top;\n        this.toolbar.style.top = scrollY + top + 'px';\n\n        // Position the arrow.\n        let arrowLeftPos = (isSelForward && !isSelectionPotentiallyBugged ? correctedSelectionRect.right : correctedSelectionRect.left) - left - OFFSET;\n        // Ensure the arrow doesn't overflow the toolbar on the left.\n        arrowLeftPos = Math.max(OFFSET, arrowLeftPos);\n        // Ensure the arrow doesn't overflow the toolbar on the right.\n        arrowLeftPos = Math.min(toolbarWidth - OFFSET - 20, arrowLeftPos);\n        this.toolbar.style.setProperty('--arrow-left-pos', arrowLeftPos + 'px');\n        const arrowTopPos = isBottom ? -17 : toolbarHeight - 3;\n        this.toolbar.classList.toggle('toolbar-bottom', isBottom);\n        this.toolbar.style.setProperty('--arrow-top-pos', arrowTopPos + 'px');\n\n        // Calculate toolbar dimensions including the arrow.\n        const toolbarTop = Math.min(top , top + arrowTopPos);\n        const toolbarBottom = Math.max(top + toolbarHeight, top + arrowTopPos + 20);\n\n        // Hide toolbar if it overflows the scroll container.\n        const distToScrollContainer = Math.min(toolbarTop - scrollContainerRect.top,\n                                                scrollContainerRect.bottom - toolbarBottom);\n        this.toolbar.classList.toggle('d-none', distToScrollContainer < OFFSET / 2);\n    }\n\n    // PASTING / DROPPING\n\n    /**\n     * Prepare clipboard data (text/html) for safe pasting into the editor.\n     *\n     * @private\n     * @param {string} clipboardData\n     * @returns {Element}\n     */\n    _prepareClipboardData(clipboardData) {\n        const container = document.createElement('fake-container');\n        container.append(parseHTML(this.document, clipboardData));\n\n        for (const tableElement of container.querySelectorAll('table')) {\n            tableElement.classList.add('table', 'table-bordered', 'o_table');\n        }\n\n        const progId = container.querySelector('meta[name=\"ProgId\"]')\n        if (progId && progId.content === 'Excel.Sheet') {\n            // Microsoft Excel keeps table style in a <style> tag with custom\n            // classes. The following lines parse that style and apply it to the\n            // style attribute of <td> tags with matching classes.\n            const xlStylesheet = container.querySelector('style');\n            const xlNodes = container.querySelectorAll(\"[class*=xl],[class*=font]\");\n            for (const xlNode of xlNodes) {\n                for (const xlClass of xlNode.classList) {\n                    // Regex captures a CSS rule definition for that xlClass.\n                    const xlStyle = xlStylesheet.textContent.match(`.${xlClass}[^\\{]*\\{(?<xlStyle>[^\\}]*)\\}`)\n                        .groups.xlStyle.replace('background:', 'background-color:');\n                    xlNode.setAttribute('style', xlNode.style.cssText + ';' + xlStyle)\n                }\n            }\n        }\n\n        for (const child of [...container.childNodes]) {\n            this._cleanForPaste(child);\n        }\n        // Force inline nodes at the root of the container into separate P\n        // elements. This is a tradeoff to ensure some features that rely on\n        // nodes having a parent (e.g. convert to list, title, etc.) can work\n        // properly on such nodes without having to actually handle that\n        // particular case in all of those functions. In fact, this case cannot\n        // happen on a new document created using this editor, but will happen\n        // instantly when editing a document that was created from Etherpad.\n        const fragment = document.createDocumentFragment();\n        let p = document.createElement('p');\n        for (const child of [...container.childNodes]) {\n            if (isBlock(child)) {\n                if (p.childNodes.length > 0) {\n                    fragment.appendChild(p);\n                    p = document.createElement('p');\n                }\n                fragment.appendChild(child);\n            } else {\n                p.appendChild(child);\n            }\n\n            if (p.childNodes.length > 0) {\n                fragment.appendChild(p);\n            }\n        }\n        return fragment;\n    }\n    /**\n     * Clean a node for safely pasting. Cleaning an element involves unwrapping\n     * its contents if it's an illegal (blacklisted or not whitelisted) element,\n     * or removing its illegal attributes and classes.\n     *\n     * @param {Node} node\n     */\n    _cleanForPaste(node) {\n        if (\n            !this._isWhitelisted(node) ||\n            this._isBlacklisted(node) ||\n            // Google Docs have their html inside a B tag with custom id.\n            node.id && node.id.startsWith('docs-internal-guid')\n        ) {\n            if (!node.matches || node.matches(CLIPBOARD_BLACKLISTS.remove.join(','))) {\n                node.remove();\n            } else {\n                // Unwrap the illegal node's contents.\n                for (const unwrappedNode of unwrapContents(node)) {\n                    this._cleanForPaste(unwrappedNode);\n                }\n            }\n        } else if (node.nodeType !== Node.TEXT_NODE) {\n            if (node.nodeName === 'TD') {\n                if (node.hasAttribute('bgcolor') && !node.style['background-color']) {\n                    node.style['background-color'] = node.getAttribute('bgcolor');\n                }\n            } else if (node.nodeName === 'FONT') {\n                // FONT tags have some style information in custom attributes,\n                // this maps them to the style attribute.\n                if (node.hasAttribute('color') && !node.style['color']) {\n                    node.style['color'] = node.getAttribute('color');\n                }\n                if (node.hasAttribute('size') && !node.style['font-size']) {\n                    // FONT size uses non-standard numeric values.\n                    node.style['font-size'] = +node.getAttribute('size') + 10 + 'pt';\n                }\n            } else if (['S', 'U'].includes(node.nodeName) && node.childNodes.length === 1 && node.firstChild.nodeName === 'FONT') {\n                // S and U tags sometimes contain FONT tags. We prefer the\n                // strike to adopt the style of the text, so we invert them.\n                const fontNode = node.firstChild;\n                node.before(fontNode);\n                node.replaceChildren(...fontNode.childNodes);\n                fontNode.appendChild(node);\n            }\n            // Remove all illegal attributes and classes from the node, then\n            // clean its children.\n            for (const attribute of [...node.attributes]) {\n                // Keep allowed styles on nodes with allowed tags.\n                if (CLIPBOARD_WHITELISTS.styledTags.includes(node.nodeName) && attribute.name === 'style') {\n                    node.removeAttribute(attribute.name);\n                    if (['SPAN', 'FONT'].includes(node.tagName)) {\n                        for (const unwrappedNode of unwrapContents(node)) {\n                            this._cleanForPaste(unwrappedNode);\n                        }\n                    }\n                } else if (!this._isWhitelisted(attribute)) {\n                    node.removeAttribute(attribute.name);\n                }\n\n            }\n            for (const klass of [...node.classList]) {\n                if (!this._isWhitelisted(klass)) {\n                    node.classList.remove(klass);\n                }\n            }\n            for (const child of [...node.childNodes]) {\n                this._cleanForPaste(child);\n            }\n        }\n    }\n    /**\n     * Return true if the given attribute, class or node is whitelisted for\n     * pasting, false otherwise.\n     *\n     * @private\n     * @param {Attr | string | Node} item\n     * @returns {boolean}\n     */\n    _isWhitelisted(item) {\n        if (item instanceof Attr) {\n            return CLIPBOARD_WHITELISTS.attributes.includes(item.name);\n        } else if (typeof item === 'string') {\n            return CLIPBOARD_WHITELISTS.classes.some(okClass =>\n                okClass instanceof RegExp ? okClass.test(item) : okClass === item,\n            );\n        } else {\n            return (\n                item.nodeType === Node.TEXT_NODE ||\n                (\n                    item.matches &&\n                    item.matches(CLIPBOARD_WHITELISTS.nodes)\n                )\n            );\n        }\n    }\n    /**\n     * Return true if the given node is blacklisted for pasting, false\n     * otherwise.\n     *\n     * @private\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    _isBlacklisted(node) {\n        return (\n            node.nodeType !== Node.TEXT_NODE &&\n            node.matches([].concat(...Object.values(CLIPBOARD_BLACKLISTS)).join(','))\n        );\n    }\n    _safeSetAttribute(node, attributeName, attributeValue) {\n        const parent = node.parentNode;\n        const next = node.nextSibling;\n        this.observerFlush();\n        node.remove();\n        this.observer.takeRecords();\n        node.setAttribute(attributeName, attributeValue);\n        this.observerFlush();\n        DOMPurify.sanitize(node, { IN_PLACE: true });\n        if (next) {\n            next.before(node);\n        } else if (parent) {\n            parent.append(node);\n        }\n        this.observer.takeRecords();\n    }\n    _insertLinkZws(side, link) {\n        this.observerUnactive('_insertLinkZws');\n        const span = document.createElement('span');\n        span.setAttribute('data-o-link-zws', side);\n        if (side !== 'end') {\n            span.setAttribute('contenteditable', 'false');\n        }\n        span.textContent = '\\u200B';\n        if (side === 'start') {\n            link.prepend(span);\n        } else if (side === 'end') {\n            link.append(span);\n        } else if (side === 'after') {\n            link.after(span);\n        }\n        this.observerActive('_insertLinkZws');\n        return span;\n    }\n\n    disableAvatarForElement(element) {\n        this.enableAvatars();\n        for (const info of this._collabSelectionInfos.values()) {\n            if (info.avatarTargetElement === element) {\n                if (!info.avatarElement.classList.contains('opacity-0')) {\n                    info.avatarElement.classList.add('opacity-0');\n                }\n            }\n        }\n    }\n    enableAvatars() {\n        for (const element of this._avatarsContainer.querySelectorAll('.oe-collaboration-caret-avatar.opacity-0')) {\n            element.classList.remove('opacity-0');\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    _onBeforeInput(ev) {\n        this._lastBeforeInputType = ev.inputType;\n    }\n\n    /**\n     * If backspace/delete input, rollback the operation and handle the\n     * operation ourself. Needed for mobile, used for desktop for consistency.\n     *\n     * @private\n     */\n    _onInput(ev) {\n        // See if the Powerbox should be opened. If so, it will open at the end.\n        const newSelection = this.document.getSelection();\n        if (newSelection.anchorNode && isProtected(newSelection.anchorNode)) {\n            return;\n        }\n        const shouldOpenPowerbox = newSelection.isCollapsed && newSelection.rangeCount &&\n            ev.data === '/' && this.powerbox && !this.powerbox.isOpen &&\n            (!this.options.getPowerboxElement || !!this.options.getPowerboxElement());\n        if (shouldOpenPowerbox) {\n            // Undo input '/'.\n            this._powerboxBeforeStepIndex = this._historySteps.length - 1;\n        }\n        // Record the selection position that was computed on keydown or before\n        // contentEditable execCommand (whatever preceded the 'input' event)\n        this._recordHistorySelection(true);\n        const selection = this._currentStep.selection;\n        const { anchorNodeOid, anchorOffset, focusNodeOid, focusOffset } = selection || {};\n        const wasCollapsed =\n            !selection || (focusNodeOid === anchorNodeOid && focusOffset === anchorOffset);\n        // Sometimes google chrome wrongly triggers an input event with `data`\n        // being `null` on `deleteContentForward` `insertParagraph`. Luckily,\n        // chrome provide the proper signal with the event `beforeinput`.\n        const isChromeDeleteforward =\n            ev.inputType === 'insertText' &&\n            ev.data === null &&\n            this._lastBeforeInputType === 'deleteContentForward';\n        const isChromeInsertParagraph =\n            ev.inputType === 'insertText' &&\n            ev.data === null &&\n            this._lastBeforeInputType === 'insertParagraph';\n        this._resetLinkZws();\n        if (this.keyboardType === KEYBOARD_TYPES.PHYSICAL || !wasCollapsed) {\n            if (ev.inputType === 'deleteContentBackward') {\n                this._compositionStep();\n                this.historyRollback();\n                ev.preventDefault();\n                this._applyCommand('oDeleteBackward');\n            } else if (ev.inputType === 'deleteContentForward' || isChromeDeleteforward) {\n                this._compositionStep();\n                this.historyRollback();\n                ev.preventDefault();\n                this._applyCommand('oDeleteForward');\n            } else if (ev.inputType === 'insertParagraph' || isChromeInsertParagraph) {\n                this._compositionStep();\n                this.historyRollback();\n                ev.preventDefault();\n                this._handleAutomaticLinkInsertion();\n                if (this._applyCommand('oEnter') === UNBREAKABLE_ROLLBACK_CODE) {\n                    const brs = this._applyRawCommand('oShiftEnter');\n                    const anchor = brs[0].parentElement;\n                    if (anchor.nodeName === 'A') {\n                        if (brs.includes(anchor.firstChild)) {\n                            brs.forEach(br => anchor.before(br));\n                            setSelection(...rightPos(brs[brs.length - 1]));\n                        } else if (brs.includes(anchor.lastChild)) {\n                            brs.forEach(br => anchor.after(br));\n                            setSelection(...rightPos(brs[0]));\n                        }\n                    }\n                    this.historyStep();\n                }\n            } else if (['insertText', 'insertCompositionText'].includes(ev.inputType)) {\n                // insertCompositionText, courtesy of Samsung keyboard.\n                const selection = this.document.getSelection();\n                // Detect that text was selected and change behavior only if it is the case,\n                // since it is the only text insertion case that may cause problems.\n                const wasTextSelected = anchorNodeOid !== focusNodeOid || anchorOffset !== focusOffset;\n                // Unit tests events are not trusted by the browser,\n                // the insertText has to be done manualy.\n                const isUnitTests = !ev.isTrusted && this.testMode;\n                // we cannot trust the browser to keep the selection inside empty tags.\n                const latestSelectionInsideEmptyTag = this._isLatestComputedSelectionInsideEmptyInlineTag();\n                if (wasTextSelected || isUnitTests || latestSelectionInsideEmptyTag) {\n                    ev.preventDefault();\n                    if (!isUnitTests) {\n                        // First we need to undo the character inserted by the browser.\n                        // Since the unit test Event is not trusted by the browser, we don't\n                        // need to undo the char during the unit tests.\n                        // @see https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted\n                        this._applyRawCommand('oDeleteBackward');\n                    }\n                    if (latestSelectionInsideEmptyTag) {\n                        // Restore the selection inside the empty Element.\n                        const selectionBackup = this._latestComputedSelection;\n                        setSelection(selectionBackup.anchorNode, selectionBackup.anchorOffset);\n                    }\n                    // When the spellcheck of Safari modify text, ev.data is\n                    // null and the string can be found within ev.dataTranser.\n                    insertText(selection, ev.data === null ? ev.dataTransfer.getData('text/plain') : ev.data);\n                    selection.collapseToEnd();\n                }\n                if (ev.data === '`' && !closestElement(selection.anchorNode, 'code')) {\n                    // We just inserted a backtick, check if there was another\n                    // one in the text.\n                    const range = getDeepRange(this.editable);\n                    let textNode = range.startContainer;\n                    let offset = range.startOffset;\n                    let sibling = textNode.previousSibling;\n                    while (sibling && sibling.nodeType === Node.TEXT_NODE) {\n                        offset += sibling.textContent.length;\n                        sibling.textContent += textNode.textContent;\n                        textNode.remove();\n                        textNode = sibling;\n                        sibling = textNode.previousSibling;\n                    }\n                    sibling = textNode.nextSibling;\n                    while (sibling && sibling.nodeType === Node.TEXT_NODE) {\n                        textNode.textContent += sibling.textContent;\n                        sibling.remove();\n                        sibling = textNode.nextSibling;\n                    }\n                    setSelection(textNode, offset);\n                    const textHasTwoTicks = /`.*`/.test(textNode.textContent);\n                    if (textHasTwoTicks) {\n                        this.historyStep();\n                        const insertedBacktickIndex = offset - 1;\n                        const textBeforeInsertedBacktick = textNode.textContent.substring(0, insertedBacktickIndex - 1);\n                        let startOffset, endOffset;\n                        const isClosingForward = textBeforeInsertedBacktick.includes('`');\n                        if (isClosingForward) {\n                            // There is a backtick before the new backtick.\n                            startOffset = textBeforeInsertedBacktick.lastIndexOf('`');\n                            endOffset = insertedBacktickIndex;\n                        } else {\n                            // There is a backtick after the new backtick.\n                            const textAfterInsertedBacktick = textNode.textContent.substring(offset);\n                            startOffset = insertedBacktickIndex;\n                            endOffset = offset + textAfterInsertedBacktick.indexOf('`');\n                        }\n                        // Split around the backticks if needed so text starts\n                        // and ends with a backtick.\n                        if (endOffset && endOffset < textNode.textContent.length) {\n                            splitTextNode(textNode, endOffset + 1, DIRECTIONS.LEFT);\n                        }\n                        if (startOffset) {\n                            splitTextNode(textNode, startOffset);\n                        }\n                        // Remove ticks.\n                        textNode.textContent = textNode.textContent.substring(1, textNode.textContent.length - 1);\n                        // Insert code element.\n                        const codeElement = this.document.createElement('code');\n                        codeElement.classList.add('o_inline_code');\n                        textNode.before(codeElement);\n                        codeElement.append(textNode);\n                        if (!codeElement.previousSibling || codeElement.previousSibling.nodeType !== Node.TEXT_NODE) {\n                            codeElement.before(document.createTextNode('\\u200B'));\n                        }\n                        if (isClosingForward) {\n                            // Move selection out of code element.\n                            codeElement.after(document.createTextNode('\\u200B'));\n                            setSelection(codeElement.nextSibling, 1);\n                        } else {\n                            setSelection(codeElement.firstChild, 0);\n                        }\n                    }\n                }\n                this.historyStep();\n            } else {\n                this.historyStep();\n            }\n        } else if (ev.inputType === 'insertCompositionText') {\n            this._fromCompositionText = true;\n        }\n        if (shouldOpenPowerbox) {\n            this._isPowerboxOpenOnInput = true;\n            this.powerbox.open();\n        }\n    }\n\n    _onClipboardCut(clipboardEvent) {\n        this._onClipboardCopy(clipboardEvent);\n        this._recordHistorySelection();\n        this.deleteRange();\n        this.historyStep();\n    }\n    _onClipboardCopy(clipboardEvent) {\n        if (!this.isSelectionInEditable()) {\n            return;\n        }\n        clipboardEvent.preventDefault();\n        const selection = this.document.getSelection();\n        const range = selection.getRangeAt(0);\n        let rangeContent = range.cloneContents();\n        if (!rangeContent.hasChildNodes()) {\n            return;\n        }\n        // Repair the copied range.\n        if (rangeContent.firstChild.nodeName === 'LI') {\n            const list = range.commonAncestorContainer.cloneNode();\n            list.replaceChildren(...rangeContent.childNodes);\n            rangeContent = list;\n        }\n        if (rangeContent.firstChild.nodeName === 'TR' || rangeContent.firstChild.nodeName === 'TD') {\n            // We enter this case only if selection is within single table.\n            const table = closestElement(range.commonAncestorContainer, 'table');\n            const tableClone = table.cloneNode(true);\n            // A table is considered fully selected if it is nested inside a\n            // cell that is itself selected, or if all its own cells are\n            // selected.\n            const isTableFullySelected =\n                table.parentElement && !!closestElement(table.parentElement, 'td.o_selected_td') ||\n                [...table.querySelectorAll('td')]\n                    .filter(td => closestElement(td, 'table') === table)\n                    .every(td => td.classList.contains('o_selected_td'));\n            if (!isTableFullySelected) {\n                for (const td of tableClone.querySelectorAll('td:not(.o_selected_td)')) {\n                    if (closestElement(td, 'table') === tableClone) { // ignore nested\n                        td.remove();\n                    }\n                }\n                const trsWithoutTd = Array.from(tableClone.querySelectorAll('tr')).filter(row => !row.querySelector('td'));\n                for (const tr of trsWithoutTd) {\n                    if (closestElement(tr, 'table') === tableClone) { // ignore nested\n                        tr.remove();\n                    }\n                }\n            }\n            // If it is fully selected, clone the whole table rather than\n            // just its rows.\n            rangeContent = tableClone;\n        }\n        const table = closestElement(range.startContainer, 'table');\n        if (rangeContent.firstChild.nodeName === 'TABLE' && table) {\n            // Make sure the full leading table is copied.\n            rangeContent.firstChild.after(table.cloneNode(true));\n            rangeContent.firstChild.remove();\n        }\n        if (rangeContent.lastChild.nodeName === 'TABLE') {\n            // Make sure the full trailing table is copied.\n            rangeContent.lastChild.before(closestElement(range.endContainer, 'table').cloneNode(true));\n            rangeContent.lastChild.remove();\n        }\n\n        const commonAncestorElement = closestElement(range.commonAncestorContainer);\n        if (commonAncestorElement && !isBlock(rangeContent.firstChild)) {\n            // Get the list of ancestor elements starting from the provided\n            // commonAncestorElement up to the block-level element.\n            const blockEl = closestBlock(commonAncestorElement);\n            const ancestorsList = [commonAncestorElement, ...ancestors(commonAncestorElement, blockEl)];\n            // Wrap rangeContent with clones of their ancestors to keep the styles.\n            for (const ancestor of ancestorsList) {\n                const clone = ancestor.cloneNode();\n                clone.append(...rangeContent.childNodes);\n                rangeContent.appendChild(clone);\n            }\n        }\n        const dataHtmlElement = document.createElement('data');\n        dataHtmlElement.append(rangeContent);\n        const odooHtml = dataHtmlElement.innerHTML;\n        const odooText = selection.toString();\n        clipboardEvent.clipboardData.setData('text/plain', odooText);\n        clipboardEvent.clipboardData.setData('text/html', odooHtml);\n        clipboardEvent.clipboardData.setData('text/odoo-editor', odooHtml);\n    }\n    /**\n     * @private\n     */\n    _onKeyDown(ev) {\n        const selection = this.document.getSelection();\n        if (selection.anchorNode && isProtected(selection.anchorNode)) {\n            return;\n        }\n        this.keyboardType =\n            ev.key === 'Unidentified' ? KEYBOARD_TYPES.VIRTUAL : KEYBOARD_TYPES.PHYSICAL;\n        this._currentKeyPress = ev.key;\n        // If the pressed key has a printed representation, the returned value\n        // is a non-empty Unicode character string containing the printable\n        // representation of the key. In this case, call `deleteRange` before\n        // inserting the printed representation of the character.\n        if (/^.$/u.test(ev.key) && !ev.ctrlKey && !ev.metaKey && (isMacOS() || !ev.altKey)) {\n            const selection = this.document.getSelection();\n            if (selection && !selection.isCollapsed) {\n                this._resetLinkZws();\n                this.deleteRange(selection);\n                this._setLinkZws();\n            }\n        }\n        if (ev.key === 'Backspace') {\n            // backspace\n            const selection = this.document.getSelection();\n            if (!ev.ctrlKey && !ev.metaKey) {\n                if (selection.isCollapsed) {\n                    // We need to hijack it because firefox doesn't trigger a\n                    // deleteBackward input event with a collapsed selection in\n                    // front of a contentEditable=\"false\" (eg: font awesome).\n                    ev.preventDefault();\n                    this._applyCommand('oDeleteBackward');\n                }\n            } else if (selection.isCollapsed && selection.anchorNode) {\n                const anchor = (selection.anchorNode.nodeType !== Node.TEXT_NODE && selection.anchorOffset) ?\n                    selection.anchorNode[selection.anchorOffset] : selection.anchorNode;\n                const element = closestBlock(anchor);\n                if (isEmptyBlock(element) && element.parentElement.children.length === 1) {\n                    // Prevent removing a <p> if it is the last element of its\n                    // parent.\n                    ev.preventDefault();\n                    if (element.tagName !== 'P') {\n                        // Replace an empty block which is not a <p> by a <p>\n                        const paragraph = this.document.createElement('P');\n                        const br = this.document.createElement('BR');\n                        paragraph.append(br);\n                        element.before(paragraph);\n                        const result = this._protect(() => element.remove());\n                        if (result !== UNBREAKABLE_ROLLBACK_CODE && result !== UNREMOVABLE_ROLLBACK_CODE) {\n                            setCursorStart(paragraph);\n                            this.historyStep();\n                        }\n                    }\n                }\n            }\n        } else if (ev.key === 'Tab') {\n            // Tab\n            const tabHtml = '<span class=\"oe-tabs\" contenteditable=\"false\">\\u0009</span>\\u200B';\n            const sel = this.document.getSelection();\n            const closestLi = closestElement(sel.anchorNode, 'li');\n            if (closestElement(sel.anchorNode, 'table') && !closestLi) {\n                this._onTabulationInTable(ev);\n            } else if (!ev.shiftKey && sel.isCollapsed && !closestLi) {\n                // Indent text (collapsed selection).\n                this.execCommand('insert', parseHTML(this.document, tabHtml));\n            } else {\n                // Indent/outdent selection.\n                // Split traversed nodes into list items and the rest.\n                const listItems = new Set();\n                const nonListItems = new Set();\n                for (const node of getTraversedNodes(this.editable)) {\n                    const closestLi = closestElement(node, 'li');\n                    const target = closestLi || node;\n                    if (!(target.querySelector && target.querySelector('li'))) {\n                        if (closestLi) {\n                            listItems.add(closestLi);\n                        } else {\n                            nonListItems.add(node);\n                        }\n                    }\n                }\n\n                const restore = preserveCursor(this.document);\n\n                // Indent/outdent list items.\n                for (const listItem of listItems) {\n                    if (ev.shiftKey) {\n                        listItem.oShiftTab(0);\n                    } else {\n                        listItem.oTab(0);\n                    }\n                }\n\n                // Indent/outdent the rest.\n                if (ev.shiftKey) {\n                    const editorTabs = new Set(\n                        [...nonListItems].map(node => {\n                            const block = closestBlock(node);\n                            return descendants(block).find(child => isEditorTab(child));\n                        }).filter(node => (\n                            // Filter out tabs preceded by visible text.\n                            node && !getAdjacentPreviousSiblings(node).some(sibling => (\n                                sibling.nodeType === Node.TEXT_NODE && !/^[\\u200B\\s]*$/.test(sibling.textContent)\n                            ))\n                    )));\n                    for (const tab of editorTabs) {\n                        let { anchorNode, anchorOffset, focusNode, focusOffset } = sel;\n                        const updateAnchor = anchorNode === tab.nextSibling;\n                        const updateFocus = focusNode === tab.nextSibling;\n                        let zwsRemoved = 0;\n                        while (tab.nextSibling && tab.nextSibling.nodeType === Node.TEXT_NODE && tab.nextSibling.textContent.startsWith('\\u200B')) {\n                            splitTextNode(tab.nextSibling, 1, DIRECTIONS.LEFT);\n                            tab.nextSibling.remove();\n                            zwsRemoved++;\n                        }\n                        if (updateAnchor || updateFocus) {\n                            setSelection(\n                                updateAnchor ? tab.nextSibling : anchorNode,\n                                updateAnchor ? Math.max(0, anchorOffset - zwsRemoved) : anchorOffset,\n                                updateFocus ? tab.nextSibling : focusNode,\n                                updateFocus ? Math.max(0, focusOffset - zwsRemoved) : focusOffset\n                            );\n                        }\n                        tab.remove();\n                    };\n                } else {\n                    const tab = parseHTML(this.document, tabHtml);\n                    for (const block of new Set([...nonListItems].map(node => closestBlock(node)).filter(node => node))) {\n                        block.prepend(tab.cloneNode(true));\n                    }\n                    restore();\n                }\n                this.historyStep();\n            }\n            ev.preventDefault();\n            ev.stopPropagation();\n        } else if (ev.shiftKey && ev.key === \"Enter\") {\n            ev.preventDefault();\n            this._handleAutomaticLinkInsertion();\n            this._applyCommand('oShiftEnter');\n        } else if (ev.key === ' ') {\n            this._handleAutomaticLinkInsertion();\n        } else if (IS_KEYBOARD_EVENT_UNDO(ev)) {\n            // Ctrl-Z\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.historyUndo();\n        } else if (IS_KEYBOARD_EVENT_REDO(ev)) {\n            // Ctrl-Y\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.historyRedo();\n        } else if (IS_KEYBOARD_EVENT_BOLD(ev)) {\n            // Ctrl-B\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.execCommand('bold');\n        } else if (IS_KEYBOARD_EVENT_ITALIC(ev)) {\n            // Ctrl-I\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.execCommand('italic');\n        } else if (IS_KEYBOARD_EVENT_UNDERLINE(ev)) {\n            // Ctrl-U\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.execCommand('underline');\n        } else if (IS_KEYBOARD_EVENT_STRIKETHROUGH(ev)) {\n            // Ctrl-5 / Ctrl-shift-(\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.execCommand('strikeThrough');\n        } else if (IS_KEYBOARD_EVENT_LEFT_ARROW(ev)) {\n            if (ev.shiftKey) {\n                this._resetLinkZws();\n            }\n            getDeepRange(this.editable, { select: true });\n            let { anchorNode, anchorOffset, focusNode, focusOffset } = this.document.getSelection();\n            if (!focusNode) {\n                return;\n            }\n            // If the selection is at the beginning of a code element at the\n            // start of its parent, make sure there's a zws before it, where the\n            // selection can then be set.\n            const codeElement = closestElement(anchorNode, 'code');\n            if (\n                codeElement?.classList.contains('o_inline_code') &&\n                !anchorOffset &&\n                (!codeElement.previousSibling || codeElement?.previousSibling.nodeType !== Node.TEXT_NODE ) &&\n                !isZWS(codeElement?.previousSibling)\n            ) {\n                codeElement.before(document.createTextNode('\\u200B'));\n                setSelection(codeElement.previousSibling, 0);\n            } else {\n                // Find previous character.\n                let previousCharacter = focusOffset > 0 && focusNode.textContent[focusOffset - 1];\n                const previousNode = previousLeaf(focusNode, this.editable);\n                if (!previousCharacter && previousNode && closestBlock(previousNode) === closestBlock(focusNode)) {\n                    focusNode = previousNode;\n                    focusOffset = nodeSize(focusNode);\n                    previousCharacter = focusNode.textContent[focusOffset - 1];\n                }\n                // Move selection if previous character is zero-width space\n                if (previousCharacter === '\\u200B' && !focusNode.parentElement.hasAttribute('data-o-link-zws')) {\n                    focusOffset -= 1;\n                    while (focusNode && (focusOffset < 0 || !focusNode.textContent[focusOffset])) {\n                        focusNode = nextLeaf(focusNode, this.editable);\n                        focusOffset = focusNode && nodeSize(focusNode);\n                    }\n                    if (focusNode) {\n                        const startContainer = ev.shiftKey ? anchorNode : focusNode;\n                        const startOffset = ev.shiftKey ? anchorOffset : focusOffset;\n                        setSelection(startContainer, startOffset, focusNode, focusOffset);\n                    }\n                }\n            }\n        } else if (IS_KEYBOARD_EVENT_RIGHT_ARROW(ev)) {\n            if (ev.shiftKey) {\n                this._resetLinkZws();\n            }\n            getDeepRange(this.editable, { select: true });\n            let { anchorNode, anchorOffset, focusNode, focusOffset } = this.document.getSelection();\n            if (!focusNode) {\n                return;\n            }\n            // If the selection is at the ending of a code element at the\n            // end of its parent, make sure there's a zws after it, where the\n            // selection can then be set.\n            const codeElement = closestElement(anchorNode, 'code');\n            if (\n                codeElement?.classList.contains('o_inline_code') &&\n                anchorOffset === nodeSize(anchorNode) &&\n                (!codeElement?.nextSibling || codeElement?.nextSibling.nodeType !== Node.TEXT_NODE ) &&\n                !isZWS(codeElement?.nextSibling)\n            ) {\n                codeElement.after(document.createTextNode('\\u200B'));\n                setSelection(codeElement.nextSibling, 1);\n            } else {\n                // Find next character.\n                let nextCharacter = focusNode.textContent[focusOffset];\n                const nextNode = nextLeaf(focusNode, this.editable);\n                if (!nextCharacter && nextNode && closestBlock(nextNode) === closestBlock(focusNode)) {\n                    focusNode = nextNode;\n                    focusOffset = 0;\n                    nextCharacter = focusNode.textContent[focusOffset];\n                }\n                // Move selection if next character is zero-width space\n                if (nextCharacter === '\\u200B' && !focusNode.parentElement.hasAttribute('data-o-link-zws')) {\n                    focusOffset += 1;\n                    let newFocusNode = focusNode;\n                    while (newFocusNode && (!newFocusNode.textContent[focusOffset] || !closestElement(newFocusNode).isContentEditable)) {\n                        newFocusNode = nextLeaf(newFocusNode, this.editable);\n                        focusOffset = 0;\n                    }\n                    if (newFocusNode && !focusOffset && closestBlock(focusNode) !== closestBlock(newFocusNode)) {\n                        newFocusNode = focusNode; // Do not move selection to next block.\n                        focusOffset = focusNode && nodeSize(focusNode);\n                    }\n                    if (newFocusNode) {\n                        const startContainer = ev.shiftKey ? anchorNode : newFocusNode;\n                        const startOffset = ev.shiftKey ? anchorOffset : focusOffset;\n                        setSelection(startContainer, startOffset, newFocusNode, focusOffset);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @private\n     */\n    _onSelectionChange() {\n        const currentKeyPress = this._currentKeyPress;\n        delete this._currentKeyPress;\n        const selection = this.document.getSelection();\n        if (!selection) {\n            // Because the `selectionchange` event is async, the selection can\n            // be null if the node has been removed between the moment the\n            // selection was moved and the moment the event is triggered.\n            return;\n        }\n        const anchorNode = selection.anchorNode;\n        // Correct cursor if at editable root.\n        if (\n            selection.isCollapsed &&\n            anchorNode === this.editable &&\n            !this.options.allowInlineAtRoot\n        ) {\n            this._fixSelectionOnEditableRoot(selection, currentKeyPress);\n            // The _onSelectionChange handler is going to be triggered again.\n            return;\n        }\n        let appliedCustomSelection = false;\n        if (selection.rangeCount && selection.getRangeAt(0)) {\n            appliedCustomSelection = this._handleSelectionInTable();\n\n            // Handle selection/navigation at the edges of links.\n            const link = getInSelection(this.document, EDITABLE_LINK_SELECTOR);\n            if (link && selection.isCollapsed) {\n                // 1. If the selection starts or ends at the end of a link\n                //    (after the end zws), move the selection after the \"after\"\n                //    zws. This ensures that the cursor is visibly outside the\n                //    link. We want to do this only if the link has an end zws\n                //    to prevent ejecting the selection when moving in from the\n                //    right.\n                const endZws = link.querySelector('[data-o-link-zws=\"end\"]');\n                const isAtEndOfLink = (\n                    // The selection is at the end of the link, ie. at offset\n                    // max of the link, with no next leaf that is in the link.\n                    endZws && selection.anchorOffset === nodeSize(selection.anchorNode) &&\n                    closestElement(selection.anchorNode, EDITABLE_LINK_SELECTOR) === link &&\n                    closestElement(nextLeaf(selection.anchorNode, this.editable), EDITABLE_LINK_SELECTOR) !== link\n                );\n                if (isAtEndOfLink) {\n                    let afterZws = link.nextElementSibling;\n                    if (!afterZws) {\n                        afterZws = this._insertLinkZws('after', link);\n                    }\n                    setSelection(\n                        afterZws.nextSibling || afterZws.parentElement,\n                        afterZws.nextSibling ? 0 : nodeSize(afterZws.parentElement),\n                    );\n                    return; // The selection is changed and will therefore re-trigger the _onSelectionChange.\n                }\n            }\n            // 2. Make sure the link has the required zws if the selection\n            //    wasn't changed.\n            this._setLinkZws();\n\n        }\n        const isSelectionInEditable = this.isSelectionInEditable(selection);\n        if (!appliedCustomSelection) {\n            this._updateToolbar(!selection.isCollapsed && isSelectionInEditable);\n        }\n        if (!isSelectionInEditable) {\n            return;\n        }\n        // When CTRL+A in the editor, sometimes the browser use the editable\n        // element as an anchor & focus node. This is an issue for the commands\n        // and the toolbar so we need to fix the selection to be based on the\n        // editable children. Calling `getDeepRange` ensure the selection is\n        // limited to the editable.\n        const containerSelector = '#wrap>*, .oe_structure>*, [contenteditable]';\n        const container =\n            (selection &&\n                closestElement(selection.anchorNode, containerSelector)) ||\n            // In case a suitable container could not be found then the\n            // selection is restricted inside the editable area.\n            this.editable;\n        if (\n            selection.anchorNode === container &&\n            selection.focusNode === container &&\n            selection.anchorOffset === 0 &&\n            selection.focusOffset === [...container.childNodes].length\n        ) {\n            getDeepRange(container, {select: true});\n            // The selection is changed in `getDeepRange` and will therefore\n            // re-trigger the _onSelectionChange.\n            return;\n        }\n\n        // Compute the current selection on selectionchange but do not record it. Leave\n        // that to the command execution or the 'input' event handler.\n        this._computeHistorySelection();\n\n        if (this._currentMouseState === 'mouseup') {\n            this._fixFontAwesomeSelection();\n        }\n        if (\n            selection.rangeCount &&\n            selection.getRangeAt(0) &&\n            this.options.onCollaborativeSelectionChange\n        ) {\n            this.options.onCollaborativeSelectionChange(this.getCurrentCollaborativeSelection());\n        }\n    }\n\n    /**\n     * Returns true if the current selection is inside the editable.\n     *\n     * @param {Object} [selection]\n     * @returns {boolean}\n     */\n    isSelectionInEditable(selection) {\n        selection = selection || this.document.getSelection();\n        if (selection && selection.anchorNode && selection.focusNode) {\n            const anchorElement = closestElement(selection.anchorNode);\n            const focusElement = closestElement(selection.focusNode);\n            return anchorElement && anchorElement.isContentEditable && focusElement && focusElement.isContentEditable &&\n                this.editable.contains(selection.anchorNode) && this.editable.contains(selection.focusNode);\n        } else {\n            return false;\n        }\n    }\n    /**\n     * Returns true if the current selection is in at least one block Element\n     * relative to the current contentEditable root.\n     *\n     * @returns {boolean}\n     */\n    isSelectionInBlockRoot() {\n        const selection = this.document.getSelection();\n        let selectionInBlockRoot;\n        let currentNode = closestElement(selection.anchorNode);\n        while (\n            !currentNode.classList.contains('o_editable') &&\n            !currentNode.classList.contains('odoo-editor-editable') &&\n            !selectionInBlockRoot\n            ) {\n            selectionInBlockRoot = isBlock(currentNode);\n            currentNode = currentNode.parentElement;\n        }\n        return !!selectionInBlockRoot;\n    }\n\n    /**\n     * @private\n     */\n    _compositionStep() {\n        if (this._fromCompositionText) {\n            this._fromCompositionText = false;\n            this.sanitize();\n            this.historyStep();\n        }\n    }\n\n    getCurrentCollaborativeSelection() {\n        const selection = this._latestComputedSelection || this._computeHistorySelection();\n        return {\n            selection: selection ? serializeSelection(selection) : {\n                anchorNodeOid: undefined,\n                anchorOffset: undefined,\n                focusNodeOid: undefined,\n                focusOffset: undefined,\n            },\n            color: this._collabSelectionColor,\n            clientId: this._collabClientId,\n            clientAvatarUrl: this._collabClientAvatarUrl,\n        };\n    }\n\n    clean() {\n        this.observerUnactive();\n        this.cleanForSave();\n        this.observerActive();\n    }\n\n    /**\n     * Initialize the provided element to be ready for edition.\n     */\n    initElementForEdition(element = this.editable) {\n        // Detect if the editable base element contain orphan inline nodes. If\n        // so we transform the base element HTML to put those orphans inside\n        // `<p>` containers.\n        const orphanInlineChildNodes = [...element.childNodes].find(\n            (n) => !isBlock(n) && (n.nodeType === Node.ELEMENT_NODE || n.textContent.trim() !== \"\")\n        );\n        if (orphanInlineChildNodes && !this.options.allowInlineAtRoot) {\n            const childNodes = [...element.childNodes];\n            const tempEl = document.createElement('temp-container');\n            let currentP = document.createElement('p');\n            currentP.style.marginBottom = '0';\n            do {\n                const node = childNodes.shift();\n                const nodeIsBlock = isBlock(node);\n                const nodeIsBR = node.nodeName === 'BR';\n                // Append to the P unless child is block or an unneeded BR.\n                if (!(nodeIsBlock || (nodeIsBR && currentP.childNodes.length))) {\n                    currentP.append(node);\n                }\n                // Break paragraphs on blocks and BR.\n                if (nodeIsBlock || nodeIsBR || childNodes.length === 0) {\n                    // Ensure we don't add an empty P or a P containing only\n                    // formating spaces that should not be visible.\n                    if (currentP.childNodes.length && currentP.innerHTML.trim() !== '') {\n                        tempEl.append(currentP);\n                    }\n                    currentP = currentP.cloneNode();\n                    // Append block children directly to the template.\n                    if (nodeIsBlock) {\n                        tempEl.append(node);\n                    }\n                }\n            } while (childNodes.length)\n            element.replaceChildren(...tempEl.childNodes);\n        }\n\n        // Flag elements with forced contenteditable=false.\n        // We need the flag to be able to leave the contentEditable\n        // at the end of the edition (see cleanForSave())\n        for (const el of element.querySelectorAll('[contenteditable=\"false\"]')) {\n            el.setAttribute('data-oe-keep-contenteditable', '');\n        }\n        // Flag elements .oe-tabs contenteditable=false.\n        for (const el of element.querySelectorAll('.oe-tabs')) {\n            el.setAttribute('contenteditable', 'false');\n        }\n    }\n\n    cleanForSave(element = this.editable) {\n        for (const hint of element.querySelectorAll('.oe-hint')) {\n            hint.classList.remove('oe-hint', 'oe-command-temporary-hint');\n            if (hint.classList.length === 0) {\n                hint.removeAttribute('class');\n            }\n            hint.removeAttribute('placeholder');\n        }\n        this._pluginCall('cleanForSave', [element]);\n\n        // Remove all link ZWS.\n        this._resetLinkZws(element);\n\n        // Clean the zero-width spaces added by the `fillEmpty` function\n        // (flagged with the \"data-oe-zws-empty-inline\" attributes). Reverse the\n        // list to start from the deepest elements (for emptiness checks).\n        const allWhitespaceRegex = /^[\\s\\u200b]*$/;\n        for (const emptyElement of [...element.querySelectorAll('[data-oe-zws-empty-inline]')].reverse()) {\n            emptyElement.removeAttribute('data-oe-zws-empty-inline');\n            if (!allWhitespaceRegex.test(emptyElement.textContent)) {\n                // The element has some meaningful text. Remove the ZWS in it.\n                cleanZWS(emptyElement);\n            } else if (!emptyElement.classList.length) {\n                // We only remove the empty element if it has no class, to\n                // ensure we don't break visual styles (in that case, its\n                // ZWS was kept to ensure the cursor can be placed in it).\n                emptyElement.remove();\n            }\n        }\n\n        // Clean all transient nodes\n        const protectedNodes = element.querySelectorAll('[data-oe-transient-content=\"true\"], [data-oe-transient-content=\"\"]');\n        for (const node of protectedNodes) {\n            node.replaceChildren();\n        }\n\n        sanitize(element);\n\n        // Remove contenteditable=false on elements\n        for (const el of element.querySelectorAll('[contenteditable=\"false\"]')) {\n            if (!el.hasAttribute('data-oe-keep-contenteditable')) {\n                el.removeAttribute('contenteditable');\n            }\n        }\n        // Remove data-oe-keep-contenteditable on elements\n        for (const el of element.querySelectorAll('[data-oe-keep-contenteditable]')) {\n            el.removeAttribute('data-oe-keep-contenteditable');\n        }\n\n        // Remove Zero Width Spaces on Font awesome elements\n        for (const el of element.querySelectorAll(ICON_SELECTOR)) {\n            cleanZWS(el);\n        }\n\n        // Clean custom selections\n        if (this.deselectTable() && hasValidSelection(this.editable)) {\n            this.document.getSelection().collapseToStart();\n        }\n    }\n    /**\n     * Handle the hint preview for the Powerbox.\n     * @private\n     */\n    _handleCommandHint() {\n        const selection = this.document.getSelection();\n        const anchorNode = selection.anchorNode;\n        if (isProtected(anchorNode)) {\n            return;\n        }\n\n        const selectors = {\n            BLOCKQUOTE: this.options._t('Empty quote'),\n            H1: this.options._t('Heading 1'),\n            H2: this.options._t('Heading 2'),\n            H3: this.options._t('Heading 3'),\n            H4: this.options._t('Heading 4'),\n            H5: this.options._t('Heading 5'),\n            H6: this.options._t('Heading 6'),\n            'UL LI': this.options._t('List'),\n            'OL LI': this.options._t('List'),\n            'CL LI': this.options._t('To-do'),\n        };\n\n        for (const hint of this.editable.querySelectorAll('.oe-hint')) {\n            if (\n                hint.classList.contains('oe-command-temporary-hint') ||\n                !isEmptyBlock(hint) ||\n                hint.querySelector('T[t-out]')\n            ) {\n                this.observerUnactive();\n                hint.classList.remove('oe-hint', 'oe-command-temporary-hint');\n                if (hint.dataset.oeEditPlaceholder) {\n                    hint.setAttribute(\"placeholder\", hint.dataset.oeEditPlaceholder);\n                    if (hint.innerText.trim().length === 0) {\n                        hint.classList.add(\"oe-hint\");\n                    }\n                } else {\n                    hint.removeAttribute(\"placeholder\");\n                }\n                if (hint.classList.length === 0) {\n                    hint.removeAttribute('class');\n                }\n                this.observerActive();\n            }\n        }\n\n        if (this.options.showEmptyElementHint) {\n            for (const [selector, text] of Object.entries(selectors)) {\n                for (const el of this.editable.querySelectorAll(selector)) {\n                    if (!this.options.isHintBlacklisted(el)) {\n                        this._makeHint(el, text);\n                    }\n                }\n            }\n        }\n\n        const block = this.options.getPowerboxElement();\n        if (block) {\n            this._makeHint(block, this.options._t('Type \"/\" for commands'), true);\n        }\n\n        // placeholder hint\n        const sel = this.document.getSelection();\n        if (this.editable.textContent.trim() === '' && this.options.placeholder && this.editable.firstChild && this.editable.firstChild.innerHTML && !this.editable.contains(sel.focusNode)) {\n            this._makeHint(this.editable.firstChild, this.options.placeholder, true);\n        }\n    }\n    _makeHint(block, text, temporary = false) {\n        const content = block && block.innerHTML.trim();\n        if (\n            block &&\n            (content === '' || content === '<br>') &&\n            !block.querySelector('T[t-out],[t-field]') &&\n            ancestors(block, this.editable).includes(this.editable)\n        ) {\n            this.observerUnactive();\n            block.setAttribute('placeholder', text);\n            block.classList.add('oe-hint');\n            if (temporary) {\n                block.classList.add('oe-command-temporary-hint');\n            }\n            this.observerActive();\n        }\n    }\n\n    /**\n     * Places the cursor in a safe place (not the editable root).\n     * Inserts an empty paragraph if selection results from mouse click and\n     * there's no other way to insert text before/after a block.\n     *\n     * @param {Selection} selection - Collapsed selection at the editable root.\n     * @param {String} currentKeyPress\n     */\n    _fixSelectionOnEditableRoot(selection, currentKeyPress) {\n        let nodeAfterCursor = this.editable.childNodes[selection.anchorOffset];\n        let nodeBeforeCursor = nodeAfterCursor && nodeAfterCursor.previousElementSibling;\n        // Handle arrow key presses.\n        if (currentKeyPress === 'ArrowRight' || currentKeyPress === 'ArrowDown') {\n            while (nodeAfterCursor && isNotAllowedContent(nodeAfterCursor)) {\n                nodeAfterCursor = nodeAfterCursor.nextElementSibling;\n            }\n            if (nodeAfterCursor) {\n                setSelection(...getDeepestPosition(nodeAfterCursor, 0));\n            } else {\n                this.historyResetLatestComputedSelection(true);\n            }\n        } else if (currentKeyPress === 'ArrowLeft' || currentKeyPress === 'ArrowUp') {\n            while (nodeBeforeCursor && isNotAllowedContent(nodeBeforeCursor)) {\n                nodeBeforeCursor = nodeBeforeCursor.previousElementSibling;\n            }\n            if (nodeBeforeCursor) {\n                setSelection(...getDeepestPosition(nodeBeforeCursor, nodeSize(nodeBeforeCursor)));\n            } else {\n                this.historyResetLatestComputedSelection(true);\n            }\n        // Handle cursor next to a 'P'.\n        } else if (nodeAfterCursor && paragraphRelatedElements.includes(nodeAfterCursor.nodeName)) {\n            // Cursor is right before a 'P'.\n            setCursorStart(nodeAfterCursor);\n        } else if (nodeBeforeCursor && paragraphRelatedElements.includes(nodeBeforeCursor.nodeName)) {\n            // Cursor is right after a 'P'.\n            setCursorEnd(nodeBeforeCursor);\n        // Handle cursor not next to a 'P'.\n        // Insert a new 'P' if selection resulted from a mouse click.\n        } else if (this._currentMouseState === 'mousedown') {\n            this._recordHistorySelection(true);\n            const p = this.document.createElement('p');\n            p.append(this.document.createElement('br'));\n            if (!nodeAfterCursor) {\n                // Cursor is at the end of the editable.\n                this.editable.append(p);\n            } else if (!nodeBeforeCursor) {\n                // Cursor is at the beginning of the editable.\n                this.editable.prepend(p);\n            } else {\n                // Cursor is between two non-p blocks\n                nodeAfterCursor.before(p);\n            }\n            setCursorStart(p);\n            this.historyStep();\n        } else {\n            // Remove selection as a fallback.\n            selection.removeAllRanges();\n        }\n    }\n\n    _onMouseup(ev) {\n        this._currentMouseState = ev.type;\n\n        this._fixFontAwesomeSelection();\n    }\n\n    _onMouseDown(ev) {\n        this._currentMouseState = ev.type;\n        this._lastMouseClickPosition = [ev.x, ev.y];\n\n        this._activateContenteditable();\n\n        // Ignore any changes that might have happened before this point.\n        this.observer.takeRecords();\n\n        const node = ev.target;\n        // handle checkbox lists\n        if (node.tagName == 'LI' && getListMode(node.parentElement) == 'CL') {\n            const beforStyle = window.getComputedStyle(node, ':before');\n            const style1 = {\n                left: parseInt(beforStyle.getPropertyValue('left'), 10),\n                top: parseInt(beforStyle.getPropertyValue('top'), 10),\n            }\n            style1.right = style1.left + parseInt(beforStyle.getPropertyValue('width'), 10);\n            style1.bottom = style1.top + parseInt(beforStyle.getPropertyValue('height'), 10);\n\n            const isMouseInsideCheckboxBox =\n                ev.offsetX >= style1.left &&\n                ev.offsetX <= style1.right &&\n                ev.offsetY >= style1.top &&\n                ev.offsetY <= style1.bottom;\n\n            if (isMouseInsideCheckboxBox) {\n                toggleClass(node, 'o_checked');\n                ev.preventDefault();\n                this.historyStep();\n                if (!document.getSelection().isCollapsed) {\n                    this._updateToolbar(true);\n                }\n            }\n        }\n\n        // handle stars\n        const isStar = el => el.nodeType === Node.ELEMENT_NODE && (\n            el.classList.contains('fa-star') || el.classList.contains('fa-star-o')\n        );\n        if (isStar(node) &&\n            node.parentElement && node.parentElement.className.includes('o_stars')) {\n            const previousStars = getAdjacentPreviousSiblings(node, isStar);\n            const nextStars = getAdjacentNextSiblings(node, isStar);\n            if (nextStars.length || previousStars.length) {\n                const shouldToggleOff = node.classList.contains('fa-star') &&\n                    (!nextStars[0] || !nextStars[0].classList.contains('fa-star'));\n                for (const star of [...previousStars, node]) {\n                    star.classList.toggle('fa-star-o', shouldToggleOff);\n                    star.classList.toggle('fa-star', !shouldToggleOff);\n                };\n                for (const star of nextStars) {\n                    star.classList.toggle('fa-star-o', true);\n                    star.classList.toggle('fa-star', false);\n                };\n                this.historyStep();\n            }\n        }\n\n        // Handle table selection.\n        if (this.toolbar && !ancestors(ev.target, this.editable).includes(this.toolbar)) {\n            this.toolbar.style.pointerEvents = 'none';\n            if (this.deselectTable() && hasValidSelection(this.editable)) {\n                this.document.getSelection().collapseToStart();\n                this._updateToolbar(false);\n            }\n        }\n        // Handle table resizing.\n        const isHoveringTdBorder = this._isHoveringTdBorder(ev);\n        if (isHoveringTdBorder) {\n            ev.preventDefault();\n            const direction = { top: 'row', right: 'col', bottom: 'row', left: 'col' }[isHoveringTdBorder] || false;\n            let target1, target2;\n            const column = closestElement(ev.target, 'tr');\n            if (isHoveringTdBorder === 'top' && column) {\n                target1 = getAdjacentPreviousSiblings(column).find(node => node.nodeName === 'TR');\n                target2 = closestElement(ev.target, 'tr');\n            } else if (isHoveringTdBorder === 'right') {\n                target1 = ev.target;\n                target2 = getAdjacentNextSiblings(ev.target).find(node => node.nodeName === 'TD');\n            } else if (isHoveringTdBorder === 'bottom' && column) {\n                target1 = closestElement(ev.target, 'tr');\n                target2 = getAdjacentNextSiblings(column).find(node => node.nodeName === 'TR');\n            } else if (isHoveringTdBorder === 'left') {\n                target1 = getAdjacentPreviousSiblings(ev.target).find(node => node.nodeName === 'TD');\n                target2 = ev.target;\n            }\n            this._isResizingTable = true;\n            this._toggleTableResizeCursor(direction);\n            const resizeTable = ev => this._resizeTable(ev, direction, target1, target2);\n            const stopResizing = ev => {\n                ev.preventDefault();\n                this._isResizingTable = false;\n                this._toggleTableResizeCursor(false);\n                this.historyStep();\n                this.document.removeEventListener('mousemove', resizeTable);\n                this.document.removeEventListener('mouseup', stopResizing);\n                this.document.removeEventListener('mouseleave', stopResizing);\n            };\n            this.document.addEventListener('mousemove', resizeTable);\n            this.document.addEventListener('mouseup', stopResizing);\n            this.document.addEventListener('mouseleave', stopResizing);\n        }\n\n        // Handle emoji popover\n        const isEmojiPopover = document.querySelector('.o-EmojiPicker');\n        if (isEmojiPopover && ev.target !== isEmojiPopover) {\n            isEmojiPopover.remove();\n        }\n    }\n\n    _onScroll(ev) {\n        if (this._rowUiTarget && !this._rowUi.classList.contains('o_open')) {\n            this._positionTableUi(this._rowUiTarget);\n        }\n        if (this._columnUiTarget && !this._columnUi.classList.contains('o_open')) {\n            this._positionTableUi(this._columnUiTarget);\n        }\n    }\n\n    _onDocumentKeydown(ev) {\n        const canUndoRedo = !['INPUT', 'TEXTAREA'].includes(this.document.activeElement.tagName);\n\n        if (this.options.controlHistoryFromDocument && canUndoRedo) {\n            if (IS_KEYBOARD_EVENT_UNDO(ev) && canUndoRedo) {\n                ev.preventDefault();\n                this.historyUndo();\n            } else if (IS_KEYBOARD_EVENT_REDO(ev) && canUndoRedo) {\n                ev.preventDefault();\n                this.historyRedo();\n            }\n        } else {\n            if (IS_KEYBOARD_EVENT_REDO(ev) || IS_KEYBOARD_EVENT_UNDO(ev)) {\n                this._onKeyupResetContenteditableNodes.push(\n                    ...this.editable.querySelectorAll('[contenteditable=true]'),\n                );\n                if (this.editable.getAttribute('contenteditable') === 'true') {\n                    this._onKeyupResetContenteditableNodes.push(this.editable);\n                }\n\n                for (const node of this._onKeyupResetContenteditableNodes) {\n                    this.automaticStepSkipStack();\n                    node.setAttribute('contenteditable', false);\n                }\n            }\n        }\n    }\n\n    _onDocumentKeyup() {\n        if (this._onKeyupResetContenteditableNodes.length) {\n            for (const node of this._onKeyupResetContenteditableNodes) {\n                this.automaticStepSkipStack();\n                node.setAttribute('contenteditable', true);\n            }\n            this._onKeyupResetContenteditableNodes = [];\n        }\n    }\n\n    _onDocumentMouseup() {\n        if (this.toolbar) {\n            this.toolbar.style.pointerEvents = 'auto';\n        }\n    }\n\n    _onMousemove(ev) {\n        if (this._currentMouseState === 'mousedown' && !this._isResizingTable) {\n            this._handleSelectionInTable(ev);\n        }\n        if (!this._rowUi.classList.contains('o_open') && !this._columnUi.classList.contains('o_open')) {\n            const column = closestElement(ev.target, 'td');\n            if (this._isResizingTable || !column || !column.isContentEditable || !ev.target || ev.target.nodeType !== Node.ELEMENT_NODE) {\n                this._toggleTableUi(false, false);\n            } else {\n                const row = closestElement(column, 'tr');\n                const isFirstColumn = column === row.querySelector('td');\n                const table = column && closestElement(column, 'table');\n                const isFirstRow = table && row === table.querySelector('tr');\n                this._toggleTableUi(isFirstColumn && row, isFirstRow && column);\n            }\n        }\n        const direction = {top: 'row', right: 'col', bottom: 'row', left: 'col'}[this._isHoveringTdBorder(ev)] || false;\n        if (direction || !this._isResizingTable) {\n            this._toggleTableResizeCursor(direction);\n        }\n    }\n\n    _onDocumentClick(ev) {\n        // Close Table UI.\n        this._rowUi.classList.remove('o_open');\n        this._columnUi.classList.remove('o_open');\n    }\n\n    /**\n     * Inserts a link in the editor. Called after pressing space or (shif +) enter.\n     * Performs a regex check to determine if the url has correct syntax.\n     */\n    _handleAutomaticLinkInsertion() {\n        const selection = this.document.getSelection();\n        if (\n            selection &&\n            selection.anchorNode &&\n            isHtmlContentSupported(selection.anchorNode) &&\n            !closestElement(selection.anchorNode).closest('a') &&\n            selection.anchorNode.nodeType === Node.TEXT_NODE\n        ) {\n            // Merge adjacent text nodes.\n            selection.anchorNode.parentNode.normalize();\n            const textSliced = selection.anchorNode.textContent.slice(0, selection.anchorOffset);\n            const textNodeSplitted = textSliced.split(/\\s/);\n            const potentialUrl = textNodeSplitted.pop();\n            // In case of multiple matches, only the last one will be converted.\n            const match = [...potentialUrl.matchAll(new RegExp(URL_REGEX, 'g'))].pop();\n\n            if (match && !EMAIL_REGEX.test(match[0])) {\n                const nodeForSelectionRestore = selection.anchorNode.splitText(selection.anchorOffset);\n                const url = match[2] ? match[0] : 'http://' + match[0];\n                const range = this.document.createRange();\n                const startOffset = selection.anchorOffset - potentialUrl.length + match.index;\n                range.setStart(selection.anchorNode, startOffset);\n                range.setEnd(selection.anchorNode, startOffset + match[0].length);\n                const link = this._createLink(range.extractContents().textContent, url);\n                range.insertNode(link);\n                setCursorStart(nodeForSelectionRestore, false);\n            }\n        }\n    }\n\n    /**\n     * @param {String} label\n     * @param {String} url\n     */\n    _createLink(label, url) {\n        const link = this.document.createElement('a');\n        link.setAttribute('href', url);\n        for (const [param, value] of Object.entries(this.options.defaultLinkAttributes)) {\n            link.setAttribute(param, `${value}`);\n        }\n        link.innerText = label;\n        return link;\n    }\n    /**\n     * Add images inside the editable at the current selection.\n     *\n     * @param {File[]} imageFiles\n     */\n    addImagesFiles(imageFiles) {\n        const promises = [];\n        for (const imageFile of imageFiles) {\n            const imageNode = document.createElement('img');\n            imageNode.classList.add('img-fluid');\n            // Mark images as having to be saved as attachments.\n            if (this.options.dropImageAsAttachment) {\n                imageNode.classList.add('o_b64_image_to_save');\n            }\n            imageNode.dataset.fileName = imageFile.name;\n            promises.push(getImageUrl(imageFile).then(url => {\n                imageNode.src = url;\n                return imageNode;\n            }));\n        }\n        return Promise.all(promises).then(nodes => {\n            const fragment = document.createDocumentFragment();\n            fragment.append(...nodes);\n            return fragment;\n        });\n    }\n    /**\n     * Handle safe pasting of html or plain text into the editor.\n     */\n    _onPaste(ev) {\n        const sel = this.document.getSelection();\n        if (sel.anchorNode && isProtected(sel.anchorNode)) {\n            return;\n        }\n        ev.preventDefault();\n        const files = getImageFiles(ev.clipboardData);\n        const odooEditorHtml = ev.clipboardData.getData('text/odoo-editor');\n        const clipboardHtml = ev.clipboardData.getData('text/html');\n        const targetSupportsHtmlContent = isHtmlContentSupported(sel.anchorNode);\n        // Replace entire link if its label is fully selected.\n        const link = closestElement(sel.anchorNode, 'a');\n        if (link && sel.toString().replace(/\\u200B/g, '') === link.innerText.replace(/\\u200B/g, '')) {\n            const start = leftPos(link);\n            link.remove();\n            setSelection(...start, ...start, false);\n        }\n        if (!targetSupportsHtmlContent) {\n            const text = ev.clipboardData.getData(\"text/plain\");\n            this._applyCommand(\"insert\", text);\n        } else if (odooEditorHtml) {\n            const fragment = parseHTML(this.document, odooEditorHtml);\n            // Instantiate DOMPurify with the correct window.\n            this.DOMPurify ??= DOMPurify(this.document.defaultView);\n            this.DOMPurify.sanitize(fragment, { IN_PLACE: true });\n            if (fragment.hasChildNodes()) {\n                this._applyCommand('insert', fragment);\n            }\n        } else if (files.length || clipboardHtml) {\n            const clipboardElem = this._prepareClipboardData(clipboardHtml);\n            // When copy pasting a table from the outside, a picture of the\n            // table can be included in the clipboard as an image file. In that\n            // particular case the html table is given a higher priority than\n            // the clipboard picture.\n            if (files.length && !clipboardElem.querySelector('table')) {\n                this.addImagesFiles(files).then(html => {\n                    this._applyCommand('insert', html);\n                });\n            } else {\n                if (closestElement(sel.anchorNode, 'a')) {\n                    this._applyCommand('insert', clipboardElem.textContent);\n                }\n                else {\n                    this._applyCommand('insert', clipboardElem);\n                }\n            }\n        } else {\n            const text = ev.clipboardData.getData('text/plain');\n            const selectionIsInsideALink = !!closestElement(sel.anchorNode, 'a');\n            let splitAroundUrl = [text];\n            // Avoid transforming dynamic placeholder pattern to url.\n            if(!text.match(/\\${.*}/gi)) {\n                splitAroundUrl = text.split(URL_REGEX);\n                // Remove 'http(s)://' capturing group from the result (indexes\n                // 2, 5, 8, ...).\n                splitAroundUrl = splitAroundUrl.filter((_, index) => ((index + 1) % 3));\n            }\n            if (splitAroundUrl.length === 3 && !splitAroundUrl[0] && !splitAroundUrl[2]) {\n                // Pasted content is a single URL.\n                const url = /^https?:\\/\\//i.test(text) ? text : 'http://' + text;\n                const youtubeUrl = this.options.allowCommandVideo && YOUTUBE_URL_GET_VIDEO_ID.exec(url);\n                const urlFileExtention = url.split('.').pop();\n                const isImageUrl = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp'].includes(urlFileExtention.toLowerCase());\n                // A url cannot be transformed inside an existing link.\n                // An image can be embedded inside an existing link, a video cannot.\n                if (selectionIsInsideALink) {\n                    if (isImageUrl) {\n                        const img = document.createElement('IMG');\n                        img.setAttribute('src', url);\n                        this._applyCommand('insert', img);\n                    } else {\n                        this._applyCommand('insert', text);\n                    }\n                } else if (isImageUrl || youtubeUrl) {\n                    // Open powerbox with commands to embed media or paste as link.\n                    // Store history step index to revert it later.\n                    const stepIndexBeforeInsert = this._historySteps.length - 1;\n                    // Store mutations before text insertion, to reapply them after history revert.\n                    this.observerFlush();\n                    const currentStepMutations = [...this._currentStep.mutations];\n                    // Insert URL as text, revert it later.\n                    this._applyCommand('insert', text);\n                    const revertTextInsertion = () => {\n                        this.historyRevertUntil(stepIndexBeforeInsert);\n                        this.historyStep(true);\n                        this._historyStepsStates.set(peek(this._historySteps).id, 'consumed');\n                        // Reapply mutations that were done before the text insertion.\n                        this.historyApply(currentStepMutations);\n                    };\n                    let commands;\n                    const pasteAsURLCommand = {\n                        name: this.options._t('Paste as URL'),\n                        description: this.options._t('Create an URL.'),\n                        fontawesome: 'fa-link',\n                        callback: () => {\n                            revertTextInsertion();\n                            this._applyRawCommand('insert', this._createLink(text, url))\n                        },\n                    };\n                    if (isImageUrl) {\n                        const embedImageCommand = {\n                            name: this.options._t('Embed Image'),\n                            description: this.options._t('Embed the image in the document.'),\n                            fontawesome: 'fa-image',\n                            callback: () => {\n                                revertTextInsertion();\n                                const img = document.createElement('IMG');\n                                img.setAttribute('src', url);\n                                this._applyRawCommand('insert', img);\n                            },\n                        };\n                        commands = [embedImageCommand, pasteAsURLCommand];\n                    } else {\n                         // URL is a YouTube video.\n                        const embedVideoCommand = {\n                            name: this.options._t('Embed Youtube Video'),\n                            description: this.options._t('Embed the youtube video in the document.'),\n                            fontawesome: 'fa-youtube-play',\n                            callback: async () => {\n                                revertTextInsertion();\n                                let videoElement;\n                                if (this.options.getYoutubeVideoElement) {\n                                    videoElement = await this.options.getYoutubeVideoElement(youtubeUrl[0]);\n                                } else {\n                                    videoElement = document.createElement('iframe');\n                                    videoElement.setAttribute('width', '560');\n                                    videoElement.setAttribute('height', '315');\n                                    videoElement.setAttribute(\n                                        'src',\n                                        `https://www.youtube.com/embed/${encodeURIComponent(youtubeUrl[1])}`,\n                                    );\n                                    videoElement.setAttribute('title', 'YouTube video player');\n                                    videoElement.setAttribute('frameborder', '0');\n                                    videoElement.setAttribute(\n                                        'allow',\n                                        'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture',\n                                    );\n                                    videoElement.setAttribute('allowfullscreen', '1');\n                                }\n                                this._applyRawCommand('insert', videoElement);\n                            },\n                        };\n                        commands = [embedVideoCommand, pasteAsURLCommand];\n                    }\n                    this.powerbox.open(commands);\n                } else {\n                    this._applyCommand('insert', this._createLink(text, url));\n                }\n            } else {\n                this.historyPauseSteps();\n                for (let i = 0; i < splitAroundUrl.length; i++) {\n                    const url = /^https?:\\/\\//gi.test(splitAroundUrl[i])\n                        ? splitAroundUrl[i]\n                        : 'http://' + splitAroundUrl[i];\n                    // Even indexes will always be plain text, and odd indexes will always be URL.\n                    // A url cannot be transformed inside an existing link.\n                    if (i % 2 && !selectionIsInsideALink) {\n                        this._applyCommand('insert', this._createLink(splitAroundUrl[i], url));\n                    } else if (splitAroundUrl[i] !== '') {\n                        const textFragments = splitAroundUrl[i].split(/\\r?\\n/);\n                        let textIndex = 1;\n                        for (const textFragment of textFragments) {\n                            // Replace consecutive spaces by alternating nbsp.\n                            const modifiedTextFragment = textFragment.replace(/( {2,})/g, match => {\n                                let alertnateValue = false;\n                                return match.replace(/ /g, () => {\n                                    alertnateValue = !alertnateValue;\n                                    const replaceContent = alertnateValue ? '\\u00A0' : ' ';\n                                    return replaceContent;\n                                });\n                            });\n                            this._applyCommand('insert', modifiedTextFragment);\n                            if (textIndex < textFragments.length) {\n                                // Break line by inserting new paragraph and\n                                // remove current paragraph's bottom margin.\n                                const p = closestElement(sel.anchorNode, 'p');\n                                if (isUnbreakable(closestBlock(sel.anchorNode))) {\n                                    this._applyCommand('oShiftEnter');\n                                } else {\n                                    this._applyCommand('oEnter');\n                                    p && (p.style.marginBottom = '0px');\n                                }\n                            }\n                            textIndex++;\n                        }\n                    }\n                }\n                this.historyUnpauseSteps();\n                this.historyStep();\n            }\n        }\n    }\n    _onDragStart(ev) {\n        if (ev.target.nodeName === 'IMG') {\n            ev.dataTransfer.setData('text/plain', `oid:${ev.target.oid}`);\n        }\n    }\n    /**\n     * Handle safe dropping of html into the editor.\n     */\n    _onDrop(ev) {\n        ev.preventDefault();\n        if (!isHtmlContentSupported(ev.target)) {\n            return;\n        }\n        const sel = this.document.getSelection();\n        let isInEditor = false;\n        let ancestor = sel.anchorNode;\n        while (ancestor && !isInEditor) {\n            if (ancestor === this.editable) {\n                isInEditor = true;\n            }\n            ancestor = ancestor.parentNode;\n        }\n        const dataTransfer = (ev.originalEvent || ev).dataTransfer;\n        const imageOidMatch = (dataTransfer.getData('text') || '').match('oid:(.*)');\n        const imageOid = imageOidMatch && imageOidMatch[1];\n        const image = imageOid && [...this.editable.querySelectorAll('*')].find(\n            node => node.oid === imageOid,\n        );\n        const fileTransferItems = getImageFiles(dataTransfer);\n        const htmlTransferItem = [...dataTransfer.items].find(\n            item => item.type === 'text/html',\n        );\n        if (image || fileTransferItems.length || htmlTransferItem) {\n            if (this.document.caretPositionFromPoint) {\n                const range = this.document.caretPositionFromPoint(ev.clientX, ev.clientY);\n                setSelection(range.offsetNode, range.offset);\n            } else if (this.document.caretRangeFromPoint) {\n                const range = this.document.caretRangeFromPoint(ev.clientX, ev.clientY);\n                setSelection(range.startContainer, range.startOffset);\n            }\n        }\n        if (image) {\n            image.classList.toggle('img-fluid', true);\n            const html = image.outerHTML;\n            image.remove();\n            this.execCommand('insert', this._prepareClipboardData(html));\n        } else if (fileTransferItems.length) {\n            this.addImagesFiles(fileTransferItems).then(html => {\n                this.execCommand('insert', html);\n            });\n        } else if (htmlTransferItem) {\n            htmlTransferItem.getAsString(pastedText => {\n                this.execCommand('insert', this._prepareClipboardData(pastedText));\n            });\n        }\n        this.historyStep();\n    }\n\n    _onTabulationInTable(ev) {\n        const sel = this.document.getSelection();\n        const closestTable = closestElement(sel.anchorNode, 'table');\n        if (!closestTable) {\n            return;\n        }\n        const closestTd = closestElement(sel.anchorNode, 'td');\n        const tds = [...closestTable.querySelectorAll('td')];\n        const direction = ev.shiftKey ? DIRECTIONS.LEFT : DIRECTIONS.RIGHT;\n        const cursorDestination =\n            tds[tds.findIndex(td => closestTd === td) + (direction === DIRECTIONS.LEFT ? -1 : 1)];\n        if (cursorDestination) {\n            setCursorEnd(lastLeaf(cursorDestination));\n        } else if (direction === DIRECTIONS.RIGHT) {\n            this.execCommand('addRow', 'after');\n            this._onTabulationInTable(ev);\n        }\n    }\n    _onTableMenuTogglerClick(ev) {\n        const uiWrapper = ev.target.closest('.o_table_ui');\n        uiWrapper.classList.toggle('o_open');\n\n        if (this.options.direction === 'rtl') {\n            const menuRowEl = this._tableUiContainer.querySelector('.o_row_ui .o_table_ui_menu')\n            const menuRowRect = menuRowEl.getBoundingClientRect();\n            menuRowEl.style.position = 'absolute';\n            menuRowEl.style.left = `-${menuRowRect.width}px`;\n            menuRowEl.style.margin = `0px`;\n        }\n\n        if (uiWrapper.classList.contains('o_column_ui')) {\n            const columnIndex = getColumnIndex(this._columnUiTarget);\n            uiWrapper.querySelector('.o_move_left').classList.toggle('o_hide', columnIndex === 0);\n            const shouldHideRight = columnIndex === [...this._columnUiTarget.parentElement.children].filter(child => child.nodeName === 'TD').length - 1;\n            uiWrapper.querySelector('.o_move_right').classList.toggle('o_hide', shouldHideRight);\n        } else {\n            const rowIndex = getRowIndex(this._rowUiTarget);\n            uiWrapper.querySelector('.o_move_up').classList.toggle('o_hide', rowIndex === 0);\n            const shouldHideDown = rowIndex === [...this._rowUiTarget.parentElement.children].filter(child => child.nodeName === 'TR').length - 1;\n            uiWrapper.querySelector('.o_move_down').classList.toggle('o_hide', shouldHideDown);\n        }\n        ev.stopPropagation();\n    }\n    _onTableMoveUpClick() {\n        if (this._rowUiTarget.previousSibling) {\n            this._rowUiTarget.previousSibling.before(this._rowUiTarget);\n        }\n    }\n    _onTableMoveDownClick() {\n        if (this._rowUiTarget.nextSibling) {\n            this._rowUiTarget.nextSibling.after(this._rowUiTarget);\n        }\n    }\n    _onTableMoveRightClick() {\n        const trs = [...this._columnUiTarget.parentElement.parentElement.children].filter(child => child.nodeName === 'TR');\n        const columnIndex = getColumnIndex(this._columnUiTarget);\n        const tdsToMove = trs.map(tr => [...tr.children].filter(child => child.nodeName === 'TD')[columnIndex]);\n        for (const tdToMove of tdsToMove) {\n            const target = [...tdToMove.parentElement.children].filter(child => child.nodeName === 'TD')[columnIndex + 1];\n            target.after(tdToMove);\n        }\n    }\n    _onTableMoveLeftClick() {\n        const trs = [...this._columnUiTarget.parentElement.parentElement.children].filter(child => child.nodeName === 'TR');\n        const columnIndex = getColumnIndex(this._columnUiTarget);\n        const tdsToMove = trs.map(tr => [...tr.children].filter(child => child.nodeName === 'TD')[columnIndex]);\n        for (const tdToMove of tdsToMove) {\n            const target = [...tdToMove.parentElement.children].filter(child => child.nodeName === 'TD')[columnIndex - 1];\n            target.before(tdToMove);\n        }\n    }\n    _onTableDeleteColumnClick() {\n        this.historyPauseSteps();\n        const rows = [...closestElement(this._columnUiTarget, 'tr').parentElement.children].filter(child => child.nodeName === 'TR');\n        this.execCommand('removeColumn', this._columnUiTarget);\n        if (rows.every(row => !row.parentElement)) {\n            this.execCommand('deleteTable', this.editable.querySelector('.o_selected_table'));\n        }\n        this.historyUnpauseSteps();\n        this.historyStep();\n    }\n    _onTableDeleteRowClick() {\n        this.historyPauseSteps();\n        const rows = [...this._rowUiTarget.parentElement.children].filter(child => child.nodeName === 'TR');\n        this.execCommand('removeRow', this._rowUiTarget);\n        if (rows.every(row => !row.parentElement)) {\n            this.execCommand('deleteTable', this.editable.querySelector('.o_selected_table'));\n        }\n        this.historyUnpauseSteps();\n        this.historyStep();\n    }\n\n    /**\n     * Fix the current selection range in case the range start or end inside a fontAwesome node\n     */\n    _fixFontAwesomeSelection() {\n        const selection = this.document.getSelection();\n        if (\n            selection.isCollapsed ||\n            (selection.anchorNode &&\n                !ancestors(selection.anchorNode, this.editable).includes(this.editable))\n        )\n            return;\n        let shouldUpdateSelection = false;\n        const fixedSelection = {\n            anchorNode: selection.anchorNode,\n            anchorOffset: selection.anchorOffset,\n            focusNode: selection.focusNode,\n            focusOffset: selection.focusOffset,\n        };\n        const selectionDirection = getCursorDirection(\n            selection.anchorNode,\n            selection.anchorOffset,\n            selection.focusNode,\n            selection.focusOffset,\n        );\n        // check and fix anchor node\n        const closestAnchorNodeEl = closestElement(selection.anchorNode);\n        if (isFontAwesome(closestAnchorNodeEl)) {\n            shouldUpdateSelection = true;\n            fixedSelection.anchorNode =\n                selectionDirection === DIRECTIONS.RIGHT\n                    ? closestAnchorNodeEl.previousSibling\n                    : closestAnchorNodeEl.nextSibling;\n            if (fixedSelection.anchorNode) {\n                fixedSelection.anchorOffset =\n                    selectionDirection === DIRECTIONS.RIGHT ? fixedSelection.anchorNode.length : 0;\n            } else {\n                fixedSelection.anchorNode = closestAnchorNodeEl.parentElement;\n                fixedSelection.anchorOffset = 0;\n            }\n        }\n        // check and fix focus node\n        const closestFocusNodeEl = closestElement(selection.focusNode);\n        if (isFontAwesome(closestFocusNodeEl)) {\n            shouldUpdateSelection = true;\n            fixedSelection.focusNode =\n                selectionDirection === DIRECTIONS.RIGHT\n                    ? closestFocusNodeEl.nextSibling\n                    : closestFocusNodeEl.previousSibling;\n            if (fixedSelection.focusNode) {\n                fixedSelection.focusOffset =\n                    selectionDirection === DIRECTIONS.RIGHT ? 0 : fixedSelection.focusNode.length;\n            } else {\n                fixedSelection.focusNode = closestFocusNodeEl.parentElement;\n                fixedSelection.focusOffset = 0;\n            }\n        }\n        if (shouldUpdateSelection) {\n            setSelection(\n                fixedSelection.anchorNode,\n                fixedSelection.anchorOffset,\n                fixedSelection.focusNode,\n                fixedSelection.focusOffset,\n                false,\n            );\n        }\n    }\n    _pluginAdd(Plugin) {\n        this._plugins.push(new Plugin({ editor: this }));\n    }\n    _pluginCall(method, args = []) {\n        for (const plugin of this._plugins) {\n            if (plugin[method]) {\n                plugin[method](...args);\n            }\n        }\n    }\n}\n", "/** @odoo-module **/\nimport { childNodeIndex, isBlock } from '../utils/utils.js';\n\nText.prototype.oAlign = function (offset, mode) {\n    this.parentElement.oAlign(childNodeIndex(this), mode);\n};\n/**\n * This does not check for command state\n * @param {*} offset\n * @param {*} mode 'left', 'right', 'center' or 'justify'\n */\nHTMLElement.prototype.oAlign = function (offset, mode) {\n    if (!isBlock(this)) {\n        return this.parentElement.oAlign(childNodeIndex(this), mode);\n    }\n    const { textAlign } = getComputedStyle(this);\n    const alreadyAlignedLeft = textAlign === 'start' || textAlign === 'left';\n    const shouldApplyStyle = !(alreadyAlignedLeft && mode === 'left');\n    if (shouldApplyStyle) {\n        this.style.textAlign = mode;\n    }\n};\n", "/** @odoo-module **/\nimport { REGEX_BOOTSTRAP_COLUMN } from '../utils/constants.js';\nimport {\n    ancestors,\n    descendants,\n    childNodeIndex,\n    closestBlock,\n    closestElement,\n    closestPath,\n    DIRECTIONS,\n    findNode,\n    getCursors,\n    getDeepRange,\n    getInSelection,\n    getListMode,\n    getSelectedNodes,\n    getTraversedNodes,\n    insertAndSelectZws,\n    insertText,\n    isBlock,\n    isColorGradient,\n    isSelectionFormat,\n    isShrunkBlock,\n    isSelfClosingElement,\n    leftLeafFirstPath,\n    preserveCursor,\n    rightPos,\n    setSelection,\n    setCursorStart,\n    setTagName,\n    splitAroundUntil,\n    splitElement,\n    splitTextNode,\n    startPos,\n    nodeSize,\n    allowsParagraphRelatedElements,\n    isUnbreakable,\n    makeContentsInline,\n    unwrapContents,\n    getColumnIndex,\n    pxToFloat,\n    getRowIndex,\n    parseHTML,\n    formatSelection,\n    getDeepestPosition,\n    fillEmpty,\n    isEmptyBlock,\n    isWhitespace,\n    isVisibleTextNode,\n    getCursorDirection,\n    resetOuids,\n    FONT_SIZE_CLASSES,\n    TEXT_STYLE_CLASSES,\n} from '../utils/utils.js';\n\nconst TEXT_CLASSES_REGEX = /\\btext-[^\\s]*\\b/;\nconst BG_CLASSES_REGEX = /\\bbg-[^\\s]*\\b/;\n\nfunction align(editor, mode) {\n    const sel = editor.document.getSelection();\n    const visitedBlocks = new Set();\n    const traversedNode = getTraversedNodes(editor.editable);\n    for (const node of traversedNode) {\n        if (isVisibleTextNode(node)) {\n            const block = closestBlock(node);\n            if (!visitedBlocks.has(block)) {\n                const hasModifier = getComputedStyle(block).textAlign === mode;\n                if (!hasModifier && block.isContentEditable) {\n                    block.oAlign(sel.anchorOffset, mode);\n                }\n                visitedBlocks.add(block);\n            }\n        }\n    }\n}\n\n/**\n * Applies a css or class color (fore- or background-) to an element.\n * Replace the color that was already there if any.\n *\n * @param {Element} element\n * @param {string} color hexadecimal or bg-name/text-name class\n * @param {string} mode 'color' or 'backgroundColor'\n */\nfunction colorElement(element, color, mode) {\n    const newClassName = element.className\n        .replace(mode === 'color' ? TEXT_CLASSES_REGEX : BG_CLASSES_REGEX, '')\n        .replace(/\\btext-gradient\\b/g, '') // cannot be combined with setting a background\n        .replace(/\\s+/, ' ');\n    element.className !== newClassName && (element.className = newClassName);\n    element.style['background-image'] = '';\n    if (mode === 'backgroundColor') {\n        element.style['background'] = '';\n    }\n    if (color.startsWith('text') || color.startsWith('bg-')) {\n        element.style[mode] = '';\n        element.classList.add(color);\n    } else if (isColorGradient(color)) {\n        element.style[mode] = '';\n        if (mode === 'color') {\n            element.style['background'] = '';\n            element.style['background-image'] = color;\n            element.classList.add('text-gradient');\n        } else {\n            element.style['background-image'] = color;\n        }\n    } else {\n        element.style[mode] = color;\n    }\n}\n\n/**\n * Returns true if the given element has a visible color (fore- or\n * -background depending on the given mode).\n *\n * @param {Element} element\n * @param {string} mode 'color' or 'backgroundColor'\n * @returns {boolean}\n */\nfunction hasColor(element, mode) {\n    const style = element.style;\n    const parent = element.parentNode;\n    const classRegex = mode === 'color' ? TEXT_CLASSES_REGEX : BG_CLASSES_REGEX;\n    if (isColorGradient(style['background-image'])) {\n        if (element.classList.contains('text-gradient')) {\n            if (mode === 'color') {\n                return true;\n            }\n        } else {\n            if (mode !== 'color') {\n                return true;\n            }\n        }\n    }\n    return (\n        (style[mode] && style[mode] !== 'inherit' && (!parent || style[mode] !== parent.style[mode])) ||\n        (classRegex.test(element.className) &&\n            (!parent || getComputedStyle(element)[mode] !== getComputedStyle(parent)[mode]))\n    );\n}\n\n// This is a whitelist of the commands that are implemented by the\n// editor itself rather than the node prototypes. It might be\n// possible to switch the conditions and test if the method exist on\n// `sel.anchorNode` rather than relying on an expicit whitelist, but\n// the behavior would change if a method name exists both on the\n// editor and on the nodes. This is too risky to change in the\n// absence of a strong test suite, so the whitelist stays for now.\nexport const editorCommands = {\n    insert: (editor, content) => {\n        if (!content) return;\n        const selection = editor.document.getSelection();\n        let startNode;\n        let insertBefore = false;\n        if (!selection.isCollapsed) {\n            editor.deleteRange(selection);\n        }\n        const range = selection.getRangeAt(0);\n        if (range.startContainer.nodeType === Node.TEXT_NODE) {\n            insertBefore = !range.startOffset;\n            splitTextNode(range.startContainer, range.startOffset, DIRECTIONS.LEFT);\n            startNode = range.startContainer;\n        }\n\n        const container = document.createElement('fake-element');\n        const containerFirstChild = document.createElement('fake-element-fc');\n        const containerLastChild = document.createElement('fake-element-lc');\n\n        if (typeof content === 'string') {\n            container.textContent = content;\n        } else {\n            container.replaceChildren(content);\n        }\n\n        // In case the html inserted starts with a list and will be inserted within\n        // a list, unwrap the list elements from the list.\n        if (closestElement(selection.anchorNode, 'UL, OL') &&\n            (container.firstChild.nodeName === 'UL' || container.firstChild.nodeName === 'OL')) {\n            container.replaceChildren(...container.firstChild.childNodes);\n        }\n\n        startNode = startNode || editor.document.getSelection().anchorNode;\n        // If the selection anchorNode is the editable itself, the content\n        // should not be unwrapped.\n        if (selection.anchorNode.oid !== 'root') {\n            // In case the html inserted is all contained in a single root <p> or <li>\n            // tag, we take the all content of the <p> or <li> and avoid inserting the\n            // <p> or <li>. The same is true for a <pre> inside a <pre>.\n            if (container.childElementCount === 1 && (\n                container.firstChild.nodeName === 'P' ||\n                container.firstChild.nodeName === 'LI' ||\n                container.firstChild.nodeName === 'PRE' && closestElement(startNode, 'pre')\n            )) {\n                const p = container.firstElementChild;\n                container.replaceChildren(...p.childNodes);\n            } else if (container.childElementCount > 1) {\n                // Grab the content of the first child block and isolate it.\n                if (isBlock(container.firstChild) && !['TABLE', 'UL', 'OL'].includes(container.firstChild.nodeName)) {\n                    containerFirstChild.replaceChildren(...container.firstElementChild.childNodes);\n                    container.firstElementChild.remove();\n                }\n                // Grab the content of the last child block and isolate it.\n                if (isBlock(container.lastChild) && !['TABLE', 'UL', 'OL'].includes(container.lastChild.nodeName)) {\n                    containerLastChild.replaceChildren(...container.lastElementChild.childNodes);\n                    container.lastElementChild.remove();\n                }\n            }\n        }\n\n        if (startNode.nodeType === Node.ELEMENT_NODE) {\n            if (selection.anchorOffset === 0) {\n                const textNode = editor.document.createTextNode('');\n                if (isSelfClosingElement(startNode)) {\n                    startNode.parentNode.insertBefore(textNode, startNode);\n                } else {\n                    startNode.prepend(textNode);\n                }\n                startNode = textNode;\n            } else {\n                startNode = startNode.childNodes[selection.anchorOffset - 1];\n            }\n        }\n\n        // If we have isolated block content, first we split the current focus\n        // element if it's a block then we insert the content in the right places.\n        let currentNode = startNode;\n        let lastChildNode = false;\n        const _insertAt = (reference, nodes, insertBefore) => {\n            for (const child of (insertBefore ? nodes.reverse() : nodes)) {\n                reference[insertBefore ? 'before' : 'after'](child);\n                reference = child;\n            }\n        }\n        const lastInsertedNodes = [...containerLastChild.childNodes];\n        if (containerLastChild.hasChildNodes()) {\n            const toInsert = [...containerLastChild.childNodes]; // Prevent mutation\n            _insertAt(currentNode, [...toInsert], insertBefore);\n            currentNode = insertBefore ? toInsert[0] : currentNode;\n            lastChildNode = toInsert[toInsert.length - 1];\n        }\n        const firstInsertedNodes = [...containerFirstChild.childNodes];\n        if (containerFirstChild.hasChildNodes()) {\n            const toInsert = [...containerFirstChild.childNodes]; // Prevent mutation\n            _insertAt(currentNode, [...toInsert], insertBefore);\n            currentNode = toInsert[toInsert.length - 1];\n            insertBefore = false;\n        }\n\n        // If all the Html have been isolated, We force a split of the parent element\n        // to have the need new line in the final result\n        if (!container.hasChildNodes()) {\n            if (isUnbreakable(closestBlock(currentNode.nextSibling))) {\n                currentNode.nextSibling.oShiftEnter(0);\n            } else {\n                // If we arrive here, the o_enter index should always be 0.\n                const parent = currentNode.nextSibling.parentElement;\n                const index = [...parent.childNodes].indexOf(currentNode.nextSibling);\n                currentNode.nextSibling.parentElement.oEnter(index);\n            }\n        }\n\n        let nodeToInsert;\n        const insertedNodes = [...container.childNodes];\n        while ((nodeToInsert = container.childNodes[0])) {\n            if (isBlock(nodeToInsert) && !allowsParagraphRelatedElements(currentNode)) {\n                // Split blocks at the edges if inserting new blocks (preventing\n                // <p><p>text</p></p> or <li><li>text</li></li> scenarios).\n                while (\n                    currentNode.parentElement !== editor.editable &&\n                    (!allowsParagraphRelatedElements(currentNode.parentElement) ||\n                        currentNode.parentElement.nodeName === 'LI')\n                ) {\n                    if (isUnbreakable(currentNode.parentElement)) {\n                        makeContentsInline(container);\n                        nodeToInsert = container.childNodes[0];\n                        break;\n                    }\n                    let offset = childNodeIndex(currentNode);\n                    if (!insertBefore) {\n                        offset += 1;\n                    }\n                    if (offset) {\n                        const [left, right] = splitElement(currentNode.parentElement, offset);\n                        currentNode = insertBefore ? right : left;\n                    } else {\n                        currentNode = currentNode.parentElement;\n                    }\n                }\n            }\n            if (insertBefore) {\n                currentNode.before(nodeToInsert);\n                insertBefore = false;\n            } else {\n                currentNode.after(nodeToInsert);\n            }\n            if (currentNode.tagName !== 'BR' && isShrunkBlock(currentNode)) {\n                currentNode.remove();\n            }\n            currentNode = nodeToInsert;\n        }\n\n        currentNode = lastChildNode || currentNode;\n        selection.removeAllRanges();\n        const newRange = new Range();\n        let lastPosition = rightPos(currentNode);\n        if (lastPosition[0] === editor.editable) {\n            // Correct the position if it happens to be in the editable root.\n            lastPosition = getDeepestPosition(...lastPosition);\n        }\n        newRange.setStart(lastPosition[0], lastPosition[1]);\n        newRange.setEnd(lastPosition[0], lastPosition[1]);\n        selection.addRange(newRange);\n        return [...firstInsertedNodes, ...insertedNodes, ...lastInsertedNodes];\n    },\n    insertFontAwesome: (editor, faClass = 'fa fa-star') => {\n        const insertedNode = editorCommands.insert(editor, document.createElement('i'))[0];\n        insertedNode.className = faClass;\n        const position = rightPos(insertedNode);\n        setSelection(...position, ...position, false);\n    },\n\n    // History\n    undo: editor => editor.historyUndo(),\n    redo: editor => editor.historyRedo(),\n\n    // Change tags\n    setTag(editor, tagName, extraClass = \"\") {\n        const range = getDeepRange(editor.editable, { correctTripleClick: true });\n        const selectedBlocks = [...new Set(getTraversedNodes(editor.editable, range).map(closestBlock))];\n        const deepestSelectedBlocks = selectedBlocks.filter(block => (\n            !descendants(block).some(descendant => selectedBlocks.includes(descendant)) &&\n            block.isContentEditable\n        ));\n        let { startContainer, startOffset, endContainer, endOffset } = range;\n        const startContainerChild = startContainer.firstChild;\n        const endContainerChild = endContainer.lastChild;\n        for (const block of deepestSelectedBlocks) {\n            if (\n                ['P', 'PRE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'BLOCKQUOTE'].includes(\n                    block.nodeName,\n                )\n            ) {\n                const inLI = block.closest('li');\n                if (inLI && tagName === \"P\") {\n                    inLI.oToggleList(0);\n                } else {\n                    const newEl = setTagName(block, tagName);\n                    newEl.classList.remove(\n                        ...FONT_SIZE_CLASSES,\n                        ...TEXT_STYLE_CLASSES,\n                        // We want to be able to edit the case `<h2 class=\"h3\">`\n                        // but in that case, we want to display \"Header 2\" and\n                        // not \"Header 3\" as it is more important to display\n                        // the semantic tag being used (especially for h1 ones).\n                        // This is why those are not in `TEXT_STYLE_CLASSES`.\n                        \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"\n                    );\n                    delete newEl.style.fontSize;\n                    if (extraClass) {\n                        newEl.classList.add(extraClass);\n                    }\n                    if (newEl.classList.length === 0) {\n                        newEl.removeAttribute(\"class\");\n                    }\n                }\n            } else {\n                // eg do not change a <div> into a h1: insert the h1\n                // into it instead.\n                const newBlock = editor.document.createElement(tagName);\n                const children = [...block.childNodes];\n                block.insertBefore(newBlock, block.firstChild);\n                children.forEach(child => newBlock.appendChild(child));\n            }\n        }\n        const isContextBlock = container => ['TD', 'DIV', 'LI'].includes(container.nodeName);\n        if (!startContainer.isConnected || isContextBlock(startContainer)) {\n            startContainer = startContainerChild.parentNode;\n        }\n        if (!endContainer.isConnected || isContextBlock(endContainer)) {\n            endContainer = endContainerChild.parentNode;\n        }\n        const newRange = new Range();\n        newRange.setStart(startContainer, startOffset);\n        newRange.setEnd(endContainer, endOffset);\n        getDeepRange(editor.editable, { range: newRange, select: true });\n        editor.historyStep();\n    },\n\n    // Formats\n    // -------------------------------------------------------------------------\n    bold: editor => formatSelection(editor, 'bold'),\n    italic: editor => formatSelection(editor, 'italic'),\n    underline: editor => formatSelection(editor, 'underline'),\n    strikeThrough: editor => formatSelection(editor, 'strikeThrough'),\n    setFontSize: (editor, size) => formatSelection(editor, 'fontSize', {applyStyle: true, formatProps: {size}}),\n    setFontSizeClassName: (editor, className) => formatSelection(editor, 'setFontSizeClassName', {formatProps: {className}}),\n    switchDirection: editor => {\n        getDeepRange(editor.editable, { splitText: true, select: true, correctTripleClick: true });\n        const selection = editor.document.getSelection();\n        const selectedTextNodes = [selection.anchorNode, ...getSelectedNodes(editor.editable), selection.focusNode]\n            .filter(n => n.nodeType === Node.TEXT_NODE && closestElement(n).isContentEditable && n.nodeValue.trim().length);\n\n        const changedElements = [];\n        const defaultDirection = editor.options.direction;\n        const shouldApplyStyle = !isSelectionFormat(editor.editable, 'switchDirection');\n        let blocks = new Set(selectedTextNodes.map(textNode => closestElement(textNode, 'ul,ol') || closestBlock(textNode)));\n        blocks.forEach(block => {\n            blocks = [...blocks, ...block.querySelectorAll('ul,ol')];\n        })\n        for (const block of blocks) {\n            if (!shouldApplyStyle) {\n                block.removeAttribute('dir');\n            } else {\n                block.setAttribute('dir', defaultDirection === 'ltr' ? 'rtl' : 'ltr');\n            }\n            changedElements.push(block);\n        }\n\n        for (const element of changedElements) {\n            const style = getComputedStyle(element);\n            if (style.direction === 'ltr' && style.textAlign === 'right') {\n                element.style.setProperty('text-align', 'left');\n            } else if (style.direction === 'rtl' && style.textAlign === 'left') {\n                element.style.setProperty('text-align', 'right');\n            }\n        }\n    },\n    removeFormat: editor => {\n        const textAlignStyles = new Map();\n        getTraversedNodes(editor.editable).forEach((element) => {\n            const block = closestBlock(element);\n            if (block.style.textAlign) {\n                textAlignStyles.set(block, block.style.textAlign);\n            }\n        });\n        // Calling `document.execCommand` will cause an input event with the\n        // input type \"formatRemove\". This would cause a new history step to be\n        // created in the middle of the process, which we prevent here.\n        editor.historyPauseSteps();\n        editor.document.execCommand('removeFormat');\n        for (const node of getTraversedNodes(editor.editable)) {\n            if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('color')) {\n                node.removeAttribute('color');\n            }\n            const element = closestElement(node);\n            element.style.removeProperty('color');\n            element.style.removeProperty('background');\n        }\n        textAlignStyles.forEach((textAlign, block) => {\n            block.style.setProperty('text-align', textAlign);\n        });\n        editor.historyUnpauseSteps();\n    },\n\n    // Align\n    justifyLeft: editor => align(editor, 'left'),\n    justifyRight: editor => align(editor, 'right'),\n    justifyCenter: editor => align(editor, 'center'),\n    justifyFull: editor => align(editor, 'justify'),\n\n    // Link\n    createLink: (editor, link, content) => {\n        const sel = editor.document.getSelection();\n        if (content && !sel.isCollapsed) {\n            editor.deleteRange(sel);\n        }\n        if (sel.isCollapsed) {\n            insertText(sel, content || 'link');\n        }\n        const currentLink = closestElement(sel.focusNode, 'a');\n        link = link || prompt('URL or Email', (currentLink && currentLink.href) || 'http://');\n        const res = editor.document.execCommand('createLink', false, link);\n        if (res) {\n            setSelection(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n            const node = findNode(closestPath(sel.focusNode), node => node.tagName === 'A');\n            for (const [param, value] of Object.entries(editor.options.defaultLinkAttributes)) {\n                node.setAttribute(param, `${value}`);\n            }\n            const pos = [node.parentElement, childNodeIndex(node) + 1];\n            setSelection(...pos, ...pos, false);\n        }\n    },\n    unlink: editor => {\n        const sel = editor.document.getSelection();\n        const isCollapsed = sel.isCollapsed;\n        // If the selection is collapsed, unlink the whole link:\n        // `<a>a[]b</a>` => `a[]b`.\n        getDeepRange(editor.editable, { sel, splitText: true, select: true });\n        if (!isCollapsed) {\n            // If not, unlink only the part(s) of the link(s) that are selected:\n            // `<a>a[b</a>c<a>d</a>e<a>f]g</a>` => `<a>a</a>[bcdef]<a>g</a>`.\n            let { anchorNode, focusNode, anchorOffset, focusOffset } = sel;\n            const direction = getCursorDirection(anchorNode, anchorOffset, focusNode, focusOffset);\n            // Split the links around the selection.\n            const [startLink, endLink] = [closestElement(anchorNode, 'a'), closestElement(focusNode, 'a')];\n            if (startLink) {\n                anchorNode = splitAroundUntil(anchorNode, startLink);\n                anchorOffset = direction === DIRECTIONS.RIGHT ? 0 : nodeSize(anchorNode);\n                setSelection(anchorNode, anchorOffset, focusNode, focusOffset, true);\n            }\n            // Only split the end link if it was not already done above.\n            if (endLink && endLink.isConnected) {\n                focusNode = splitAroundUntil(focusNode, endLink);\n                focusOffset = direction === DIRECTIONS.RIGHT ? nodeSize(focusNode) : 0;\n                setSelection(anchorNode, anchorOffset, focusNode, focusOffset, true);\n            }\n        }\n        const targetedNodes = isCollapsed ? [sel.anchorNode] : getSelectedNodes(editor.editable);\n        const links = new Set(targetedNodes.map(node => closestElement(node, 'a')).filter(a => a && a.isContentEditable));\n        if (links.size) {\n            const cr = preserveCursor(editor.document);\n            for (const link of links) {\n                unwrapContents(link);\n            }\n            cr();\n        }\n    },\n\n    // List\n    indentList: (editor, mode = 'indent') => {\n        const [pos1, pos2] = getCursors(editor.document);\n        const end = leftLeafFirstPath(...pos1).next().value;\n        const li = new Set();\n        for (const node of leftLeafFirstPath(...pos2)) {\n            const cli = closestElement(node,'li');\n            if (\n                cli &&\n                cli.tagName == 'LI' &&\n                !li.has(cli) &&\n                !cli.classList.contains('oe-nested') &&\n                cli.isContentEditable &&\n                !cli.classList.contains('nav-item')\n            ) {\n                li.add(cli);\n            }\n            if (node == end) break;\n        }\n        for (const node of li) {\n            if (mode == 'indent') {\n                node.oTab(0);\n            } else {\n                node.oShiftTab(0);\n            }\n        }\n        return true;\n    },\n    toggleList: (editor, mode) => {\n        const li = new Set();\n        const blocks = new Set();\n\n        const selectedBlocks = getTraversedNodes(editor.editable);\n        const deepestSelectedBlocks = selectedBlocks.filter(block => (\n            !descendants(block).some(descendant => selectedBlocks.includes(descendant))\n        ));\n        for (const node of deepestSelectedBlocks) {\n            if (node.nodeType === Node.TEXT_NODE && isWhitespace(node) && closestElement(node).isContentEditable) {\n                node.remove();\n            } else {\n                // Ensure nav-item lists are excluded from toggling\n                const isNavItemList = node => node.nodeName === 'LI' && node.classList.contains('nav-item');\n                let nodeToToggle = closestBlock(node);\n                nodeToToggle = isNavItemList(nodeToToggle) ? node : nodeToToggle;\n                if (!['OL', 'UL'].includes(nodeToToggle.tagName) && (nodeToToggle.isContentEditable || nodeToToggle.nodeType === Node.TEXT_NODE)) {\n                    const closestLi = closestElement(nodeToToggle, 'li');\n                    nodeToToggle = closestLi && !isNavItemList(closestLi) ? closestLi : nodeToToggle;\n                    const ublock = nodeToToggle.nodeName === 'LI' && nodeToToggle.closest('ol, ul');\n                    ublock && getListMode(ublock) == mode ? li.add(nodeToToggle) : blocks.add(nodeToToggle);\n                }\n            }\n        }\n\n        let target = [...(blocks.size ? blocks : li)];\n        while (target.length) {\n            const node = target.pop();\n            // only apply one li per ul\n            if (!node.oToggleList(0, mode)) {\n                target = target.filter(\n                    li => li.parentNode != node.parentNode || li.tagName != 'LI',\n                );\n            }\n        }\n    },\n\n    /**\n     * Apply a css or class color on the current selection (wrapped in <font>).\n     *\n     * @param {string} color hexadecimal or bg-name/text-name class\n     * @param {string} mode 'color' or 'backgroundColor'\n     * @param {Element} [element]\n     */\n    applyColor: (editor, color, mode, element) => {\n        const selectedTds = [...editor.editable.querySelectorAll('td.o_selected_td')].filter(\n            node => closestElement(node).isContentEditable\n        );\n        let coloredTds = [];\n        if (selectedTds.length && mode === \"backgroundColor\") {\n            for (const td of selectedTds) {\n                colorElement(td, color, mode);\n            }\n            coloredTds = [...selectedTds];\n        } else if (element) {\n            colorElement(element, color, mode);\n            return [element];\n        }\n        const selection = editor.document.getSelection();\n        let wasCollapsed = false;\n        if (selection.getRangeAt(0).collapsed && !selectedTds.length) {\n            insertAndSelectZws(selection);\n            wasCollapsed = true;\n        }\n        const range = getDeepRange(editor.editable, { splitText: true, select: true });\n        if (!range) return;\n        const restoreCursor = preserveCursor(editor.document);\n        // Get the <font> nodes to color\n        const selectionNodes = getSelectedNodes(editor.editable).filter(node => closestElement(node).isContentEditable);\n        if (isEmptyBlock(range.endContainer)) {\n            selectionNodes.push(range.endContainer, ...descendants(range.endContainer));\n        }\n        const selectedNodes = mode === \"backgroundColor\"\n            ? selectionNodes.filter(node => !closestElement(node, 'table.o_selected_table'))\n            : selectionNodes;\n        const selectedFieldNodes = new Set(getSelectedNodes(editor.editable)\n                .map(n => closestElement(n, \"*[t-field],*[t-out],*[t-esc]\"))\n                .filter(Boolean));\n\n        function getFonts(selectedNodes) {\n            return selectedNodes.flatMap(node => {\n                let font = closestElement(node, 'font') || closestElement(node, 'span');\n                const children = font && descendants(font);\n                if (font && (font.nodeName === 'FONT' || (font.nodeName === 'SPAN' && font.style[mode]))) {\n                    // Partially selected <font>: split it.\n                    const selectedChildren = children.filter(child => selectedNodes.includes(child));\n                    if (selectedChildren.length) {\n                        font = splitAroundUntil(selectedChildren, font);\n                    } else {\n                        font = [];\n                    }\n                } else if ((node.nodeType === Node.TEXT_NODE && !isWhitespace(node))\n                        || (node.nodeName === 'BR' && isEmptyBlock(node.parentNode))\n                        || (node.nodeType === Node.ELEMENT_NODE &&\n                            node.nodeName !== 'FIGURE' &&\n                            ['inline', 'inline-block'].includes(getComputedStyle(node).display) &&\n                            !isWhitespace(node.textContent) &&\n                            !node.classList.contains('btn') &&\n                            !node.querySelector('font'))) {\n                    // Node is a visible text or inline node without font nor a button:\n                    // wrap it in a <font>.\n                    const previous = node.previousSibling;\n                    const classRegex = mode === 'color' ? BG_CLASSES_REGEX : TEXT_CLASSES_REGEX;\n                    if (\n                        previous &&\n                        previous.nodeName === 'FONT' &&\n                        !previous.style[mode === 'color' ? 'backgroundColor' : 'color'] &&\n                        !classRegex.test(previous.className) &&\n                        selectedNodes.includes(previous.firstChild) &&\n                        selectedNodes.includes(previous.lastChild)\n                    ) {\n                        // Directly follows a fully selected <font> that isn't\n                        // colored in the other mode: append to that.\n                        font = previous;\n                    } else {\n                        // No <font> found: insert a new one.\n                        font = document.createElement('font');\n                        node.after(font);\n                    }\n                    if (node.textContent) {\n                        font.appendChild(node);\n                    } else {\n                        fillEmpty(font);\n                    }\n                } else {\n                    font = []; // Ignore non-text or invisible text nodes.\n                }\n                return font;\n            });\n        }\n\n        for (const fieldNode of selectedFieldNodes) {\n            colorElement(fieldNode, color, mode);\n        }\n\n        let fonts = getFonts(selectedNodes);\n        // Dirty fix as the previous call could have unconnected elements\n        // because of the `splitAroundUntil`. Another call should provide he\n        // correct list of fonts.\n        if (!fonts.every((font) => font.isConnected)) {\n            fonts = getFonts(selectedNodes);\n        }\n\n        // Color the selected <font>s and remove uncolored fonts.\n        const fontsSet = new Set(fonts);\n        for (const font of fontsSet) {\n            colorElement(font, color, mode);\n            if ((!hasColor(font, 'color') && !hasColor(font,'backgroundColor')) && (!font.hasAttribute('style') || !color)) {\n                for (const child of [...font.childNodes]) {\n                    font.parentNode.insertBefore(child, font);\n                }\n                font.parentNode.removeChild(font);\n                fontsSet.delete(font);\n            }\n        }\n        restoreCursor();\n        if (wasCollapsed) {\n            const newSelection = editor.document.getSelection();\n            const range = new Range();\n            range.setStart(newSelection.anchorNode, newSelection.anchorOffset);\n            range.collapse(true);\n            newSelection.removeAllRanges();\n            newSelection.addRange(range);\n        }\n        return [...fontsSet, ...coloredTds];\n    },\n    // Table\n    insertTable: (editor, { rowNumber = 2, colNumber = 2 } = {}) => {\n        const tdsHtml = new Array(colNumber).fill('<td><p><br></p></td>').join('');\n        const trsHtml = new Array(rowNumber).fill(`<tr>${tdsHtml}</tr>`).join('');\n        const tableHtml = `<table class=\"table table-bordered o_table\"><tbody>${trsHtml}</tbody></table>`;\n        const sel = editor.document.getSelection();\n        if (!sel.isCollapsed) {\n            editor.deleteRange(sel);\n        }\n        while (!isBlock(sel.anchorNode)) {\n            const anchorNode = sel.anchorNode;\n            const isTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n            const newAnchorNode = isTextNode\n                ? splitTextNode(anchorNode, sel.anchorOffset, DIRECTIONS.LEFT) + 1 && anchorNode\n                : splitElement(anchorNode, sel.anchorOffset).shift();\n            const newPosition = rightPos(newAnchorNode);\n            setSelection(...newPosition, ...newPosition, false);\n        }\n        const [table] = editorCommands.insert(editor, parseHTML(editor.document, tableHtml));\n        setCursorStart(table.querySelector('p'));\n    },\n    addColumn: (editor, beforeOrAfter, referenceCell) => {\n        if (!referenceCell) {\n            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding td.\n            referenceCell = getInSelection(editor.document, 'td');\n            if (!referenceCell) return;\n        }\n        const columnIndex = getColumnIndex(referenceCell);\n        const table = closestElement(referenceCell, 'table');\n        const tableWidth = table.style.width ? pxToFloat(table.style.width) : table.clientWidth;\n        const referenceColumn = table.querySelectorAll(`tr td:nth-of-type(${columnIndex + 1})`);\n        const referenceCellWidth = referenceCell.style.width ? pxToFloat(referenceCell.style.width) : referenceCell.clientWidth;\n        // Temporarily set widths so proportions are respected.\n        const firstRow = table.querySelector('tr');\n        const firstRowCells = [...firstRow.children].filter(child => child.nodeName === 'TD' || child.nodeName === 'TH');\n        let totalWidth = 0;\n        for (const cell of firstRowCells) {\n            const width = cell.style.width ? pxToFloat(cell.style.width) : cell.clientWidth;\n            cell.style.width = width + 'px';\n            // Spread the widths to preserve proportions.\n            // -1 for the width of the border of the new column.\n            const newWidth = Math.max(Math.round((width * tableWidth) / (tableWidth + referenceCellWidth - 1)), 13);\n            cell.style.width = newWidth + 'px';\n            totalWidth += newWidth;\n        }\n        referenceColumn.forEach((cell, rowIndex) => {\n            const newCell = document.createElement('td');\n            const p = document.createElement('p');\n            p.append(document.createElement('br'));\n            newCell.append(p);\n            cell[beforeOrAfter](newCell);\n            if (rowIndex === 0) {\n                newCell.style.width = cell.style.width;\n                totalWidth += pxToFloat(cell.style.width);\n            }\n        });\n        if (totalWidth !== tableWidth - 1) { // -1 for the width of the border of the new column.\n            firstRowCells[firstRowCells.length - 1].style.width = pxToFloat(firstRowCells[firstRowCells.length - 1].style.width) + (tableWidth - totalWidth - 1) + 'px';\n        }\n        // Fix the table and row's width so it doesn't change.\n        table.style.width = tableWidth + 'px';\n    },\n    addRow: (editor, beforeOrAfter, referenceRow) => {\n        if (!referenceRow) {\n            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding tr.\n            referenceRow = getInSelection(editor.document, 'tr');\n            if (!referenceRow) return;\n        }\n        const referenceRowHeight = referenceRow.style.height ? pxToFloat(referenceRow.style.height) : referenceRow.clientHeight;\n        const newRow = document.createElement('tr');\n        newRow.style.height = referenceRowHeight + 'px';\n        const cells = referenceRow.querySelectorAll('td');\n        newRow.append(...Array.from(Array(cells.length)).map(() => {\n            const td = document.createElement('td');\n            const p = document.createElement('p');\n            p.append(document.createElement('br'));\n            td.append(p);\n            return td;\n        }));\n        referenceRow[beforeOrAfter](newRow);\n        newRow.style.height = referenceRowHeight + 'px';\n        if (getRowIndex(newRow) === 0) {\n            let columnIndex = 0;\n            for (const newColumn of newRow.children) {\n                newColumn.style.width = cells[columnIndex].style.width;\n                cells[columnIndex].style.width = '';\n                columnIndex++;\n            }\n        }\n    },\n    removeColumn: (editor, cell) => {\n        if (!cell) {\n            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding td.\n            cell = getInSelection(editor.document, 'td');\n            if (!cell) return;\n        }\n        const table = closestElement(cell, 'table');\n        const cells = [...closestElement(cell, 'tr').querySelectorAll('th, td')];\n        const index = cells.findIndex(td => td === cell);\n        const siblingCell = cells[index - 1] || cells[index + 1];\n        table.querySelectorAll(`tr td:nth-of-type(${index + 1})`).forEach(td => td.remove());\n        siblingCell ? setSelection(...startPos(siblingCell)) : editorCommands.deleteTable(editor, table);\n    },\n    removeRow: (editor, row) => {\n        if (!row) {\n            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding tr.\n            row = getInSelection(editor.document, 'tr');\n            if (!row) return;\n        }\n        const table = closestElement(row, 'table');\n        const rows = [...table.querySelectorAll('tr')];\n        const rowIndex = rows.findIndex(tr => tr === row);\n        const siblingRow = rows[rowIndex - 1] || rows[rowIndex + 1];\n        row.remove();\n        siblingRow ? setSelection(...startPos(siblingRow)) : editorCommands.deleteTable(editor, table);\n    },\n    resetSize: (editor,table) => {\n        if (!table) {\n            getDeepRange(editor.editable, { select: true });\n            table = getInSelection(editor.document,'table');\n        }\n        table.removeAttribute('style');\n        const cells = [...table.querySelectorAll('tr, td')];\n        cells.forEach( cell => {\n            const cStyle = cell.style;\n            if (cell.tagName === 'TR') {\n                cStyle.height = '';\n            } else {\n                cStyle.width = '';\n            }\n        })\n    },\n    deleteTable: (editor, table) => {\n        table = table || getInSelection(editor.document, 'table');\n        if (!table) return;\n        const p = document.createElement('p');\n        p.appendChild(document.createElement('br'));\n        table.before(p);\n        table.remove();\n        setSelection(p, 0);\n    },\n    // Structure\n    columnize: (editor, numberOfColumns, addParagraphAfter=true) => {\n        const sel = editor.document.getSelection();\n        const anchor = sel.anchorNode;\n        const hasColumns = !!closestElement(anchor, '.o_text_columns');\n        if (!numberOfColumns && hasColumns) {\n            // Remove columns.\n            const restore = preserveCursor(editor.document);\n            const container = closestElement(anchor, '.o_text_columns');\n            const rows = unwrapContents(container);\n            for (const row of rows) {\n                const columns = unwrapContents(row);\n                for (const column of columns) {\n                    const columnContents = unwrapContents(column);\n                    for (const node of columnContents) {\n                        resetOuids(node);\n                    }\n                }\n            }\n            restore();\n        } else if (numberOfColumns && !hasColumns) {\n            // Create columns.\n            const restore = preserveCursor(editor.document);\n            const container = document.createElement('div');\n            if (!closestElement(anchor, '.container')) {\n                container.classList.add('container');\n            }\n            container.classList.add('o_text_columns');\n            const row = document.createElement('div');\n            row.classList.add('row');\n            container.append(row);\n            const block = closestBlock(anchor);\n            resetOuids(block);\n            const columnSize = Math.floor(12 / numberOfColumns);\n            const columns = [];\n            for (let i = 0; i < numberOfColumns; i++) {\n                const column = document.createElement('div');\n                column.classList.add(`col-${columnSize}`);\n                row.append(column);\n                columns.push(column);\n            }\n            block.before(container);\n            columns.shift().append(block);\n            for (const column of columns) {\n                const p = document.createElement('p');\n                p.append(document.createElement('br'));\n                p.classList.add('oe-hint');\n                p.setAttribute('placeholder', 'New column...');\n                column.append(p);\n            }\n            restore();\n            if (addParagraphAfter) {\n                const p = document.createElement('p');\n                p.append(document.createElement('br'));\n                container.after(p);\n            }\n        } else if (numberOfColumns && hasColumns) {\n            const row = closestElement(anchor, '.row');\n            const columns = [...row.children];\n            const columnSize = Math.floor(12 / numberOfColumns);\n            const diff = numberOfColumns - columns.length;\n            if (diff > 0) {\n                // Add extra columns.\n                const restore = preserveCursor(editor.document);\n                for (const column of columns) {\n                    column.className = column.className.replace(REGEX_BOOTSTRAP_COLUMN, `col$1-${columnSize}`);\n                }\n                let lastColumn = columns[columns.length - 1];\n                for (let i = 0; i < diff; i++) {\n                    const column = document.createElement('div');\n                    column.classList.add(`col-${columnSize}`);\n                    const p = document.createElement('p');\n                    p.append(document.createElement('br'));\n                    p.classList.add('oe-hint');\n                    p.setAttribute('placeholder', 'New column...');\n                    column.append(p);\n                    lastColumn.after(column);\n                    lastColumn = column;\n                }\n                restore();\n            } else if (diff < 0) {\n                // Remove superfluous columns.\n                const restore = preserveCursor(editor.document);\n                for (const column of columns) {\n                    column.className = column.className.replace(REGEX_BOOTSTRAP_COLUMN, `col$1-${columnSize}`);\n                }\n                const contents = [];\n                for (let i = diff; i < 0; i++) {\n                    const column = columns.pop();\n                    const columnContents = unwrapContents(column);\n                    for (const node of columnContents) {\n                        resetOuids(node);\n                    }\n                    contents.unshift(...columnContents);\n                }\n                columns[columns.length - 1].append(...contents);\n                restore();\n            }\n        }\n    },\n    insertHorizontalRule(editor) {\n        const selection = editor.document.getSelection();\n        const range = selection.getRangeAt(0);\n        const element = closestElement(\n            range.startContainer,\n            'P, PRE, H1, H2, H3, H4, H5, H6, BLOCKQUOTE',\n        );\n\n        if (element && ancestors(element).includes(editor.editable)) {\n            element.before(editor.document.createElement('hr'));\n        }\n    },\n};\n", "/** @odoo-module **/\nimport { UNBREAKABLE_ROLLBACK_CODE, UNREMOVABLE_ROLLBACK_CODE, REGEX_BOOTSTRAP_COLUMN } from '../utils/constants.js';\nimport {deleteText} from './deleteForward.js';\nimport {\n    boundariesOut,\n    childNodeIndex,\n    CTGROUPS,\n    CTYPES,\n    DIRECTIONS,\n    endPos,\n    fillEmpty,\n    getState,\n    isBlock,\n    isEmptyBlock,\n    isUnbreakable,\n    isUnremovable,\n    isVisible,\n    leftPos,\n    rightPos,\n    moveNodes,\n    nodeSize,\n    paragraphRelatedElements,\n    prepareUpdate,\n    setSelection,\n    isMediaElement,\n    isSelfClosingElement,\n    isNotEditableNode,\n    createDOMPathGenerator,\n    closestElement,\n    closestBlock,\n    getOffsetAndCharSize,\n} from '../utils/utils.js';\n\nText.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {\n    const parentElement = this.parentElement;\n\n    if (!offset) {\n        // Backspace at the beginning of a text node is not a specific case to\n        // handle, let the element implementation handle it.\n        parentElement.oDeleteBackward([...parentElement.childNodes].indexOf(this), alreadyMoved);\n        return;\n    }\n    // Get the size of the unicode character to remove.\n    // If the current offset split an emoji in the middle , we need to change offset to the end of the emoji\n    const [newOffset, charSize] = getOffsetAndCharSize(this.nodeValue, offset, DIRECTIONS.LEFT);\n    deleteText.call(this, charSize, newOffset - charSize, DIRECTIONS.LEFT, alreadyMoved);\n};\n\nconst isDeletable = (node) => {\n    return isMediaElement(node) || isNotEditableNode(node);\n}\n\nHTMLElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false, offsetLimit) {\n    const contentIsZWS = this.textContent === '\\u200B';\n    let moveDest;\n    if (offset) {\n        const leftNode = this.childNodes[offset - 1];\n        if (isUnremovable(leftNode)) {\n            throw UNREMOVABLE_ROLLBACK_CODE;\n        }\n        if (\n            isDeletable(leftNode)\n        ) {\n            leftNode.remove();\n            return;\n        }\n        if (!isBlock(leftNode) || isSelfClosingElement(leftNode)) {\n            /**\n             * Backspace just after an inline node, convert to backspace at the\n             * end of that inline node.\n             *\n             * E.g. <p>abc<i>def</i>[]</p> + BACKSPACE\n             * <=>  <p>abc<i>def[]</i></p> + BACKSPACE\n             */\n            leftNode.oDeleteBackward(nodeSize(leftNode), alreadyMoved);\n            return;\n        }\n\n        /**\n         * Backspace just after an block node, we have to move any inline\n         * content after it, up to the next block. If the cursor is between\n         * two blocks, this is a theoretical case: just do nothing.\n         *\n         * E.g. <p>abc</p>[]de<i>f</i><p>ghi</p> + BACKSPACE\n         * <=>  <p>abcde<i>f</i></p><p>ghi</p>\n         */\n        alreadyMoved = true;\n        moveDest = endPos(leftNode);\n    } else {\n        if (isUnremovable(this)) {\n            throw UNREMOVABLE_ROLLBACK_CODE;\n        }\n        // Empty unbreakable blocks should be removed with backspace, with the\n        // notable exception of Bootstrap columns.\n        if (isUnbreakable(this) && (REGEX_BOOTSTRAP_COLUMN.test(this.className) || !isEmptyBlock(this))) {\n            throw UNBREAKABLE_ROLLBACK_CODE;\n        }\n        const parentEl = this.parentElement;\n        // Handle editable sub-nodes\n        if (\n            parentEl &&\n            parentEl.getAttribute(\"contenteditable\") === \"true\" &&\n            parentEl.oid !== \"root\" &&\n            parentEl.parentElement &&\n            !parentEl.parentElement.isContentEditable &&\n            paragraphRelatedElements.includes(this.tagName) &&\n            !this.previousElementSibling\n        ) {\n            // The first child element of a contenteditable=\"true\" zone which\n            // itself is contained in a contenteditable=\"false\" zone can not be\n            // removed if it is paragraph-like.\n            throw UNREMOVABLE_ROLLBACK_CODE;\n        }\n        const closestLi = closestElement(this, 'li');\n        if ((closestLi && !closestLi.previousElementSibling) || !isBlock(this) || isSelfClosingElement(this)) {\n            /**\n             * Backspace at the beginning of an inline node, nothing has to be\n             * done: propagate the backspace. If the node was empty, we remove\n             * it before.\n             *\n             * E.g. <p>abc<b></b><i>[]def</i></p> + BACKSPACE\n             * <=>  <p>abc<b>[]</b><i>def</i></p> + BACKSPACE\n             * <=>  <p>abc[]<i>def</i></p> + BACKSPACE\n             */\n            const parentOffset = childNodeIndex(this);\n\n            if (!nodeSize(this) || contentIsZWS) {\n                const visible = isVisible(this);\n                const restore = prepareUpdate(...boundariesOut(this));\n                this.remove();\n                restore();\n\n                fillEmpty(parentEl);\n\n                if (visible) {\n                    // TODO this handle BR/IMG/etc removals../ to see if we\n                    // prefer to have a dedicated handler for every possible\n                    // HTML element or if we let this generic code handle it.\n                    setSelection(parentEl, parentOffset);\n                    return;\n                }\n            }\n            parentEl.oDeleteBackward(parentOffset, alreadyMoved);\n            return;\n        }\n\n        /** If we are at the beninning of a block node,\n         *  And the previous node is empty, remove it.\n         *\n         *   E.g. (previousEl == empty)\n         *        <p><br></p><h1>[]def</h1> + BACKSPACE\n         *   <=>  <h1>[]def</h1>\n         *\n         *   E.g. (previousEl != empty)\n         *        <h3>abc</h3><h1>[]def</h1> + BACKSPACE\n         *   <=>  <h3>abc[]def</h3>\n        */\n        const previousElementSiblingClosestBlock = closestBlock(this.previousElementSibling);\n        if (\n            previousElementSiblingClosestBlock &&\n            (isEmptyBlock(previousElementSiblingClosestBlock) ||\n                previousElementSiblingClosestBlock.textContent === '\\u200B') &&\n            paragraphRelatedElements.includes(this.nodeName)\n        ) {\n            previousElementSiblingClosestBlock.remove();\n            setSelection(this, 0);\n            return;\n        }\n\n        /**\n         * Backspace at the beginning of a block node. If it doesn't have a left\n         * block and it is one of the special block formatting tags below then\n         * convert the block into a P and return immediately. Otherwise, we have\n         * to move the inline content at its beginning outside of the element\n         * and propagate to the left block.\n         *\n         * E.g. (prev == block)\n         *      <p>abc</p><div>[]def<p>ghi</p></div> + BACKSPACE\n         * <=>  <p>abc</p>[]def<div><p>ghi</p></div> + BACKSPACE\n         *\n         * E.g. (prev != block)\n         *      abc<div>[]def<p>ghi</p></div> + BACKSPACE\n         * <=>  abc[]def<div><p>ghi</p></div>\n         */\n        if (\n            !this.previousElementSibling &&\n            ['BLOCKQUOTE', 'H1', 'H2', 'H3', 'PRE'].includes(this.nodeName) &&\n            !closestLi\n        ) {\n            const p = document.createElement('p');\n            p.replaceChildren(...this.childNodes);\n            this.replaceWith(p);\n            setSelection(p, offset);\n            return;\n        } else {\n            moveDest = leftPos(this);\n        }\n    }\n\n    const domPathGenerator = createDOMPathGenerator(DIRECTIONS.LEFT, {\n        leafOnly: true,\n        stopTraverseFunction: isDeletable,\n    });\n    const domPath = domPathGenerator(this, offset)\n    const leftNode = domPath.next().value;\n    if (leftNode && isDeletable(leftNode)) {\n        const [parent, offset] = rightPos(leftNode);\n        return parent.oDeleteBackward(offset, alreadyMoved);\n    }\n    let node = this.childNodes[offset];\n    const nextSibling = this.nextSibling;\n    let currentNodeIndex = offset;\n\n    // `offsetLimit` will ensure we never move nodes that were not initialy in\n    // the element => when Deleting and merging an element the containing node\n    // will temporarily be hosted in the common parent beside possible other\n    // nodes. We don't want to touch those other nodes when merging two html\n    // elements ex : <div>12<p>ab[]</p><p>cd</p>34</div> should never touch the\n    // 12 and 34 text node.\n    if (offsetLimit === undefined) {\n        while (node && !isBlock(node)) {\n            node = node.nextSibling;\n            currentNodeIndex++;\n        }\n    } else {\n        currentNodeIndex = offsetLimit;\n    }\n    let [cursorNode, cursorOffset] = moveNodes(...moveDest, this, offset, currentNodeIndex);\n    setSelection(cursorNode, cursorOffset);\n\n    // Propagate if this is still a block on the left of where the nodes were\n    // moved.\n    if (\n        cursorNode.nodeType === Node.TEXT_NODE &&\n        (cursorOffset === 0 || cursorOffset === cursorNode.length)\n    ) {\n        cursorOffset = childNodeIndex(cursorNode) + (cursorOffset === 0 ? 0 : 1);\n        cursorNode = cursorNode.parentNode;\n    }\n    if (cursorNode.nodeType !== Node.TEXT_NODE) {\n        const { cType } = getState(cursorNode, cursorOffset, DIRECTIONS.LEFT);\n        if (cType & CTGROUPS.BLOCK && (!alreadyMoved || cType === CTYPES.BLOCK_OUTSIDE)) {\n            cursorNode.oDeleteBackward(cursorOffset, alreadyMoved, cursorOffset + currentNodeIndex - offset);\n        } else if (!alreadyMoved) {\n            // When removing a block node adjacent to an inline node, we need to\n            // ensure the block node induced line break are kept with a <br>.\n            // ex : <div>a<span>b</span><p>[]c</p>d</div> => deleteBakward =>\n            // <div>a<span>b</span>[]c<br>d</div> In this case we cannot simply\n            // merge the <p> content into the div parent, or we would lose the\n            // line break located after the <p>.\n            const cursorNodeNode = cursorNode.childNodes[cursorOffset];\n            const cursorNodeRightNode = cursorNodeNode ? cursorNodeNode.nextSibling : undefined;\n            if (cursorNodeRightNode &&\n                cursorNodeRightNode.nodeType === Node.TEXT_NODE &&\n                nextSibling === cursorNodeRightNode) {\n                moveDest[0].insertBefore(document.createElement('br'), cursorNodeRightNode);\n            }\n        }\n    }\n};\n\nHTMLLIElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {\n    // If the deleteBackward is performed at the begening of a LI element,\n    // we take the current LI out of the list.\n    if (offset === 0) {\n        this.oToggleList(offset);\n        return;\n    }\n    // Otherwise, call the HTMLElement deleteBackward method.\n    HTMLElement.prototype.oDeleteBackward.call(this, offset, alreadyMoved);\n};\n\nHTMLBRElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {\n    const parentOffset = childNodeIndex(this);\n    const rightState = getState(this.parentElement, parentOffset + 1, DIRECTIONS.RIGHT).cType;\n    if (rightState & CTYPES.BLOCK_INSIDE) {\n        this.parentElement.oDeleteBackward(parentOffset, alreadyMoved);\n    } else {\n        HTMLElement.prototype.oDeleteBackward.call(this, offset, alreadyMoved);\n    }\n};\n\nHTMLTableCellElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {\n    if (offset) {\n        HTMLElement.prototype.oDeleteBackward.call(this, offset, alreadyMoved);\n    }\n};\n", "/** @odoo-module **/\nimport { UNREMOVABLE_ROLLBACK_CODE } from '../utils/constants.js';\nimport {\n    findNode,\n    isSelfClosingElement,\n    nodeSize,\n    rightPos,\n    getState,\n    DIRECTIONS,\n    CTYPES,\n    leftPos,\n    isFontAwesome,\n    rightLeafOnlyNotBlockNotEditablePath,\n    rightLeafOnlyPathNotBlockNotEditablePath,\n    isNotEditableNode,\n    splitTextNode,\n    paragraphRelatedElements,\n    prepareUpdate,\n    isInPre,\n    fillEmpty,\n    setSelection,\n    isZWS,\n    childNodeIndex,\n    boundariesOut,\n    isEditorTab,\n    isVisible,\n    isUnbreakable,\n    isEmptyBlock,\n    isWhitespace,\n    isVisibleTextNode,\n    getOffsetAndCharSize,\n} from '../utils/utils.js';\n\n/**\n * Handle text node deletion for Text.oDeleteForward and Text.oDeleteBackward.\n *\n * @param {int} charSize\n * @param {int} offset\n * @param {DIRECTIONS} direction\n * @param {boolean} alreadyMoved\n */\nexport function deleteText(charSize, offset, direction, alreadyMoved) {\n    const parentElement = this.parentElement;\n    // Split around the character where the deletion occurs.\n    const firstSplitOffset = splitTextNode(this, offset);\n    const secondSplitOffset = splitTextNode(parentElement.childNodes[firstSplitOffset], charSize);\n    const middleNode = parentElement.childNodes[firstSplitOffset];\n\n    // Do remove the character, then restore the state of the surrounding parts.\n    const restore = prepareUpdate(parentElement, firstSplitOffset, parentElement, secondSplitOffset);\n    const isSpace = isWhitespace(middleNode) && !isInPre(middleNode);\n    const isZWS = middleNode.nodeValue === '\\u200B';\n    middleNode.remove();\n    restore();\n\n    // If the removed element was not visible content, propagate the deletion.\n    const parentState = getState(parentElement, firstSplitOffset, direction);\n    if (\n        isZWS ||\n        (isSpace &&\n            (parentState.cType !== CTYPES.CONTENT || parentState.node === undefined))\n    ) {\n        if (direction === DIRECTIONS.LEFT) {\n            parentElement.oDeleteBackward(firstSplitOffset, alreadyMoved);\n        } else {\n            if (isSpace && parentState.node == undefined) {\n                // multiple invisible space at the start of the node\n                this.oDeleteForward(offset, alreadyMoved);\n            } else {\n                parentElement.oDeleteForward(firstSplitOffset, alreadyMoved);\n            }\n        }\n        if (isZWS) {\n            fillEmpty(parentElement);\n        }\n        return;\n    }\n    fillEmpty(parentElement);\n    setSelection(parentElement, firstSplitOffset);\n}\n\nText.prototype.oDeleteForward = function (offset, alreadyMoved = false) {\n    const parentElement = this.parentElement;\n\n    if (offset === this.nodeValue.length) {\n        // Delete at the end of a text node is not a specific case to handle,\n        // let the element implementation handle it.\n        parentElement.oDeleteForward([...parentElement.childNodes].indexOf(this) + 1);\n        return;\n    }\n    // Get the size of the unicode character to remove.\n    const [newOffset, charSize] = getOffsetAndCharSize(this.nodeValue, offset + 1, DIRECTIONS.RIGHT);\n    deleteText.call(this, charSize, newOffset, DIRECTIONS.RIGHT, alreadyMoved);\n};\n\nHTMLElement.prototype.oDeleteForward = function (offset) {\n    const filterFunc = node =>\n        isSelfClosingElement(node) || isVisibleTextNode(node) || isNotEditableNode(node);\n\n    const firstLeafNode = findNode(rightLeafOnlyNotBlockNotEditablePath(this, offset), filterFunc);\n    if (firstLeafNode &&\n        isZWS(firstLeafNode) &&\n        this.parentElement.hasAttribute('data-oe-zws-empty-inline')\n    ) {\n        const grandparent = this.parentElement.parentElement;\n        if (!grandparent) {\n            return;\n        }\n\n        const parentIndex = childNodeIndex(this.parentElement);\n        const restore = prepareUpdate(...boundariesOut(this.parentElement));\n        this.parentElement.remove();\n        restore();\n        HTMLElement.prototype.oDeleteForward.call(grandparent, parentIndex);\n        return;\n    }\n    if (\n        this.hasAttribute &&\n        this.hasAttribute('data-oe-zws-empty-inline') &&\n        (\n            isZWS(this) ||\n            (this.textContent === '' && this.childNodes.length === 0)\n        )\n    ) {\n        const parent = this.parentElement;\n        if (!parent) {\n            return;\n        }\n\n        const index = childNodeIndex(this);\n        const restore = prepareUpdate(...boundariesOut(this));\n        this.remove();\n        restore();\n        HTMLElement.prototype.oDeleteForward.call(parent, index);\n        return;\n    }\n\n    if (firstLeafNode && (isFontAwesome(firstLeafNode) || isNotEditableNode(firstLeafNode))) {\n        const nextSibling = firstLeafNode.nextSibling;\n        const nextSiblingText = nextSibling ? nextSibling.textContent : '';\n        firstLeafNode.remove();\n        if (isEditorTab(firstLeafNode) && nextSiblingText[0] === '\\u200B') {\n            // When deleting an editor tab, we need to ensure it's related ZWS\n            // il deleted as well.\n            nextSibling.textContent = nextSiblingText.replace('\\u200B', '');\n        }\n        return;\n    }\n    if (\n        firstLeafNode &&\n        (firstLeafNode.nodeName !== 'BR' ||\n            getState(...rightPos(firstLeafNode), DIRECTIONS.RIGHT).cType !== CTYPES.BLOCK_INSIDE)\n    ) {\n        firstLeafNode.oDeleteBackward(Math.min(1, nodeSize(firstLeafNode)));\n        return;\n    }\n\n    const nextSibling = this.nextSibling;\n    if (\n        (\n            offset === this.childNodes.length ||\n            (this.childNodes.length === 1 && this.childNodes[0].tagName === 'BR')\n        ) &&\n        this.parentElement &&\n        nextSibling &&\n        ['LI', 'UL', 'OL'].includes(nextSibling.tagName)\n    ) {\n        const nextSiblingNestedLi = nextSibling.querySelector('li:first-child');\n        if (nextSiblingNestedLi) {\n            // Add the first LI from the next sibbling list to the current list.\n            this.after(nextSiblingNestedLi);\n            // Remove the next sibbling list if it's empty.\n            if (!isVisible(nextSibling, false) || nextSibling.textContent === '') {\n                nextSibling.remove();\n            }\n            HTMLElement.prototype.oDeleteBackward.call(nextSiblingNestedLi, 0, true);\n        } else {\n            HTMLElement.prototype.oDeleteBackward.call(nextSibling, 0);\n        }\n        return;\n    }\n\n    // Remove the nextSibling if it is a non-editable element.\n    if (\n        nextSibling &&\n        nextSibling.nodeType === Node.ELEMENT_NODE &&\n        !nextSibling.isContentEditable\n    ) {\n        nextSibling.remove();\n        return;\n    }\n    const parentEl = this.parentElement;\n    // Prevent the deleteForward operation since it is done at the end of an\n    // enclosed editable zone (inside a non-editable zone in the editor).\n    if (\n        parentEl &&\n        parentEl.getAttribute(\"contenteditable\") === \"true\" &&\n        parentEl.oid !== \"root\" &&\n        parentEl.parentElement &&\n        !parentEl.parentElement.isContentEditable &&\n        paragraphRelatedElements.includes(this.tagName) &&\n        !this.nextElementSibling\n    ) {\n        throw UNREMOVABLE_ROLLBACK_CODE;\n    }\n    const firstOutNode = findNode(\n        rightLeafOnlyPathNotBlockNotEditablePath(\n            ...(firstLeafNode ? rightPos(firstLeafNode) : [this, offset]),\n        ),\n        filterFunc,\n    );\n    if (firstOutNode) {\n        // If next sibblings is an unbreadable node, and current node is empty, we\n        // delete the current node and put the selection at the beginning of the\n        // next sibbling.\n        if (nextSibling && isUnbreakable(nextSibling) && isEmptyBlock(this)) {\n            const restore = prepareUpdate(...boundariesOut(this));\n            this.remove();\n            restore();\n            setSelection(firstOutNode, 0);\n            return;\n        }\n        const [node, offset] = leftPos(firstOutNode);\n        // If the next node is a <LI> we call directly the htmlElement\n        // oDeleteBackward : because we don't want the special cases of\n        // deleteBackward for LI when we comme from a deleteForward.\n        if (node.tagName === 'LI') {\n            HTMLElement.prototype.oDeleteBackward.call(node, offset);\n            return;\n        }\n        node.oDeleteBackward(offset);\n        return;\n    }\n};\n", "/** @odoo-module **/\nimport { UNBREAKABLE_ROLLBACK_CODE } from '../utils/constants.js';\n\nimport {\n    childNodeIndex,\n    fillEmpty,\n    isBlock,\n    isUnbreakable,\n    prepareUpdate,\n    setCursorStart,\n    setCursorEnd,\n    setTagName,\n    splitTextNode,\n    toggleClass,\n    isVisible,\n    descendants,\n    isVisibleTextNode,\n} from '../utils/utils.js';\n\nText.prototype.oEnter = function (offset) {\n    this.parentElement.oEnter(splitTextNode(this, offset), true);\n};\n/**\n * The whole logic can pretty much be described by this example:\n *\n *     <p><span><b>[]xt</b>ab</span>cd</p> + ENTER\n * <=> <p><span><b><br></b>[]<b>xt</b>ab</span>cd</p> + ENTER\n * <=> <p><span><b><br></b></span>[]<span><b>xt</b>ab</span>cd</p> + ENTER\n * <=> <p><span><b><br></b></span></p><p><span><b>[]xt</b>ab</span>cd</p> + SANITIZE\n * <=> <p><br></p><p><span><b>[]xt</b>ab</span>cd</p>\n *\n * Propagate the split for as long as we split an inline node, then refocus the\n * beginning of the first split node\n */\nHTMLElement.prototype.oEnter = function (offset, firstSplit = true) {\n    let didSplit = false;\n    if (isUnbreakable(this)) {\n        throw UNBREAKABLE_ROLLBACK_CODE;\n    }\n    let restore;\n    if (firstSplit) {\n        restore = prepareUpdate(this, offset);\n    }\n\n    // First split the node in two and move half the children in the clone.\n    let splitEl = this.cloneNode(false);\n    while (offset < this.childNodes.length) {\n        splitEl.appendChild(this.childNodes[offset]);\n    }\n    if (isBlock(this) || splitEl.hasChildNodes()) {\n        this.after(splitEl);\n        if (isBlock(splitEl) || isVisible(splitEl) || splitEl.textContent === '\\u200B') {\n            didSplit = true;\n        } else {\n            splitEl.remove();\n        }\n    }\n\n    // Propagate the split until reaching a block element (or continue to the\n    // closest list item element if there is one).\n    if (!isBlock(this) || (this.nodeName !== 'LI' && this.closest('LI'))) {\n        if (this.parentElement) {\n            this.parentElement.oEnter(childNodeIndex(this) + 1, !didSplit);\n        } else {\n            // There was no block parent element in the original chain, consider\n            // this unsplittable, like an unbreakable.\n            throw UNBREAKABLE_ROLLBACK_CODE;\n        }\n    }\n\n    // All split have been done, place the cursor at the right position, and\n    // fill/remove empty nodes.\n    if (firstSplit && didSplit) {\n        restore();\n\n        let node = this;\n        while (!isBlock(node) && !isVisible(node)) {\n            const toRemove = node;\n            node = node.parentNode;\n            toRemove.remove();\n        }\n        fillEmpty(node);\n        fillEmpty(splitEl);\n        if (splitEl.tagName === 'A') {\n            while (!isBlock(splitEl) && !isVisible(splitEl)) {\n                const toRemove = splitEl;\n                splitEl = splitEl.parentNode;\n                toRemove.remove();\n            }\n        }\n        setCursorStart(splitEl);\n    }\n    return splitEl;\n};\n/**\n * Specific behavior for headings: do not split in two if cursor at the end but\n * instead create a paragraph.\n * Cursor end of line: <h1>title[]</h1> + ENTER <=> <h1>title</h1><p>[]<br/></p>\n * Cursor in the line: <h1>tit[]le</h1> + ENTER <=> <h1>tit</h1><h1>[]le</h1>\n */\nHTMLHeadingElement.prototype.oEnter = function () {\n    const newEl = HTMLElement.prototype.oEnter.call(this, ...arguments);\n    if (!descendants(newEl).some(isVisibleTextNode)) {\n        const node = setTagName(newEl, 'P');\n        node.replaceChildren(document.createElement('br'));\n        setCursorStart(node);\n    }\n};\n/**\n * Same specific behavior as headings elements.\n */\nHTMLQuoteElement.prototype.oEnter = HTMLHeadingElement.prototype.oEnter;\n/**\n * Specific behavior for list items: deletion and unindentation when empty.\n */\nHTMLLIElement.prototype.oEnter = function () {\n    // If not empty list item, regular block split\n    if (this.textContent) {\n        const node = HTMLElement.prototype.oEnter.call(this, ...arguments);\n        if (node.classList.contains('o_checked')) {\n            toggleClass(node, 'o_checked');\n        }\n        return node;\n    }\n    this.oShiftTab();\n};\n/**\n * Specific behavior for pre: insert newline (\\n) in text or insert p at end.\n */\nHTMLPreElement.prototype.oEnter = function (offset) {\n    if (offset < this.childNodes.length) {\n        const lineBreak = document.createElement('br');\n        this.insertBefore(lineBreak, this.childNodes[offset]);\n        setCursorEnd(lineBreak);\n    } else {\n        const node = document.createElement('p');\n        this.parentNode.insertBefore(node, this.nextSibling);\n        fillEmpty(node);\n        setCursorStart(node);\n    }\n};\n", "/** @odoo-module **/\nimport {\n    CTYPES,\n    DIRECTIONS,\n    isFakeLineBreak,\n    prepareUpdate,\n    rightPos,\n    setSelection,\n    getState,\n    leftPos,\n    splitTextNode,\n} from '../utils/utils.js';\n\nText.prototype.oShiftEnter = function (offset) {\n    return this.parentElement.oShiftEnter(splitTextNode(this, offset));\n};\n\nHTMLElement.prototype.oShiftEnter = function (offset) {\n    const restore = prepareUpdate(this, offset);\n\n    const brEl = document.createElement('br');\n    const brEls = [brEl];\n    if (offset >= this.childNodes.length) {\n        this.appendChild(brEl);\n    } else {\n        this.insertBefore(brEl, this.childNodes[offset]);\n    }\n    if (isFakeLineBreak(brEl) && getState(...leftPos(brEl), DIRECTIONS.LEFT).cType !== CTYPES.BR) {\n        const brEl2 = document.createElement('br');\n        brEl.before(brEl2);\n        brEls.unshift(brEl2);\n    }\n\n    restore();\n\n    for (const el of brEls) {\n        if (el.parentNode) {\n            setSelection(...rightPos(el));\n            break;\n        }\n    }\n\n    return brEls;\n};\n", "/** @odoo-module **/\nimport { isUnbreakable, preserveCursor, toggleClass, isBlock, isVisible } from '../utils/utils.js';\n\nText.prototype.oShiftTab = function () {\n    return this.parentElement.oShiftTab(0);\n};\n\nHTMLElement.prototype.oShiftTab = function (offset = undefined) {\n    if (!isUnbreakable(this)) {\n        return this.parentElement.oShiftTab(offset);\n    }\n    return false;\n};\n\n// returns: is still in a <LI> nested list\nHTMLLIElement.prototype.oShiftTab = function () {\n    const li = this;\n    if (li.nextElementSibling) {\n        const ul = li.parentElement.cloneNode(false);\n        while (li.nextSibling) {\n            ul.append(li.nextSibling);\n        }\n        if (li.parentNode.parentNode.tagName === 'LI') {\n            const lip = document.createElement('li');\n            toggleClass(lip, 'oe-nested');\n            lip.append(ul);\n            li.parentNode.parentNode.after(lip);\n        } else {\n            li.parentNode.after(ul);\n        }\n    }\n\n    const restoreCursor = preserveCursor(this.ownerDocument);\n    if (\n        li.parentNode.parentNode.tagName === 'LI' &&\n        !li.parentNode.parentNode.classList.contains('nav-item')\n    ) {\n        const ul = li.parentNode;\n        const shouldRemoveParentLi = !li.previousElementSibling && !ul.previousElementSibling;\n        const toremove = shouldRemoveParentLi ? ul.parentNode : null;\n        ul.parentNode.after(li);\n        if (toremove) {\n            if (toremove.classList.contains('oe-nested')) {\n                // <li>content<ul>...</ul></li>\n                toremove.remove();\n            } else {\n                // <li class=\"oe-nested\"><ul>...</ul></li>\n                ul.remove();\n            }\n        }\n        restoreCursor();\n        return li;\n    } else {\n        const ul = li.parentNode;\n        const dir = ul.getAttribute('dir');\n        let p;\n        while (li.firstChild) {\n            if (isBlock(li.firstChild)) {\n                if (p && isVisible(p)) {\n                    ul.after(p);\n                }\n                p = undefined;\n                ul.after(li.firstChild);\n            } else {\n                p = p || document.createElement('P');\n                if (dir) {\n                    p.setAttribute('dir', dir);\n                    p.style.setProperty('text-align', ul.style.getPropertyValue('text-align'));\n                }\n                p.append(li.firstChild);\n            }\n        }\n        if (p && isVisible(p)) {\n            ul.after(p)\n        }\n\n        restoreCursor(new Map([[li, ul.nextSibling]]));\n        li.remove();\n        if (!ul.firstElementChild) {\n            ul.remove();\n        }\n    }\n    return false;\n};\n", "/** @odoo-module **/\nimport { createList, getListMode, isBlock, preserveCursor, toggleClass } from '../utils/utils.js';\n\nText.prototype.oTab = function () {\n    return this.parentElement.oTab(0);\n};\n\nHTMLElement.prototype.oTab = function (offset) {\n    if (!isBlock(this)) {\n        return this.parentElement.oTab(offset);\n    }\n    return false;\n};\n\nHTMLLIElement.prototype.oTab = function () {\n    const lip = document.createElement('li');\n    const destul =\n        (this.previousElementSibling && this.previousElementSibling.querySelector('ol, ul')) ||\n        (this.nextElementSibling && this.nextElementSibling.querySelector('ol, ul')) ||\n        this.closest('ul, ol');\n\n    const ul = createList(getListMode(destul));\n    lip.append(ul);\n\n    const cr = preserveCursor(this.ownerDocument);\n    toggleClass(lip, 'oe-nested');\n    this.before(lip);\n    ul.append(this);\n    cr();\n    return true;\n};\n", "/** @odoo-module **/\nimport {\n    childNodeIndex,\n    getListMode,\n    isBlock,\n    preserveCursor,\n    setTagName,\n    toggleClass,\n    insertListAfter,\n    getAdjacents,\n    closestElement,\n} from '../utils/utils.js';\n\nText.prototype.oToggleList = function (offset, mode) {\n    // Create a new list if textNode is inside a nav-item list\n    if (closestElement(this, 'li').classList.contains('nav-item')) {\n        const restoreCursor = preserveCursor(this.ownerDocument);\n        insertListAfter(this, mode, [this]);\n        restoreCursor();\n    } else {\n        this.parentElement.oToggleList(childNodeIndex(this), mode);\n    }\n};\n\nHTMLElement.prototype.oToggleList = function (offset, mode = 'UL') {\n    if (!isBlock(this)) {\n        return this.parentElement.oToggleList(childNodeIndex(this));\n    }\n    const closestLi = this.closest('li');\n    // Do not toggle nav-item list as they don't behave like regular list items\n    if (closestLi && !closestLi.classList.contains('nav-item')) {\n        return closestLi.oToggleList(0, mode);\n    }\n    const restoreCursor = preserveCursor(this.ownerDocument);\n    if (this.oid === 'root') {\n        const callingNode = this.childNodes[offset];\n        const group = getAdjacents(callingNode, n => !isBlock(n));\n        insertListAfter(callingNode, mode, [group]);\n        restoreCursor();\n    } else {\n        const list = insertListAfter(this, mode, [this]);\n        if (this.hasAttribute('dir')) {\n            list.setAttribute('dir', this.getAttribute('dir'));\n        }\n        restoreCursor(new Map([[this, list.firstElementChild]]));\n    }\n};\n\nHTMLParagraphElement.prototype.oToggleList = function (offset, mode = 'UL') {\n    const restoreCursor = preserveCursor(this.ownerDocument);\n    const list = insertListAfter(this, mode, [[...this.childNodes]]);\n    const classList = [...list.classList];\n    for (const attribute of this.attributes) {\n        if (attribute.name === 'class' && attribute.value && list.className) {\n            list.className = `${list.className} ${attribute.value}`;\n        } else {\n            list.setAttribute(attribute.name, attribute.value);\n        }\n    }\n    for (const className of classList) {\n        list.classList.toggle(className, true); // restore list classes\n    }\n    this.remove();\n\n    restoreCursor(new Map([[this, list.firstChild]]));\n    return true;\n};\n\nHTMLLIElement.prototype.oToggleList = function (offset, mode) {\n    const pnode = this.closest('ul, ol');\n    if (!pnode) return;\n    const restoreCursor = preserveCursor(this.ownerDocument);\n    const listMode = getListMode(pnode) + mode;\n    if (['OLCL', 'ULCL'].includes(listMode)) {\n        pnode.classList.add('o_checklist');\n        for (let li = pnode.firstElementChild; li !== null; li = li.nextElementSibling) {\n            if (li.style.listStyle != 'none') {\n                li.style.listStyle = null;\n                if (!li.style.all) li.removeAttribute('style');\n            }\n        }\n        setTagName(pnode, 'UL');\n    } else if (['CLOL', 'CLUL'].includes(listMode)) {\n        toggleClass(pnode, 'o_checklist');\n        setTagName(pnode, mode);\n    } else if (['OLUL', 'ULOL'].includes(listMode)) {\n        setTagName(pnode, mode);\n    } else {\n        // toggle => remove list\n        let node = this;\n        while (node) {\n            node = node.oShiftTab(offset);\n        }\n    }\n\n    restoreCursor();\n    return false;\n};\n\nHTMLTableCellElement.prototype.oToggleList = function (offset, mode) {\n    const restoreCursor = preserveCursor(this.ownerDocument);\n    const callingNode = this.childNodes[offset];\n    const group = getAdjacents(callingNode, n => !isBlock(n));\n    insertListAfter(callingNode, mode, [group]);\n    restoreCursor();\n};\n", "/** @odoo-module **/\nimport { patienceDiff } from './patienceDiff.js';\nimport { closestBlock, getRangePosition } from '../utils/utils.js';\n\nconst REGEX_RESERVED_CHARS = /[\\\\^$.*+?()[\\]{}|]/g;\n/**\n * Make `num` cycle from 0 to `max`.\n */\nfunction cycle(num, max) {\n    const y = max + 1;\n    return ((num % y) + y) % y;\n}\n\n/**\n * interface PowerboxCommand {\n *     category: string;\n *     name: string;\n *     priority: number;\n *     description: string;\n *     fontawesome: string; // a fontawesome class name\n *     callback: () => void; // to execute when the command is picked\n *     isDisabled?: () => boolean; // return true to disable the command\n * }\n */\n\nexport class Powerbox {\n    constructor({\n        categories, commands, commandFilters, editable, getContextFromParentRect,\n        onShow, onStop, beforeCommand, afterCommand\n    } = {}) {\n        this.categories = categories;\n        this.commands = commands;\n        this.commandFilters = commandFilters || [];\n        this.editable = editable;\n        this.getContextFromParentRect = getContextFromParentRect;\n        this.onShow = onShow;\n        this.onStop = onStop;\n        this.beforeCommand = beforeCommand;\n        this.afterCommand = afterCommand;\n        this.isOpen = false;\n        this.document = editable.ownerDocument;\n\n        // Draw the powerbox.\n        this.el = document.createElement('div');\n        this.el.className = 'oe-powerbox-wrapper position-absolute overflow-hidden';\n        this.el.style.display = 'none';\n        document.body.append(this.el);\n        this._mainWrapperElement = document.createElement('div');\n        this._mainWrapperElement.className = 'oe-powerbox-mainWrapper flex-skrink-1 overflow-auto py-2';\n        this.el.append(this._mainWrapperElement);\n        this.el.addEventListener('mousedown', ev => ev.stopPropagation());\n\n        // Set up events for later binding.\n        this._boundOnKeyup = this._onKeyup.bind(this);\n        this._boundOnKeydown = this._onKeydown.bind(this);\n        this._boundClose = this.close.bind(this);\n        this._events = [\n            [this.document, 'keyup', this._boundOnKeyup],\n            [this.document, 'keydown', this._boundOnKeydown, true],\n            [this.document, 'mousedown', this._boundClose],\n        ]\n        // If the global document is different from the provided\n        // options.document, which happens when the editor is inside an iframe,\n        // we need to listen to the mouse event on both documents to be sure the\n        // Powerbox will always close when clicking outside of it.\n        if (document !== this.document) {\n            this._events.push(\n                [document, 'mousedown', this._boundClose],\n            );\n        }\n\n    }\n    destroy() {\n        if (this.isOpen) {\n            this.close();\n        }\n        this.el.remove();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public\n    // -------------------------------------------------------------------------\n\n    /**\n     * Open the Powerbox with the given commands or with all instance commands.\n     *\n     * @param {PowerboxCommand[]} [commands=this.commands]\n     * @param {Array<{name: string, priority: number}} [categories=this.categories]\n     */\n    open(commands=this.commands, categories=this.categories) {\n        commands = (commands || []).map(command => ({\n            ...command,\n            category: command.category || '',\n            name: command.name || '',\n            priority: command.priority || 0,\n            description: command.description || '',\n            callback: command.callback || (() => {}),\n        }));\n        categories = (categories || []).map(category => ({\n            name: category.name || '',\n            priority: category.priority || 0,\n        }));\n        const order = (a, b) => b.priority - a.priority || a.name.localeCompare(b.name);\n        // Remove duplicate category names, keeping only last declared version,\n        // and order them.\n        categories = [...categories].reverse().filter((category, index, cats) => (\n            cats.findIndex(cat => cat.name === category.name) === index\n        )).sort(order);\n\n        // Apply optional filters to disable commands, then order them.\n        for (let filter of this.commandFilters) {\n            commands = filter(commands);\n        }\n        commands = commands.filter(command => !command.isDisabled || !command.isDisabled()).sort(order);\n        commands = this._groupCommands(commands, categories).flatMap(group => group[1]);\n\n        const selection = this.document.getSelection();\n        const currentBlock = (selection && closestBlock(selection.anchorNode)) || this.editable;\n        this._context = {\n            commands, categories, filteredCommands: commands, selectedCommand: undefined,\n            initialTarget: currentBlock, initialValue: currentBlock.textContent,\n            lastText: undefined,\n        }\n        this.isOpen = true;\n        this._render(this._context.commands, this._context.categories);\n        this._bindEvents();\n        this.show();\n    }\n    /**\n     * Close the Powerbox without destroying it. Unbind events, reset context\n     * and call the optional `onStop` hook.\n     */\n    close() {\n        this.isOpen = false;\n        this.hide();\n        this._context = undefined;\n        this._unbindEvents();\n        this.onStop && this.onStop();\n    };\n    /**\n     * Show the Powerbox and position it. Call the optional `onShow` hook.\n     */\n    show() {\n        this.onShow && this.onShow();\n        this.el.style.display = 'flex';\n        this._resetPosition();\n    }\n    /**\n     * Hide the Powerbox. If the Powerbox is active, close it.\n     *\n     * @see close\n     */\n    hide() {\n        this.el.style.display = 'none';\n        if (this.isOpen) {\n            this.close();\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Private\n    // -------------------------------------------------------------------------\n\n    /**\n     * Render the Powerbox with the given commands, grouped by `category`.\n     *\n     * @private\n     * @param {PowerboxCommand[]} commands\n     * @param {Array<{name: string, priority: number}} categories\n     */\n    _render(commands, categories) {\n        const parser = new DOMParser();\n        this._mainWrapperElement.innerHTML = '';\n        this._hoverActive = false;\n        this._mainWrapperElement.classList.toggle('oe-powerbox-noResult', commands.length === 0);\n        this._context.selectedCommand = commands.find(command => command === this._context.selectedCommand) || commands[0];\n        for (const [category, categoryCommands] of this._groupCommands(commands, categories)) {\n            const categoryWrapperEl = parser.parseFromString(`\n                <div class=\"oe-powerbox-categoryWrapper\">\n                    <div class=\"oe-powerbox-category mx-3 my-1 text-uppercase\"></div>\n                </div>`, 'text/html').body.firstChild;\n            this._mainWrapperElement.append(categoryWrapperEl);\n            categoryWrapperEl.firstElementChild.innerText = category;\n            for (const command of categoryCommands) {\n                const commandElWrapper = document.createElement('div');\n                commandElWrapper.className = 'oe-powerbox-commandWrapper d-flex align-items-center px-3 py-2 cursor-pointer';\n                commandElWrapper.classList.toggle('active', this._context.selectedCommand === command);\n                commandElWrapper.replaceChildren(...parser.parseFromString(`\n                    <div class=\"oe-powerbox-commandLeftCol border rounded\">\n                        <i class=\"oe-powerbox-commandImg d-flex align-items-center justify-content-center fa\"></i>\n                    </div>\n                    <div class=\"oe-powerbox-commandRightCol ms-3\">\n                        <div class=\"oe-powerbox-commandName\"></div>\n                        <div class=\"oe-powerbox-commandDescription\"></div>\n                    </div>`, 'text/html').body.children);\n                commandElWrapper.querySelector('.oe-powerbox-commandImg').classList.add(command.fontawesome);\n                commandElWrapper.querySelector('.oe-powerbox-commandName').innerText = command.name;\n                commandElWrapper.querySelector('.oe-powerbox-commandDescription').innerText = command.description;\n                categoryWrapperEl.append(commandElWrapper);\n                // Handle events on command (activate and pick).\n                commandElWrapper.addEventListener('mousemove', () => {\n                    this.el.querySelector('.oe-powerbox-commandWrapper.active').classList.remove('active');\n                    this._context.selectedCommand = command;\n                    commandElWrapper.classList.add('active');\n                });\n                commandElWrapper.addEventListener('click', ev => {\n                        ev.preventDefault();\n                        ev.stopImmediatePropagation();\n                        this._pickCommand(command);\n                    }, true,\n                );\n            }\n        }\n        // Hide category name if there is only a single one.\n        if (this._mainWrapperElement.childElementCount === 1) {\n            this._mainWrapperElement.querySelector('.oe-powerbox-category').style.display = 'none';\n        }\n        this._resetPosition();\n    }\n    /**\n     * Handle the selection of a command: call the command's callback. Also call\n     * the `beforeCommand` and `afterCommand` hooks if they exists.\n     *\n     * @private\n     * @param {PowerboxCommand} [command=this._context.selectedCommand]\n     */\n    async _pickCommand(command=this._context.selectedCommand) {\n        if (command) {\n            if (this.beforeCommand) {\n                await this.beforeCommand();\n            }\n            await command.callback();\n            if (this.afterCommand) {\n                await this.afterCommand();\n            }\n        }\n        this.close();\n    };\n    /**\n     * Takes a list of commands and returns an object whose keys are all\n     * existing category names and whose values are each of these categories'\n     * commands. Categories with no commands are removed.\n     *\n     * @private\n     * @param {PowerboxCommand[]} commands\n     * @param {Array<{name: string, priority: number}} categories\n     * @returns {{Array<[string, PowerboxCommand[]]>}>}\n     */\n    _groupCommands(commands, categories) {\n        const groups = [];\n        for (const category of categories) {\n            const categoryCommands = commands.filter(command => command.category === category.name);\n            commands = commands.filter(command => command.category !== category.name);\n            groups.push([category.name, categoryCommands]);\n        }\n        // If commands remain, it means they declared categories that didn't\n        // exist. Add these categories alphabetically at the end of the list.\n        const remainingCategories = [...new Set(commands.map(command => command.category))];\n        for (const categoryName of remainingCategories.sort((a, b) => a.localeCompare(b))) {\n            const categoryCommands = commands.filter(command => command.category === categoryName);\n            groups.push([categoryName, categoryCommands]);\n        }\n        return groups.filter(group => group[1].length);\n    }\n    /**\n     * Take an array of commands or categories and return a reordered copy of\n     * it, based on their respective priorities.\n     *\n     * @param {PowerboxCommand[] | Array<{name: string, priority: number}} commandsOrCategories\n     * @returns {PowerboxCommand[] | Array<{name: string, priority: number}}\n     */\n    _orderByPriority(commandsOrCategories) {\n        return [...commandsOrCategories].sort((a, b) => b.priority - a.priority || a.name.localeCompare(b.name));\n    }\n    /**\n     * Recompute the Powerbox's position base on the selection in the document.\n     *\n     * @private\n     */\n    _resetPosition() {\n        let options = {};\n        if (this.getContextFromParentRect) {\n            options['parentContextRect'] = this.getContextFromParentRect();\n        }\n        const position = getRangePosition(this.el, this.document, options);\n        if (position) {\n            let { left, top } = position;\n            this.el.style.left = `${left}px`;\n            this.el.style.top = `${top}px`;\n        } else {\n            this.hide();\n        }\n    }\n    /**\n     * Add all events to their given target, based on @see _events.\n     *\n     * @private\n     */\n    _bindEvents() {\n        for (const [target, eventName, callback, option] of this._events) {\n            target.addEventListener(eventName, callback, option);\n        }\n    }\n    /**\n     * Remove all events from their given target, based on @see _events.\n     *\n     * @private\n     */\n    _unbindEvents() {\n        for (const [target, eventName, callback, option] of this._events) {\n            target.removeEventListener(eventName, callback, option);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Handlers\n    // -------------------------------------------------------------------------\n\n    /**\n     * Handle keyup events to filter commands based on what was typed, and\n     * prevent changing selection when using the arrow keys.\n     *\n     * @private\n     * @param {KeyboardEvent} ev\n     */\n    _onKeyup(ev) {\n        if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {\n            ev.preventDefault();\n        } else {\n            const diff = patienceDiff(\n                this._context.initialValue.split(''),\n                this._context.initialTarget.textContent.split(''),\n                true,\n            );\n            this._context.lastText = diff.bMove.join('');\n            const selection = this.document.getSelection();\n            if (\n                this._context.lastText.match(/\\s/) ||\n                !selection ||\n                this._context.initialTarget !== closestBlock(selection.anchorNode)\n            ) {\n                this.close();\n            } else {\n                const term = this._context.lastText.toLowerCase()\n                    .replaceAll(/\\s/g, '\\\\s')\n                    .replaceAll('\\u200B', '')\n                    .replace(REGEX_RESERVED_CHARS, '\\\\$&');\n                if (term.length) {\n                    const exactRegex = new RegExp(term, 'i');\n                    const fuzzyRegex = new RegExp(term.match(/\\\\.|./g).join('.*'), 'i');\n                    this._context.filteredCommands = this._context.commands.filter(command => {\n                        const commandText = (command.category + ' ' + command.name);\n                        const commandDescription = command.description.replace(/\\s/g, '');\n                        return commandText.match(fuzzyRegex) || commandDescription.match(exactRegex);\n                    });\n                } else {\n                    this._context.filteredCommands = this._context.commands;\n                }\n                this._render(this._context.filteredCommands, this._context.categories);\n            }\n        }\n    }\n    /**\n     * Handle keydown events to add keyboard interactions with the Powerbox.\n     *\n     * @private\n     * @param {KeyboardEvent} ev\n     */\n    _onKeydown(ev) {\n        if (ev.key === 'Enter') {\n            ev.stopImmediatePropagation();\n            this._pickCommand();\n            ev.preventDefault();\n        } else if (ev.key === 'Escape') {\n            ev.stopImmediatePropagation();\n            this.close();\n            ev.preventDefault();\n        } else if (ev.key === 'Backspace' && !this._context.lastText) {\n            this.close();\n        } else if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n\n            const commandIndex = this._context.filteredCommands.findIndex(\n                command => command === this._context.selectedCommand,\n            );\n            if (this._context.filteredCommands.length && commandIndex !== -1) {\n                const nextIndex = commandIndex + (ev.key === 'ArrowDown' ? 1 : -1);\n                const newIndex = cycle(nextIndex, this._context.filteredCommands.length - 1);\n                this._context.selectedCommand = this._context.filteredCommands[newIndex];\n            } else {\n                this._context.selectedCommand = undefined;\n            }\n            this._render(this._context.filteredCommands, this._context.categories);\n            const activeCommand = this.el.querySelector('.oe-powerbox-commandWrapper.active');\n            if (activeCommand) {\n                activeCommand.scrollIntoView({block: 'nearest', inline: 'nearest'});\n            }\n        }\n    }\n}\n", "/** @odoo-module **/\n/**\n * program: \"patienceDiff\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiff( aLines[], bLines[], diffPlusFlag)\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *      diffPlusFlag if true, returns additional arrays with the subset of lines that were\n *          either deleted or inserted.  These additional arrays are used by patienceDiffPlus.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLine[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *          moved is true if the line was moved from elsewhere in aLines[] or bLines[].\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is the number of lines moved outside of the Longest Common Subsequence.\n *\n */\n\nexport function patienceDiff(aLines, bLines, diffPlusFlag) {\n    //\n    // findUnique finds all unique values in arr[lo..hi], inclusive.  This\n    // function is used in preparation for determining the longest common\n    // subsequence.  Specifically, it first reduces the array range in question\n    // to unique values.\n    //\n    // Returns an ordered Map, with the arr[i] value as the Map key and the\n    // array index i as the Map value.\n    //\n    function findUnique(arr, lo, hi) {\n        var lineMap = new Map();\n\n        for (let i = lo; i <= hi; i++) {\n            let line = arr[i];\n            if (lineMap.has(line)) {\n                lineMap.get(line).count++;\n                lineMap.get(line).index = i;\n            } else {\n                lineMap.set(line, { count: 1, index: i });\n            }\n        }\n\n        lineMap.forEach((val, key, map) => {\n            if (val.count !== 1) {\n                map.delete(key);\n            } else {\n                map.set(key, val.index);\n            }\n        });\n\n        return lineMap;\n    }\n\n    //\n    // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\n    // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\n    // down the aArray and bArray ranges first, before then walking the comparison\n    // between the two arrays.\n    //\n    // Returns an ordered Map, with the Map key as the common line between aArray\n    // and bArray, with the Map value as an object containing the array indexes of\n    // the matching unique lines.\n    //\n    function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\n        let ma = findUnique(aArray, aLo, aHi);\n        let mb = findUnique(bArray, bLo, bHi);\n\n        ma.forEach((val, key, map) => {\n            if (mb.has(key)) {\n                map.set(key, { indexA: val, indexB: mb.get(key) });\n            } else {\n                map.delete(key);\n            }\n        });\n\n        return ma;\n    }\n\n    //\n    // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\n    // and determines the Longest Common Subsequence (LCS).\n    //\n    // Returns an ordered array of objects containing the array indexes of the\n    // matching lines for a LCS.\n    //\n    function longestCommonSubsequence(abMap) {\n        var ja = [];\n\n        // First, walk the list creating the jagged array.\n        abMap.forEach((val, key, map) => {\n            let i = 0;\n            while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n                i++;\n            }\n\n            if (!ja[i]) {\n                ja[i] = [];\n            }\n\n            if (0 < i) {\n                val.prev = ja[i - 1][ja[i - 1].length - 1];\n            }\n\n            ja[i].push(val);\n        });\n\n        // Now, pull out the longest common subsequence.\n        var lcs = [];\n        if (0 < ja.length) {\n            let n = ja.length - 1;\n            var lcs = [ja[n][ja[n].length - 1]];\n            while (lcs[lcs.length - 1].prev) {\n                lcs.push(lcs[lcs.length - 1].prev);\n            }\n        }\n\n        return lcs.reverse();\n    }\n\n    // \"result\" is the array used to accumulate the aLines that are deleted, the\n    // lines that are shared between aLines and bLines, and the bLines that were\n    // inserted.\n    let result = [];\n    let deleted = 0;\n    let inserted = 0;\n\n    // aMove and bMove will contain the lines that don't match, and will be returned\n    // for possible searching of lines that moved.\n\n    let aMove = [];\n    let aMoveIndex = [];\n    let bMove = [];\n    let bMoveIndex = [];\n\n    //\n    // addToResult simply pushes the latest value onto the \"result\" array.  This\n    // array captures the diff of the line, aIndex, and bIndex from the aLines\n    // and bLines array.\n    //\n    function addToResult(aIndex, bIndex) {\n        if (bIndex < 0) {\n            aMove.push(aLines[aIndex]);\n            aMoveIndex.push(result.length);\n            deleted++;\n        } else if (aIndex < 0) {\n            bMove.push(bLines[bIndex]);\n            bMoveIndex.push(result.length);\n            inserted++;\n        }\n\n        result.push({\n            line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n            aIndex: aIndex,\n            bIndex: bIndex,\n        });\n    }\n\n    //\n    // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\n    // this function might recursively call recurseLCS to further match the lines\n    // between aLines and bLines.\n    //\n    function addSubMatch(aLo, aHi, bLo, bHi) {\n        // Match any lines at the beginning of aLines and bLines.\n        while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n            addToResult(aLo++, bLo++);\n        }\n\n        // Match any lines at the end of aLines and bLines, but don't place them\n        // in the \"result\" array just yet, as the lines between these matches at\n        // the beginning and the end need to be analyzed first.\n        let aHiTemp = aHi;\n        while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n            aHi--;\n            bHi--;\n        }\n\n        // Now, check to determine with the remaining lines in the subsequence\n        // whether there are any unique common lines between aLines and bLines.\n        //\n        // If not, add the subsequence to the result (all aLines having been\n        // deleted, and all bLines having been inserted).\n        //\n        // If there are unique common lines between aLines and bLines, then let's\n        // recursively perform the patience diff on the subsequence.\n        let uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n        if (uniqueCommonMap.size === 0) {\n            while (aLo <= aHi) {\n                addToResult(aLo++, -1);\n            }\n            while (bLo <= bHi) {\n                addToResult(-1, bLo++);\n            }\n        } else {\n            recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n        }\n\n        // Finally, let's add the matches at the end to the result.\n        while (aHi < aHiTemp) {\n            addToResult(++aHi, ++bHi);\n        }\n    }\n\n    //\n    // recurseLCS finds the longest common subsequence (LCS) between the arrays\n    // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\n    // recursively performs another LCS search (via addSubMatch), until there are\n    // none found, at which point the subsequence is dumped to the result.\n    //\n    function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\n        var x = longestCommonSubsequence(\n            uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi),\n        );\n        if (x.length === 0) {\n            addSubMatch(aLo, aHi, bLo, bHi);\n        } else {\n            if (aLo < x[0].indexA || bLo < x[0].indexB) {\n                addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n            }\n\n            let i;\n            for (i = 0; i < x.length - 1; i++) {\n                addSubMatch(x[i].indexA, x[i + 1].indexA - 1, x[i].indexB, x[i + 1].indexB - 1);\n            }\n\n            if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n                addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n            }\n        }\n    }\n\n    recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n    if (diffPlusFlag) {\n        return {\n            lines: result,\n            lineCountDeleted: deleted,\n            lineCountInserted: inserted,\n            lineCountMoved: 0,\n            aMove: aMove,\n            aMoveIndex: aMoveIndex,\n            bMove: bMove,\n            bMoveIndex: bMoveIndex,\n        };\n    }\n\n    return {\n        lines: result,\n        lineCountDeleted: deleted,\n        lineCountInserted: inserted,\n        lineCountMoved: 0,\n    };\n}\n", "/** @odoo-module **/\nimport { getRangePosition } from '../utils/utils.js';\n\nexport class TablePicker extends EventTarget {\n    constructor(options = {}) {\n        super();\n        this.options = options;\n        this.options.minRowCount = this.options.minRowCount || 3;\n        this.options.minColCount = this.options.minColCount || 3;\n        this.options.getContextFromParentRect = this.options.getContextFromParentRect || (() => ({ top: 0, left: 0 }));\n\n        this.rowNumber = this.options.minRowCount;\n        this.colNumber = this.options.minColCount;\n\n        this.tablePickerWrapper = document.createElement('div');\n        this.tablePickerWrapper.classList.add('oe-tablepicker-wrapper');\n        this.tablePickerWrapper.innerHTML = `\n            <div class=\"oe-tablepicker\"></div>\n            <div class=\"oe-tablepicker-size\"></div>\n        `;\n\n        if (this.options.floating) {\n            this.tablePickerWrapper.style.position = 'absolute';\n            this.tablePickerWrapper.classList.add('oe-floating');\n        }\n\n        this.tablePickerElement = this.tablePickerWrapper.querySelector('.oe-tablepicker');\n        this.tablePickerSizeViewElement =\n            this.tablePickerWrapper.querySelector('.oe-tablepicker-size');\n\n        this.el = this.tablePickerWrapper;\n\n        this.hide();\n    }\n\n    render() {\n        this.tablePickerElement.innerHTML = '';\n\n        const colCount = Math.max(this.colNumber, this.options.minRowCount);\n        const rowCount = Math.max(this.rowNumber, this.options.minRowCount);\n        const extraCol = 1;\n        const extraRow = 1;\n\n        for (let rowNumber = 1; rowNumber <= rowCount + extraRow; rowNumber++) {\n            const rowElement = document.createElement('div');\n            rowElement.classList.add('oe-tablepicker-row');\n            this.tablePickerElement.appendChild(rowElement);\n            for (let colNumber = 1; colNumber <= colCount + extraCol; colNumber++) {\n                const cell = this.el.ownerDocument.createElement('div');\n                cell.classList.add('oe-tablepicker-cell', 'btn');\n                rowElement.appendChild(cell);\n\n                if (rowNumber <= this.rowNumber && colNumber <= this.colNumber) {\n                    cell.classList.add('active');\n                }\n\n                const bindMouseMove = () => {\n                    cell.addEventListener('mouseover', () => {\n                        if (this.colNumber !== colNumber || this.rowNumber != rowNumber) {\n                            this.colNumber = colNumber;\n                            this.rowNumber = rowNumber;\n                            this.render();\n                        }\n                    });\n                    this.el.ownerDocument.removeEventListener('mousemove', bindMouseMove);\n                };\n                this.el.ownerDocument.addEventListener('mousemove', bindMouseMove);\n                cell.addEventListener('mousedown', this.selectCell.bind(this));\n            }\n        }\n\n        this.tablePickerSizeViewElement.textContent = `${this.colNumber}x${this.rowNumber}`;\n    }\n\n    show() {\n        this.reset();\n        this.el.style.display = 'block';\n        if (this.options.floating) {\n            this._showFloating();\n        }\n    }\n\n    hide() {\n        this.el.style.display = 'none';\n    }\n\n    reset() {\n        this.rowNumber = this.options.minRowCount;\n        this.colNumber = this.options.minColCount;\n        this.render();\n    }\n\n    selectCell() {\n        this.dispatchEvent(\n            new CustomEvent('cell-selected', {\n                detail: { colNumber: this.colNumber, rowNumber: this.rowNumber },\n            }),\n        );\n    }\n\n    _showFloating() {\n        const keydown = e => {\n            const actions = {\n                ArrowRight: {\n                    colNumber: this.colNumber + 1,\n                    rowNumber: this.rowNumber,\n                },\n                ArrowLeft: {\n                    colNumber: this.colNumber - 1 || 1,\n                    rowNumber: this.rowNumber,\n                },\n                ArrowUp: {\n                    colNumber: this.colNumber,\n                    rowNumber: this.rowNumber - 1 || 1,\n                },\n                ArrowDown: {\n                    colNumber: this.colNumber,\n                    rowNumber: this.rowNumber + 1,\n                },\n            };\n            const action = actions[e.key];\n            if (action) {\n                this.rowNumber = action.rowNumber || this.rowNumber;\n                this.colNumber = action.colNumber || this.colNumber;\n                this.render();\n\n                e.preventDefault();\n            } else if (e.key === 'Enter') {\n                this.selectCell();\n                e.preventDefault();\n            } else if (e.key === 'Escape') {\n                stop();\n                e.preventDefault();\n            }\n        };\n\n        const offset = getRangePosition(this.el, this.options.document, this.options);\n        this.el.style.left = `${offset.left}px`;\n        this.el.style.top = `${offset.top}px`;\n\n        const stop = () => {\n            this.hide();\n            this.options.document.removeEventListener('mousedown', stop);\n            this.removeEventListener('cell-selected', stop);\n            this.options.document.removeEventListener('keydown', keydown, true);\n        };\n\n        // Allow the mousedown that activate this command callback to release before adding the listener.\n        setTimeout(() => {\n            this.options.document.addEventListener('mousedown', stop);\n        });\n        this.options.document.addEventListener('keydown', keydown, true);\n        this.addEventListener('cell-selected', stop);\n    }\n}\n", "/** @odoo-module **/\nexport const UNBREAKABLE_ROLLBACK_CODE = 'UNBREAKABLE';\nexport const UNREMOVABLE_ROLLBACK_CODE = 'UNREMOVABLE';\nexport const REGEX_BOOTSTRAP_COLUMN = /(?:^| )col(-[a-zA-Z]+)?(-\\d+)?(?:$| )/;\n", "/** @odoo-module **/\nimport {\n    closestBlock,\n    closestElement,\n    startPos,\n    fillEmpty,\n    getListMode,\n    isBlock,\n    isEmptyBlock,\n    isSelfClosingElement,\n    moveNodes,\n    preserveCursor,\n    isFontAwesome,\n    getDeepRange,\n    isUnbreakable,\n    isEditorTab,\n    isProtected,\n    isZWS,\n    isArtificialVoidElement,\n    ancestors,\n    EMAIL_REGEX,\n    PHONE_REGEX,\n    URL_REGEX,\n    unwrapContents,\n} from './utils.js';\n\nconst NOT_A_NUMBER = /[^\\d]/g;\n\n// In some cases, we want to prevent merging identical elements.\nexport const UNMERGEABLE_SELECTORS = [];\n\nfunction hasPseudoElementContent (node, pseudoSelector) {\n    const content = getComputedStyle(node, pseudoSelector).getPropertyValue('content');\n    return content && content !== 'none';\n}\n\nexport function areSimilarElements(node, node2) {\n    if (![node, node2].every(n => n?.nodeType === Node.ELEMENT_NODE)) {\n        return false; // The nodes don't both exist or aren't both elements.\n    }\n    if (node.nodeName !== node2.nodeName) {\n        return false; // The nodes aren't the same type of element.\n    }\n    const nodeName = node.nodeName;\n\n    for (const name of new Set([\n        ...node.getAttributeNames(),\n        ...node2.getAttributeNames(),\n    ])) {\n        if (node.getAttribute(name) !== node2.getAttribute(name)) {\n            return false; // The nodes don't have the same attributes.\n        }\n    }\n    if ([node, node2].some(n => hasPseudoElementContent(n, ':before') || hasPseudoElementContent(n, ':after'))) {\n        return false; // The nodes have pseudo elements with content.\n    }\n    if (isFontAwesome(node) || isFontAwesome(node2)) {\n        return false;\n    }\n    if (nodeName === 'LI' && node.classList.contains('oe-nested')) {\n        // If the nodes are adjacent nested list items, we need to compare the\n        // types of their \"adjacent\" list children rather that the list items\n        // themselves.\n        return (\n            node.lastElementChild &&\n            node2.firstElementChild &&\n            getListMode(node.lastElementChild) === getListMode(node2.firstElementChild)\n        );\n    }\n    if (['UL', 'OL'].includes(nodeName)) {\n        return !isSelfClosingElement(node) && !isSelfClosingElement(node2); // The nodes are non-empty lists. TODO: this doesn't check that and it will always be true!\n    }\n    if (isBlock(node) || isSelfClosingElement(node) || isSelfClosingElement(node2)) {\n        return false; // The nodes are blocks or are empty but visible. TODO: Not sure this was what we wanted to check (see just above).\n    }\n    const nodeStyle = getComputedStyle(node);\n    const node2Style = getComputedStyle(node2);\n    return (\n        !+nodeStyle.padding.replace(NOT_A_NUMBER, '') &&\n        !+node2Style.padding.replace(NOT_A_NUMBER, '') &&\n        !+nodeStyle.margin.replace(NOT_A_NUMBER, '') &&\n        !+node2Style.margin.replace(NOT_A_NUMBER, '')\n    );\n}\n\n/**\n* Returns a complete URL if text is a valid email address, http URL or telephone\n* number, null otherwise.\n* The optional link parameter is used to prevent protocol switching between\n* 'http' and 'https'.\n*\n* @param {String} text\n* @param {HTMLAnchorElement} [link]\n* @returns {String|null}\n*/\nexport function deduceURLfromText(text, link) {\n   const label = text.replace(/\\u200b/g, '').trim();\n   // Check first for e-mail.\n   let match = label.match(EMAIL_REGEX);\n   if (match) {\n       return match[1] ? match[0] : 'mailto:' + match[0];\n   }\n   // Check for http link.\n   match = label.match(URL_REGEX);\n   if (match && match[0] === label) {\n       const currentHttpProtocol = (link?.href.match(/^http(s)?:\\/\\//gi) || [])[0];\n       if (match[2]) {\n           return match[0];\n       } else if (currentHttpProtocol) {\n           // Avoid converting a http link to https.\n           return currentHttpProtocol + match[0];\n       } else {\n           return 'http://' + match[0];\n       }\n   }\n   // Check for telephone url.\n   match = label.match(PHONE_REGEX);\n   if (match) {\n       return match[1] ? match[0] : 'tel://' + match[0];\n   }\n   return null;\n}\n\nfunction shouldPreserveCursor(node, root) {\n    const selection = root.ownerDocument.getSelection();\n    return node.isConnected && selection &&\n        selection.anchorNode && root.contains(selection.anchorNode) &&\n        selection.focusNode && root.contains(selection.focusNode);\n}\n\n/**\n * Sanitize the given node and return it.\n *\n * @param {Node} node\n * @param {Element} root\n * @returns {Node} the sanitized node\n */\nfunction sanitizeNode(node, root) {\n    // First ensure elements which should not contain any content are tagged\n    // contenteditable=false to avoid any hiccup.\n    if (isArtificialVoidElement(node) && node.getAttribute('contenteditable') !== 'false') {\n        node.setAttribute('contenteditable', 'false');\n    }\n\n    // Remove empty class/style attributes.\n    for (const attributeName of ['class', 'style']) {\n        if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute(attributeName) && !node.getAttribute(attributeName)) {\n            node.removeAttribute(attributeName);\n        }\n    }\n\n    if (['SPAN', 'FONT'].includes(node.nodeName) && !node.hasAttributes()) {\n        // Unwrap the contents of SPAN and FONT elements without attributes.\n        getDeepRange(root, { select: true });\n        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);\n        const parent = node.parentElement;\n        unwrapContents(node);\n        restoreCursor && restoreCursor();\n        node = parent; // The node has been removed, update the reference.\n    } else if (\n        areSimilarElements(node, node.previousSibling) &&\n        !isUnbreakable(node) &&\n        !isEditorTab(node) &&\n        !(\n            node.attributes?.length === 1 &&\n            node.hasAttribute('data-oe-zws-empty-inline') &&\n            (node.textContent === '\\u200B' || node.previousSibling.textContent === '\\u200B')\n        ) &&\n        !UNMERGEABLE_SELECTORS.some(selectorClass => node.classList?.contains(selectorClass))\n    ) {\n        // Merge identical elements together.\n        getDeepRange(root, { select: true });\n        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);\n        moveNodes(...startPos(node), node.previousSibling);\n        restoreCursor && restoreCursor();\n    } else if (node.nodeType === Node.COMMENT_NODE) {\n        // Remove comment nodes to avoid issues with mso comments.\n        const parent = node.parentElement;\n        node.remove();\n        node = parent; // The node has been removed, update the reference.\n    } else if (\n        node.nodeName === 'P' && // Note: not sure we should limit to <p>.\n        node.parentElement.nodeName === 'LI' &&\n        !node.parentElement.classList.contains('nav-item')\n    ) {\n        // Remove empty paragraphs in <li>.\n        const classes = node.classList;\n        const parent = node.parentElement;\n        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);\n        if (isEmptyBlock(node)) {\n            node.remove();\n        } else if (classes.length) {\n            const spanEl = document.createElement('span');\n            spanEl.setAttribute('class', classes);\n            spanEl.append(...node.childNodes);\n            node.replaceWith(spanEl);\n        } else {\n            unwrapContents(node);\n        }\n        fillEmpty(parent);\n        restoreCursor && restoreCursor(new Map([[node, parent]]));\n        node = parent; // The node has been removed, update the reference.\n    } else if (node.nodeName === 'LI' && !node.closest('ul, ol')) {\n        // Transform <li> into <p> if they are not in a <ul> / <ol>.\n        const paragraph = document.createElement('p');\n        paragraph.replaceChildren(...node.childNodes);\n        node.replaceWith(paragraph);\n        node = paragraph; // The node has been removed, update the reference.\n    } else if (isFontAwesome(node) && node.textContent !== '\\u200B') {\n        // Ensure a zero width space is present inside the FA element.\n        node.textContent = '\\u200B';\n    } else if (isEditorTab(node)) {\n        // Ensure the editor tabs align on a 40px grid.\n        let tabPreviousSibling = node.previousSibling;\n        while (isZWS(tabPreviousSibling)) {\n            tabPreviousSibling = tabPreviousSibling.previousSibling;\n        }\n        if (isEditorTab(tabPreviousSibling)) {\n            node.style.width = '40px';\n        } else {\n            const editable = closestElement(node, '.odoo-editor-editable');\n            if (editable?.firstElementChild) {\n                const nodeRect = node.getBoundingClientRect();\n                const referenceRect = editable.firstElementChild.getBoundingClientRect();\n                // Values from getBoundingClientRect() are all zeros during\n                // Editor startup or saving. We cannot recalculate the tabs\n                // width in thoses cases.\n                if (nodeRect.width && referenceRect.width) {\n                    const width = (nodeRect.left - referenceRect.left) % 40;\n                    node.style.width = (40 - width) + 'px';\n                }\n            }\n        }\n    }\n    return node;\n}\n\n/**\n * Sanitize a node tree and return the sanitized node.\n *\n * @param {Node} nodeToSanitize the node to sanitize\n * @param {Node} [root] the root of the tree to sanitize (will not sanitize nodes outside of this tree)\n * @returns {Node} the sanitized node\n */\nexport function sanitize(nodeToSanitize, root = nodeToSanitize) {\n    const start = nodeToSanitize.ownerDocument.getSelection()?.anchorNode;\n    const block = closestBlock(nodeToSanitize);\n    if (block && root.contains(block)) {\n        // If the node is a list, start sanitization from its parent to ensure\n        // adjacent lists are merged when needed.\n        const isList = ['UL', 'OL'].includes(block.nodeName);\n        let node = isList ? block.parentElement : block;\n\n        // Sanitize the tree.\n        while (node && !(root.isConnected && !node.isConnected) && root.contains(node)) {\n            if (!isProtected(node)) {\n                node = sanitizeNode(node, root); // The node itself might be replaced during sanitization.\n            }\n            node = node.firstChild || node.nextSibling || ancestors(node, root).find(a => a.nextSibling)?.nextSibling;\n        }\n\n        // Ensure unique ids on checklists and stars.\n        const elementsWithId = [...block.querySelectorAll('[id^=checkId-]')];\n        const maxId = Math.max(...[0, ...elementsWithId.map(node => +node.getAttribute('id').substring(8))]);\n        let nextId = maxId + 1;\n        const ids = [];\n        for (const node of block.querySelectorAll('[id^=checkId-], .o_checklist > li, .o_stars')) {\n            if (\n                !node.classList.contains('o_stars') && (\n                    !node.parentElement.classList.contains('o_checklist') ||\n                    [...node.children].some(child => ['UL', 'OL'].includes(child.nodeName))\n            )) {\n                // Remove unique ids from checklists and stars from elements\n                // that are no longer checklist items or stars, and from\n                // parents of nested lists.\n                node.removeAttribute('id')\n            } else {\n                // Add/change IDs where needed, and ensure they're unique.\n                let id = node.getAttribute('id');\n                if (!id || ids.includes(id)) {\n                    id = `checkId-${nextId}`;\n                    nextId++;\n                    node.setAttribute('id', id);\n                }\n                ids.push(id);\n            }\n        }\n\n        // Update link URL if label is a new valid link.\n        const startEl = start && closestElement(start, 'a');\n        if (startEl && root.contains(startEl)) {\n            const label = startEl.innerText;\n            const url = deduceURLfromText(label, startEl);\n            if (url) {\n                startEl.setAttribute('href', url);\n            }\n        }\n    }\n    return nodeToSanitize;\n}\n", "/** @odoo-module **/\n// TODO: avoid empty keys when not necessary to reduce request size\nexport function serializeNode(node, nodesToStripFromChildren = new Set()) {\n    if (!node.oid) {\n        return;\n    }\n    const result = {\n        nodeType: node.nodeType,\n        oid: node.oid,\n    };\n    if (node.nodeType === Node.TEXT_NODE) {\n        result.textValue = node.nodeValue;\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n        result.tagName = node.tagName;\n        result.children = [];\n        result.attributes = {};\n        for (let i = 0; i < node.attributes.length; i++) {\n            result.attributes[node.attributes[i].name] = node.attributes[i].value;\n        }\n        let child = node.firstChild;\n        // Don't serialize transient nodes\n        if (![\"true\", \"\"].includes(node.dataset.oeTransientContent)) {\n            while (child) {\n                if (!nodesToStripFromChildren.has(child.oid)) {\n                    const serializedChild = serializeNode(child, nodesToStripFromChildren);\n                    if (serializedChild) {\n                        result.children.push(serializedChild);\n                    }\n                }\n                child = child.nextSibling;\n            }\n        }\n    }\n    return result;\n}\n\nexport function unserializeNode(obj) {\n    let result = undefined;\n    if (obj.nodeType === Node.TEXT_NODE) {\n        result = document.createTextNode(obj.textValue);\n    } else if (obj.nodeType === Node.ELEMENT_NODE) {\n        result = document.createElement(obj.tagName);\n        for (const key in obj.attributes) {\n            result.setAttribute(key, obj.attributes[key]);\n        }\n        obj.children.forEach(child => result.append(unserializeNode(child)));\n    } else {\n        console.warn('unknown node type');\n    }\n    result.oid = obj.oid;\n    return result;\n}\n\nexport function serializeSelection(selection) {\n    if (\n        selection &&\n        selection.anchorNode &&\n        selection.anchorNode.oid &&\n        typeof selection.anchorOffset !==  'undefined' &&\n        selection.focusNode &&\n        selection.anchorNode.oid &&\n        typeof selection.focusOffset !==  'undefined'\n    ) {\n        return {\n            anchorNodeOid: selection.anchorNode.oid,\n            anchorOffset: selection.anchorOffset,\n            focusNodeOid: selection.focusNode.oid,\n            focusOffset: selection.focusOffset,\n        };\n    } else {\n        return {\n            anchorNodeOid: undefined,\n            anchorOffset: undefined,\n            focusNodeOid: undefined,\n            focusOffset: undefined,\n        };\n    }\n}\n", "/** @odoo-module **/\n\nexport const DIRECTIONS = {\n    LEFT: false,\n    RIGHT: true,\n};\nexport const CTYPES = {\n    // Short for CONTENT_TYPES\n    // Inline group\n    CONTENT: 1,\n    SPACE: 2,\n\n    // Block group\n    BLOCK_OUTSIDE: 4,\n    BLOCK_INSIDE: 8,\n\n    // Br group\n    BR: 16,\n};\nexport function ctypeToString(ctype) {\n    return Object.keys(CTYPES).find((key) => CTYPES[key] === ctype);\n}\nexport const CTGROUPS = {\n    // Short for CONTENT_TYPE_GROUPS\n    INLINE: CTYPES.CONTENT | CTYPES.SPACE,\n    BLOCK: CTYPES.BLOCK_OUTSIDE | CTYPES.BLOCK_INSIDE,\n    BR: CTYPES.BR,\n};\nconst tldWhitelist = [\n    'com', 'net', 'org', 'ac', 'ad', 'ae', 'af', 'ag', 'ai', 'al', 'am', 'an',\n    'ao', 'aq', 'ar', 'as', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd',\n    'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bl', 'bm', 'bn', 'bo', 'br', 'bq',\n    'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cc', 'cd', 'cf', 'cg', 'ch',\n    'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'cr', 'cs', 'cu', 'cv', 'cw', 'cx',\n    'cy', 'cz', 'dd', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'ee', 'eg',\n    'eh', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga',\n    'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gp', 'gq',\n    'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu',\n    'id', 'ie', 'il', 'im', 'in', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm',\n    'jo', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky',\n    'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly',\n    'ma', 'mc', 'md', 'me', 'mf', 'mg', 'mh', 'mk', 'ml', 'mm', 'mn', 'mo',\n    'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw', 'mx', 'my', 'mz', 'na',\n    'nc', 'ne', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om',\n    'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'ps', 'pt',\n    'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd',\n    'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'ss',\n    'st', 'su', 'sv', 'sx', 'sy', 'sz', 'tc', 'td', 'tf', 'tg', 'th', 'tj',\n    'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'tt', 'tv', 'tw', 'tz', 'ua',\n    'ug', 'uk', 'um', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn',\n    'vu', 'wf', 'ws', 'ye', 'yt', 'yu', 'za', 'zm', 'zr', 'zw', 'co\\\\.uk'];\n\nconst urlRegexBase = `|(?:www.))[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.[a-zA-Z][a-zA-Z0-9]{1,62}|(?:[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.(?:${tldWhitelist.join('|')})\\\\b))(?:(?:[/?#])[^\\\\s]*[^!.,})\\\\]'\"\\\\s]|(?:[^!(){}.,[\\\\]'\"\\\\s]+))?`;\nconst httpCapturedRegex= `(https?:\\\\/\\\\/)`;\n\nexport const URL_REGEX = new RegExp(`((?:(?:${httpCapturedRegex}${urlRegexBase})`, 'i');\nexport const YOUTUBE_URL_GET_VIDEO_ID =\n    /^(?:(?:https?:)?\\/\\/)?(?:(?:www|m)\\.)?(?:youtube\\.com|youtu\\.be)(?:\\/(?:[\\w-]+\\?v=|embed\\/|v\\/)?)([^\\s?&#]+)(?:\\S+)?$/i;\nexport const EMAIL_REGEX = /^(mailto:)?[\\w-.]+@(?:[\\w-]+\\.)+[\\w-]{2,4}$/i;\nexport const PHONE_REGEX = /^(tel:(?:\\/\\/)?)?\\+?[\\d\\s.\\-()\\/]{3,25}$/;\n\nexport const PROTECTED_BLOCK_TAG = ['TR','TD','TABLE','TBODY','UL','OL','LI'];\n\n/**\n * Array of all the classes used by the editor to change the font size.\n *\n * Note: the Bootstrap \"small\" class is an exception, the editor does not allow\n * to set it but it did in the past and we want to remove it when applying an\n * override of the font-size.\n */\nexport const FONT_SIZE_CLASSES = [\"display-1-fs\", \"display-2-fs\", \"display-3-fs\", \"display-4-fs\", \"h1-fs\",\n    \"h2-fs\", \"h3-fs\", \"h4-fs\", \"h5-fs\", \"h6-fs\", \"base-fs\", \"o_small-fs\", \"small\"];\n\n/**\n * Array of all the classes used by the editor to change the text style.\n *\n * Note: the Bootstrap \"small\" class was actually part of \"text style\"\n * configuration in the past... but also of the \"font size\" configuration (see\n * FONT_SIZE_CLASSES). It should be mentioned here too.\n */\nexport const TEXT_STYLE_CLASSES = [\"display-1\", \"display-2\", \"display-3\", \"display-4\", \"lead\", \"o_small\", \"small\"];\n\n//------------------------------------------------------------------------------\n// Position and sizes\n//------------------------------------------------------------------------------\n\n/**\n * @param {Node} node\n * @returns {Array.<HTMLElement, number>}\n */\nexport function leftPos(node) {\n    return [node.parentNode, childNodeIndex(node)];\n}\n/**\n * @param {Node} node\n * @returns {Array.<HTMLElement, number>}\n */\nexport function rightPos(node) {\n    return [node.parentNode, childNodeIndex(node) + 1];\n}\n/**\n * @param {Node} node\n * @returns {Array.<HTMLElement, number, HTMLElement, number>}\n */\nexport function boundariesOut(node) {\n    const index = childNodeIndex(node);\n    return [node.parentNode, index, node.parentNode, index + 1];\n}\n/**\n * @param {Node} node\n * @returns {Array.<Node, number>}\n */\nexport function startPos(node) {\n    return [node, 0];\n}\n/**\n * @param {Node} node\n * @returns {Array.<Node, number>}\n */\nexport function endPos(node) {\n    return [node, nodeSize(node)];\n}\n/**\n * @param {Node} node\n * @returns {Array.<node, number, node, number>}\n */\nexport function boundariesIn(node) {\n    return [node, 0, node, nodeSize(node)];\n}\n/**\n * Returns the given node's position relative to its parent (= its index in the\n * child nodes of its parent).\n *\n * @param {Node} node\n * @returns {number}\n */\nexport function childNodeIndex(node) {\n    let i = 0;\n    while (node.previousSibling) {\n        i++;\n        node = node.previousSibling;\n    }\n    return i;\n}\n/**\n * Returns the size of the node = the number of characters for text nodes and\n * the number of child nodes for element nodes.\n *\n * @param {Node} node\n * @returns {number}\n */\nexport function nodeSize(node) {\n    const isTextNode = node.nodeType === Node.TEXT_NODE;\n    return isTextNode ? node.length : node.childNodes.length;\n}\n\n//------------------------------------------------------------------------------\n// DOM Path and node search functions\n//------------------------------------------------------------------------------\n\nexport const closestPath = function* (node) {\n    while (node) {\n        yield node;\n        node = node.parentNode;\n    }\n};\n\n/**\n * Values which can be returned while browsing the DOM which gives information\n * to why the path ended.\n */\nconst PATH_END_REASONS = {\n    NO_NODE: 0,\n    BLOCK_OUT: 1,\n    BLOCK_HIT: 2,\n    OUT_OF_SCOPE: 3,\n};\n/**\n * Creates a generator function according to the given parameters. Pre-made\n * generators to traverse the DOM are made using this function:\n *\n * @see leftLeafFirstPath\n * @see leftLeafOnlyNotBlockPath\n * @see leftLeafOnlyInScopeNotBlockEditablePath\n * @see rightLeafOnlyNotBlockPath\n * @see rightLeafOnlyPathNotBlockNotEditablePath\n * @see rightLeafOnlyInScopeNotBlockEditablePath\n * @see rightLeafOnlyNotBlockNotEditablePath\n *\n * @param {number} direction\n * @param {boolean} [options.leafOnly] if true, do not yield any non-leaf node\n * @param {boolean} [options.inScope] if true, stop the generator as soon as a node is not\n *                      a descendant of `node` provided when traversing the\n *                      generated function.\n * @param {Function} [options.stopTraverseFunction] a function that takes a node\n *                      and should return true when a node descendant should not\n *                      be traversed.\n * @param {Function} [options.stopFunction] function that makes the generator stop when a\n *                      node is encountered.\n */\nexport function createDOMPathGenerator(\n    direction,\n    { leafOnly = false, inScope = false, stopTraverseFunction, stopFunction } = {},\n) {\n    const nextDeepest =\n        direction === DIRECTIONS.LEFT\n            ? node => lastLeaf(node.previousSibling, stopTraverseFunction)\n            : node => firstLeaf(node.nextSibling, stopTraverseFunction);\n\n    const firstNode =\n        direction === DIRECTIONS.LEFT\n            ? (node, offset) => lastLeaf(node.childNodes[offset - 1], stopTraverseFunction)\n            : (node, offset) => firstLeaf(node.childNodes[offset], stopTraverseFunction);\n\n    // Note \"reasons\" is a way for the caller to be able to know why the\n    // generator ended yielding values.\n    return function* (node, offset, reasons = []) {\n        let movedUp = false;\n\n        let currentNode = firstNode(node, offset);\n        if (!currentNode) {\n            movedUp = true;\n            currentNode = node;\n        }\n\n        while (currentNode) {\n            if (stopFunction && stopFunction(currentNode)) {\n                reasons.push(movedUp ? PATH_END_REASONS.BLOCK_OUT : PATH_END_REASONS.BLOCK_HIT);\n                break;\n            }\n            if (inScope && currentNode === node) {\n                reasons.push(PATH_END_REASONS.OUT_OF_SCOPE);\n                break;\n            }\n            if (!(leafOnly && movedUp)) {\n                yield currentNode;\n            }\n\n            movedUp = false;\n            let nextNode = nextDeepest(currentNode);\n            if (!nextNode) {\n                movedUp = true;\n                nextNode = currentNode.parentNode;\n            }\n            currentNode = nextNode;\n        }\n\n        reasons.push(PATH_END_REASONS.NO_NODE);\n    };\n}\n\n/**\n * Find a node.\n * @param {findCallback} findCallback - This callback check if this function\n *      should return `node`.\n * @param {findCallback} stopCallback - This callback check if this function\n *      should stop when it receive `node`.\n */\nexport function findNode(domPath, findCallback = () => true, stopCallback = () => false) {\n    for (const node of domPath) {\n        if (findCallback(node)) {\n            return node;\n        }\n        if (stopCallback(node)) {\n            break;\n        }\n    }\n    return null;\n}\n/**\n * This callback check if findNode should return `node`.\n * @callback findCallback\n * @param {Node} node\n * @return {Boolean}\n */\n/**\n * This callback check if findNode should stop when it receive `node`.\n * @callback stopCallback\n * @param {Node} node\n */\n\n/**\n * Return the furthest uneditable parent of node contained within parentLimit.\n * @see deleteRange Used to guarantee that uneditables are fully contained in\n * the range (so that it is not possible to partially remove them)\n *\n * @param {Node} node\n * @param {Node} [parentLimit=undefined] non-inclusive furthest parent allowed\n * @returns {Node} uneditable parent if it exists\n */\nexport function getFurthestUneditableParent(node, parentLimit) {\n    if (node === parentLimit || (parentLimit && !parentLimit.contains(node))) {\n        return undefined;\n    }\n    let parent = node && node.parentElement;\n    let nonEditableElement;\n    while (parent && (!parentLimit || parent !== parentLimit)) {\n        if (!parent.isContentEditable) {\n            nonEditableElement = parent;\n        }\n        if (parent.oid === \"root\") {\n            break;\n        }\n        parent = parent.parentElement;\n    }\n    return nonEditableElement;\n}\n/**\n * Returns the closest HTMLElement of the provided Node. If the predicate is a\n * string, returns the closest HTMLElement that match the predicate selector. If\n * the predicate is a function, returns the closest element that matches the\n * predicate. Any returned element will be contained within the editable.\n *\n * @param {Node} node\n * @param {string | Function} [predicate='*']\n * @returns {HTMLElement|null}\n */\nexport function closestElement(node, predicate = \"*\") {\n    if (!node) return null;\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (typeof predicate === 'function') {\n        while (element && !predicate(element)) {\n            element = element.parentElement;\n        }\n    } else {\n        element = element?.closest(predicate);\n    }\n\n    return element?.closest('.odoo-editor-editable') && element;\n}\n\n/**\n * Returns a list of all the ancestors nodes of the provided node.\n *\n * @param {Node} node\n * @param {Node} [editable] include to prevent bubbling up further than the editable.\n * @returns {HTMLElement[]}\n */\nexport function ancestors(node, editable) {\n    if (!node || !node.parentElement || node === editable) return [];\n    return [node.parentElement, ...ancestors(node.parentElement, editable)];\n}\n\n/**\n * Take a node, return all of its descendants, in depth-first order.\n *\n * @param {Node} node\n * @returns {Node[]}\n */\nexport function descendants(node) {\n    const posterity = [];\n    for (const child of (node.childNodes || [])) {\n        posterity.push(child, ...descendants(child));\n    }\n    return posterity;\n}\n\nexport function closestBlock(node) {\n    return findNode(closestPath(node), node => isBlock(node));\n}\n/**\n * Returns the deepest child in last position.\n *\n * @param {Node} node\n * @param {Function} [stopTraverseFunction]\n * @returns {Node}\n */\nexport function lastLeaf(node, stopTraverseFunction) {\n    while (node && node.lastChild && !(stopTraverseFunction && stopTraverseFunction(node))) {\n        node = node.lastChild;\n    }\n    return node;\n}\n/**\n * Returns the deepest child in first position.\n *\n * @param {Node} node\n * @param {Function} [stopTraverseFunction]\n * @returns {Node}\n */\nexport function firstLeaf(node, stopTraverseFunction) {\n    while (node && node.firstChild && !(stopTraverseFunction && stopTraverseFunction(node))) {\n        node = node.firstChild;\n    }\n    return node;\n}\nexport function previousLeaf(node, editable, skipInvisible = false) {\n    let ancestor = node;\n    while (ancestor && !ancestor.previousSibling && ancestor !== editable) {\n        ancestor = ancestor.parentElement;\n    }\n    if (ancestor && ancestor !== editable) {\n        if (skipInvisible && !isVisible(ancestor.previousSibling)) {\n            return previousLeaf(ancestor.previousSibling, editable, skipInvisible);\n        } else {\n            const last = lastLeaf(ancestor.previousSibling);\n            if (skipInvisible && !isVisible(last)) {\n                return previousLeaf(last, editable, skipInvisible);\n            } else {\n                return last;\n            }\n        }\n    }\n}\nexport function nextLeaf(node, editable, skipInvisible = false) {\n    let ancestor = node;\n    while (ancestor && !ancestor.nextSibling && ancestor !== editable) {\n        ancestor = ancestor.parentElement;\n    }\n    if (ancestor && ancestor !== editable) {\n        if (skipInvisible && ancestor.nextSibling && !isVisible(ancestor.nextSibling)) {\n            return nextLeaf(ancestor.nextSibling, editable, skipInvisible);\n        } else {\n            const first = firstLeaf(ancestor.nextSibling);\n            if (skipInvisible && !isVisible(first)) {\n                return nextLeaf(first, editable, skipInvisible);\n            } else {\n                return first;\n            }\n        }\n    }\n}\n/**\n * Returns all the previous siblings of the given node until the first\n * sibling that does not satisfy the predicate, in lookup order.\n *\n * @param {Node} node\n * @param {Function} [predicate] (node: Node) => boolean\n */\nexport function getAdjacentPreviousSiblings(node, predicate = n => !!n) {\n    let previous = node.previousSibling;\n    const list = [];\n    while (previous && predicate(previous)) {\n        list.push(previous);\n        previous = previous.previousSibling;\n    }\n    return list;\n}\n/**\n * Returns all the next siblings of the given node until the first\n * sibling that does not satisfy the predicate, in lookup order.\n *\n * @param {Node} node\n * @param {Function} [predicate] (node: Node) => boolean\n */\nexport function getAdjacentNextSiblings(node, predicate = n => !!n) {\n    let next = node.nextSibling;\n    const list = [];\n    while (next && predicate(next)) {\n        list.push(next);\n        next = next.nextSibling;\n    }\n    return list;\n}\n/**\n * Returns all the adjacent siblings of the given node until the first sibling\n * (in both directions) that does not satisfy the predicate, in index order. If\n * the given node does not satisfy the predicate, an empty array is returned.\n *\n * @param {Node} node\n * @param {Function} [predicate] (node: Node) => boolean\n */\nexport function getAdjacents(node, predicate = n => !!n) {\n    const previous = getAdjacentPreviousSiblings(node, predicate);\n    const next = getAdjacentNextSiblings(node, predicate);\n    return predicate(node) ? [...previous.reverse(), node, ...next] : [];\n}\n\n//------------------------------------------------------------------------------\n// Cursor management\n//------------------------------------------------------------------------------\n\n/**\n * Returns true if the given editable area contains a table with selected cells.\n *\n * @param {Element} editable\n * @returns {boolean}\n */\nexport function hasTableSelection(editable) {\n    return !!editable.querySelector('.o_selected_table');\n}\n/**\n * Returns true if the given editable area contains a \"valid\" selection, by\n * which we mean a browser selection whose elements are defined, or a table with\n * selected cells.\n *\n * @param {Element} editable\n * @returns {boolean}\n */\nexport function hasValidSelection(editable) {\n    return hasTableSelection(editable) || editable.ownerDocument.getSelection().rangeCount > 0;\n}\n/**\n * From a given position, returns the normalized version.\n *\n * E.g. <b>abc</b>[]def -> <b>abc[]</b>def\n *\n * @param {Node} node\n * @param {number} offset\n * @param {boolean} [full=true] (if not full, it means we only normalize\n *     positions which are not possible, like the cursor inside an image).\n */\nexport function getNormalizedCursorPosition(node, offset, full = true) {\n    const editable = closestElement(node, '.odoo-editor-editable');\n    let closest = closestElement(node);\n    while (\n        closest &&\n        closest !== editable &&\n        (isSelfClosingElement(node) || !closest.isContentEditable)\n    ) {\n        // Cannot put the cursor inside those elements, put it before if the\n        // offset is 0 and the node is not empty, else after instead.\n        [node, offset] = offset || !nodeSize(node) ? rightPos(node) : leftPos(node);\n        closest = closestElement(node);\n    }\n\n    // Be permissive about the received offset.\n    offset = Math.min(Math.max(offset, 0), nodeSize(node));\n\n    if (full) {\n        // Put the cursor in deepest inline node around the given position if\n        // possible.\n        let el;\n        let elOffset;\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            el = node;\n            elOffset = offset;\n        } else if (node.nodeType === Node.TEXT_NODE) {\n            if (offset === 0) {\n                el = node.parentNode;\n                elOffset = childNodeIndex(node);\n            } else if (offset === node.length) {\n                el = node.parentNode;\n                elOffset = childNodeIndex(node) + 1;\n            }\n        }\n        if (el) {\n            const leftInlineNode = leftLeafOnlyInScopeNotBlockEditablePath(el, elOffset).next().value;\n            let leftVisibleEmpty = false;\n            if (leftInlineNode) {\n                leftVisibleEmpty =\n                    isSelfClosingElement(leftInlineNode) ||\n                    !closestElement(leftInlineNode).isContentEditable;\n                [node, offset] = leftVisibleEmpty\n                    ? rightPos(leftInlineNode)\n                    : endPos(leftInlineNode);\n            }\n            if (!leftInlineNode || leftVisibleEmpty) {\n                const rightInlineNode = rightLeafOnlyInScopeNotBlockEditablePath(el, elOffset).next().value;\n                if (rightInlineNode) {\n                    const closest = closestElement(rightInlineNode);\n                    const rightVisibleEmpty =\n                        isSelfClosingElement(rightInlineNode) ||\n                        !closest ||\n                        !closest.isContentEditable;\n                    if (!(leftVisibleEmpty && rightVisibleEmpty)) {\n                        [node, offset] = rightVisibleEmpty\n                            ? leftPos(rightInlineNode)\n                            : startPos(rightInlineNode);\n                    }\n                }\n            }\n        }\n    }\n\n    const prevNode = node.nodeType === Node.ELEMENT_NODE && node.childNodes[offset - 1];\n    if (prevNode && prevNode.nodeName === 'BR' && isFakeLineBreak(prevNode)) {\n        // If trying to put the cursor on the right of a fake line break, put\n        // it before instead.\n        offset--;\n    }\n\n    return [node, offset];\n}\n/**\n * Guarantee that the focus is on element or one of its children.\n *\n * A simple call to element.focus will change the editable context\n * if one of the parents of the current activeElement is not editable,\n * and the caret position will not be preserved, even if activeElement is\n * one of the subchildren of element. This is why the (re)focus is\n * only called when the current activeElement is not one of the\n * (sub)children of element.\n *\n * @param {Element} element should have the focus or a child with the focus\n */\n export function ensureFocus(element) {\n    const activeElement = element.ownerDocument.activeElement;\n    if (activeElement !== element && (!element.contains(activeElement) || !activeElement.isContentEditable)) {\n        element.focus();\n    }\n}\n/**\n * @param {Node} anchorNode\n * @param {number} anchorOffset\n * @param {Node} focusNode\n * @param {number} focusOffset\n * @param {boolean} [normalize=true]\n * @returns {?Array.<Node, number}\n */\nexport function setSelection(\n    anchorNode,\n    anchorOffset,\n    focusNode = anchorNode,\n    focusOffset = anchorOffset,\n    normalize = true,\n) {\n    if (\n        !anchorNode ||\n        !anchorNode.parentElement ||\n        !anchorNode.parentElement.closest('body') ||\n        !focusNode ||\n        !focusNode.parentElement ||\n        !focusNode.parentElement.closest('body')\n    ) {\n        return null;\n    }\n    const document = anchorNode.ownerDocument;\n\n    const seemsCollapsed = anchorNode === focusNode && anchorOffset === focusOffset;\n    [anchorNode, anchorOffset] = getNormalizedCursorPosition(anchorNode, anchorOffset, normalize);\n    [focusNode, focusOffset] = seemsCollapsed\n        ? [anchorNode, anchorOffset]\n        : getNormalizedCursorPosition(focusNode, focusOffset, normalize);\n\n    const direction = getCursorDirection(anchorNode, anchorOffset, focusNode, focusOffset);\n    const sel = document.getSelection();\n    if (!sel) {\n        return null;\n    }\n    try {\n        const range = new Range();\n        if (direction === DIRECTIONS.RIGHT) {\n            range.setStart(anchorNode, anchorOffset);\n            range.collapse(true);\n        } else {\n            range.setEnd(anchorNode, anchorOffset);\n            range.collapse(false);\n        }\n        sel.removeAllRanges();\n        sel.addRange(range);\n        sel.extend(focusNode, focusOffset);\n    } catch (e) {\n        // Firefox throws NS_ERROR_FAILURE when setting selection on element\n        // with contentEditable=false for no valid reason since non-editable\n        // content are selectable by the user anyway.\n        if (e.name !== 'NS_ERROR_FAILURE') {\n            throw e;\n        }\n    }\n\n    return [anchorNode, anchorOffset, focusNode, focusOffset];\n}\n/**\n * @param {Node} node\n * @param {boolean} [normalize=true]\n * @returns {?Array.<Node, number}\n */\nexport function setCursorStart(node, normalize = true) {\n    const pos = startPos(node);\n    return setSelection(...pos, ...pos, normalize);\n}\n/**\n * @param {Node} node\n * @param {boolean} [normalize=true]\n * @returns {?Array.<Node, number}\n */\nexport function setCursorEnd(node, normalize = true) {\n    const pos = endPos(node);\n    return setSelection(...pos, ...pos, normalize);\n}\n/**\n * From selection position, checks if it is left-to-right or right-to-left.\n *\n * @param {Node} anchorNode\n * @param {number} anchorOffset\n * @param {Node} focusNode\n * @param {number} focusOffset\n * @returns {boolean} the direction of the current range if the selection not is collapsed | false\n */\nexport function getCursorDirection(anchorNode, anchorOffset, focusNode, focusOffset) {\n    if (anchorNode === focusNode) {\n        if (anchorOffset === focusOffset) return false;\n        return anchorOffset < focusOffset ? DIRECTIONS.RIGHT : DIRECTIONS.LEFT;\n    }\n    return anchorNode.compareDocumentPosition(focusNode) & Node.DOCUMENT_POSITION_FOLLOWING\n        ? DIRECTIONS.RIGHT\n        : DIRECTIONS.LEFT;\n}\n/**\n * Returns an array containing all the nodes traversed when walking the\n * selection.\n *\n * @param {Node} editable\n * @returns {Node[]}\n */\nexport function getTraversedNodes(editable, range = getDeepRange(editable)) {\n    const selectedTableCells = editable.querySelectorAll('.o_selected_td');\n    const document = editable.ownerDocument;\n    if (!range) return [];\n    const iterator = document.createNodeIterator(range.commonAncestorContainer);\n    let node;\n    do {\n        node = iterator.nextNode();\n    } while (node && node !== range.startContainer && !(selectedTableCells.length && node === selectedTableCells[0]));\n    const traversedNodes = new Set([node, ...descendants(node)]);\n    while (node && node !== range.endContainer) {\n        node = iterator.nextNode();\n        if (node) {\n            const selectedTable = closestElement(node, '.o_selected_table');\n            if (selectedTable) {\n                for (const selectedTd of selectedTable.querySelectorAll('.o_selected_td')) {\n                    traversedNodes.add(selectedTd);\n                    descendants(selectedTd).forEach(descendant => traversedNodes.add(descendant));\n                }\n            } else {\n                traversedNodes.add(node);\n            }\n        }\n    }\n    return [...traversedNodes];\n}\n/**\n * Returns an array containing all the nodes fully contained in the selection.\n *\n * @param {Node} editable\n * @returns {Node[]}\n */\nexport function getSelectedNodes(editable) {\n    const selectedTableCells = editable.querySelectorAll('.o_selected_td');\n    const document = editable.ownerDocument;\n    const sel = document.getSelection();\n    if (!sel.rangeCount && !selectedTableCells.length) {\n        return [];\n    }\n    const range = sel.getRangeAt(0);\n    return [...new Set(getTraversedNodes(editable).flatMap(\n        node => {\n            const td = closestElement(node, '.o_selected_td');\n            if (td) {\n                return descendants(td);\n            } else if (range.isPointInRange(node, 0) && range.isPointInRange(node, nodeSize(node))) {\n                return node;\n            } else {\n                return [];\n            }\n        },\n    ))];\n}\n\n/**\n * Returns the current range (if any), adapted to target the deepest\n * descendants.\n *\n * @param {Node} editable\n * @param {object} [options]\n * @param {Selection} [options.range] the range to use.\n * @param {Selection} [options.sel] the selection to use.\n * @param {boolean} [options.splitText] split the targeted text nodes at offset.\n * @param {boolean} [options.select] select the new range if it changed (via splitText).\n * @param {boolean} [options.correctTripleClick] adapt the range if it was a triple click.\n * @returns {Range}\n */\nexport function getDeepRange(editable, { range, sel, splitText, select, correctTripleClick } = {}) {\n    sel = sel || editable.parentElement && editable.ownerDocument.getSelection();\n    if (\n        sel &&\n        sel.isCollapsed &&\n        sel.anchorNode &&\n        (sel.anchorNode.nodeName === \"BR\" || (sel.anchorNode.nodeType === Node.TEXT_NODE && sel.anchorNode.textContent === ''))\n    ) {\n        setCursorStart(sel.anchorNode.parentElement, false);\n    }\n    range = range ? range.cloneRange() : sel && sel.rangeCount && sel.getRangeAt(0).cloneRange();\n    if (!range) return;\n    let start = range.startContainer;\n    let startOffset = range.startOffset;\n    let end = range.endContainer;\n    let endOffset = range.endOffset;\n\n    const isBackwards =\n        !range.collapsed && start === sel.focusNode && startOffset === sel.focusOffset;\n\n    // Target the deepest descendant of the range nodes.\n    [start, startOffset] = getDeepestPosition(start, startOffset);\n    [end, endOffset] = getDeepestPosition(end, endOffset);\n\n    // Split text nodes if that was requested.\n    if (splitText) {\n        const isInSingleContainer = start === end;\n        if (\n            end.nodeType === Node.TEXT_NODE &&\n            endOffset !== 0 &&\n            endOffset !== end.textContent.length\n        ) {\n            const endParent = end.parentNode;\n            const splitOffset = splitTextNode(end, endOffset);\n            end = endParent.childNodes[splitOffset - 1] || endParent.firstChild;\n            if (isInSingleContainer) {\n                start = end;\n            }\n            endOffset = end.textContent.length;\n        }\n        if (\n            start.nodeType === Node.TEXT_NODE &&\n            startOffset !== 0 &&\n            startOffset !== start.textContent.length\n        ) {\n            splitTextNode(start, startOffset);\n            startOffset = 0;\n            if (isInSingleContainer) {\n                endOffset = start.textContent.length;\n            }\n        }\n    }\n    // A selection spanning multiple nodes and ending at position 0 of a node,\n    // like the one resulting from a triple click, is corrected so that it ends\n    // at the last position of the previous node instead.\n    const endLeaf = firstLeaf(end);\n    const beforeEnd = endLeaf.previousSibling;\n    if (\n        correctTripleClick &&\n        !endOffset &&\n        (start !== end || startOffset !== endOffset) &&\n        (!beforeEnd || (beforeEnd.nodeType === Node.TEXT_NODE && !isVisibleTextNode(beforeEnd) && !isZWS(beforeEnd)))\n    ) {\n        const previous = previousLeaf(endLeaf, editable, true);\n        if (previous && closestElement(previous).isContentEditable) {\n            [end, endOffset] = [previous, nodeSize(previous)];\n        }\n    }\n\n    if (select) {\n        if (isBackwards) {\n            [start, end, startOffset, endOffset] = [end, start, endOffset, startOffset];\n            range.setEnd(start, startOffset);\n            range.collapse(false);\n        } else {\n            range.setStart(start, startOffset);\n            range.collapse(true);\n        }\n        sel.removeAllRanges();\n        sel.addRange(range);\n        try {\n            sel.extend(end, endOffset);\n        } catch {\n            // Firefox yells not happy when setting selection on elem with contentEditable=false.\n        }\n        range = sel.getRangeAt(0);\n    } else {\n        range.setStart(start, startOffset);\n        range.setEnd(end, endOffset);\n    }\n    return range;\n}\n\nexport function getDeepestPosition(node, offset) {\n    let direction = DIRECTIONS.RIGHT;\n    let next = node;\n    while (next) {\n        if ((isVisible(next) || isZWS(next)) && (!isBlock(next) || next.isContentEditable)) {\n            // Valid node: update position then try to go deeper.\n            if (next !== node) {\n                [node, offset] = [next, direction ? 0 : nodeSize(next)];\n            }\n            // First switch direction to left if offset is at the end.\n            direction = offset < node.childNodes.length;\n            next = node.childNodes[direction ? offset : offset - 1];\n        } else if (direction && next.nextSibling) {\n            // Invalid node: skip to next sibling (without crossing blocks).\n            next = next.nextSibling;\n        } else {\n            // Invalid node: skip to previous sibling (without crossing blocks).\n            direction = DIRECTIONS.LEFT;\n            next = !isBlock(next.previousSibling) && next.previousSibling;\n        }\n        // Avoid too-deep ranges inside self-closing elements like [BR, 0].\n        next = !isSelfClosingElement(next) && next;\n    }\n    return [node, offset];\n}\n\nexport function getCursors(document) {\n    const sel = document.getSelection();\n    if (\n        getCursorDirection(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) ===\n        DIRECTIONS.LEFT\n    )\n        return [\n            [sel.focusNode, sel.focusOffset],\n            [sel.anchorNode, sel.anchorOffset],\n        ];\n    return [\n        [sel.anchorNode, sel.anchorOffset],\n        [sel.focusNode, sel.focusOffset],\n    ];\n}\n\nexport function preserveCursor(document) {\n    const sel = document.getSelection();\n    const cursorPos = [sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset];\n    return replace => {\n        replace = replace || new Map();\n        cursorPos[0] = replace.get(cursorPos[0]) || cursorPos[0];\n        cursorPos[2] = replace.get(cursorPos[2]) || cursorPos[2];\n        return setSelection(...cursorPos, false);\n    };\n}\n\n/**\n * Check if the selection starts inside given selector. This function can be\n * used as the `isDisabled` property of a command of the PowerBox to disable\n * a command in the given selectors.\n * @param {string}: comma separated string with all the desired selectors\n * @returns {boolean} true selector is within one of the selector\n * (if the command should be filtered)\n */\nexport function isSelectionInSelectors(selector) {\n    let anchor = document.getSelection().anchorNode;\n    if (anchor && anchor.nodeType && anchor.nodeType !== Node.ELEMENT_NODE) {\n        anchor = anchor.parentElement;\n    }\n    if (anchor && closestElement(anchor, selector)) {\n        return true;\n    }\n    return false;\n}\n\nexport function getOffsetAndCharSize(nodeValue, offset, direction) {\n    //We get the correct offset which corresponds to this offset\n    // If direction is left it means we are coming from the right and\n    // we want to get the end offset of the first element to the left\n    // Example with LEFT direction:\n    // <p>a \\uD83D[offset]\\uDE0D b</p> -> <p>a \\uD83D\\uDE0D[offset] b</p> and\n    // size = 2 so delete backward will delete the whole emoji.\n    // Example with Right direction:\n    // <p>a \\uD83D[offset]\\uDE0D b</p> -> <p>a [offset]\\uD83D\\uDE0D b</p> and\n    // size = 2 so delete forward will delete the whole emoji.\n    const splittedNodeValue = [...nodeValue];\n    let charSize = 1;\n    let newOffset = offset;\n    let currentSize = 0;\n    for (const item of splittedNodeValue) {\n        currentSize += item.length;\n        if (currentSize >= offset) {\n            newOffset = direction == DIRECTIONS.LEFT ? currentSize : currentSize - item.length;\n            charSize = item.length;\n            break;\n        }\n    }\n    return [newOffset, charSize];\n}\n\n//------------------------------------------------------------------------------\n// Format utils\n//------------------------------------------------------------------------------\n\nconst formatsSpecs = {\n    italic: {\n        tagName: 'em',\n        isFormatted: isItalic,\n        isTag: (node) => ['EM', 'I'].includes(node.tagName),\n        hasStyle: (node) => Boolean(node.style && node.style['font-style']),\n        addStyle: (node) => node.style['font-style'] = 'italic',\n        addNeutralStyle: (node) => node.style['font-style'] = 'normal',\n        removeStyle: (node) => removeStyle(node, 'font-style'),\n    },\n    bold: {\n        tagName: 'strong',\n        isFormatted: isBold,\n        isTag: (node) => ['STRONG', 'B'].includes(node.tagName),\n        hasStyle: (node) => Boolean(node.style && node.style['font-weight']),\n        addStyle: (node) => node.style['font-weight'] = 'bolder',\n        addNeutralStyle: (node) => {\n            node.style['font-weight'] = 'normal'\n        },\n        removeStyle: (node) => removeStyle(node, 'font-weight'),\n    },\n    underline: {\n        tagName: 'u',\n        isFormatted: isUnderline,\n        isTag: (node) => node.tagName === 'U',\n        hasStyle: (node) => node.style && node.style['text-decoration-line'].includes('underline'),\n        addStyle: (node) => node.style['text-decoration-line'] += ' underline',\n        removeStyle: (node) => removeStyle(node, 'text-decoration-line', 'underline'),\n    },\n    strikeThrough: {\n        tagName: 's',\n        isFormatted: isStrikeThrough,\n        isTag: (node) => node.tagName === 'S',\n        hasStyle: (node) => node.style && node.style['text-decoration-line'].includes('line-through'),\n        addStyle: (node) => node.style['text-decoration-line'] += ' line-through',\n        removeStyle: (node) => removeStyle(node, 'text-decoration-line', 'line-through'),\n    },\n    fontSize: {\n        isFormatted: isFontSize,\n        hasStyle: (node) => node.style && node.style['font-size'],\n        addStyle: (node, props) => {\n            node.style['font-size'] = props.size;\n            node.classList.remove(...FONT_SIZE_CLASSES);\n        },\n        removeStyle: (node) => removeStyle(node, 'font-size'),\n    },\n    setFontSizeClassName: {\n        isFormatted: hasClass,\n        hasStyle: (node, props) => FONT_SIZE_CLASSES\n            .find(cls => node.classList.contains(cls)),\n        addStyle: (node, props) => node.classList.add(props.className),\n        removeStyle: (node) => {\n            node.classList.remove(...FONT_SIZE_CLASSES, ...TEXT_STYLE_CLASSES);\n            if (node.classList.length === 0) {\n                node.removeAttribute(\"class\");\n            }\n        },\n    },\n    switchDirection: {\n        isFormatted: isDirectionSwitched,\n    }\n}\n\nconst removeStyle = (node, styleName, item) => {\n    if (item) {\n        const newStyle = node.style[styleName].split(' ').filter(x => x !== item).join(' ');\n        node.style[styleName] = newStyle || null;\n    } else {\n        node.style[styleName] = null;\n    }\n    if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n    }\n};\nconst getOrCreateSpan = (node, ancestors) => {\n    const span = ancestors.find((element) => element.tagName === 'SPAN' && element.isConnected);\n    if (span) {\n        return span;\n    } else {\n        const span = document.createElement('span');\n        node.after(span);\n        span.append(node);\n        return span;\n    }\n}\nconst removeFormat = (node, formatSpec) => {\n    node = closestElement(node);\n    if (formatSpec.hasStyle(node)) {\n        formatSpec.removeStyle(node);\n        if (['SPAN', 'FONT'].includes(node.tagName) && !node.getAttributeNames().length) {\n            return unwrapContents(node);\n        }\n    }\n\n    if (formatSpec.isTag && formatSpec.isTag(node)) {\n        const attributesNames = node.getAttributeNames().filter((name)=> {\n            return name !== 'data-oe-zws-empty-inline';\n        });\n        if (attributesNames.length) {\n            // Change tag name\n            const newNode = document.createElement('span');\n            while (node.firstChild) {\n                newNode.appendChild(node.firstChild);\n            }\n            for (let index = node.attributes.length - 1; index >= 0; --index) {\n                newNode.attributes.setNamedItem(node.attributes[index].cloneNode());\n            }\n            node.parentNode.replaceChild(newNode, node);\n        } else {\n            unwrapContents(node);\n        }\n    }\n}\n\nexport const formatSelection = (editor, formatName, {applyStyle, formatProps} = {}) => {\n    const selection = editor.document.getSelection();\n    let direction\n    let wasCollapsed;\n    if (editor.editable.querySelector('.o_selected_td')) {\n        direction = DIRECTIONS.RIGHT;\n    } else {\n        if (!selection.rangeCount) return;\n        wasCollapsed = selection.getRangeAt(0).collapsed;\n\n        direction = getCursorDirection(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    }\n    getDeepRange(editor.editable, { splitText: true, select: true, correctTripleClick: true });\n\n    if (typeof applyStyle === 'undefined') {\n        applyStyle = !isSelectionFormat(editor.editable, formatName);\n    }\n\n    let zws;\n    if (wasCollapsed) {\n        if (selection.anchorNode.nodeType === Node.TEXT_NODE && selection.anchorNode.textContent === '\\u200b') {\n            zws = selection.anchorNode;\n            selection.getRangeAt(0).selectNode(zws);\n        } else {\n            zws = insertAndSelectZws(selection);\n        }\n        getDeepRange(editor.editable, { splitText: true, select: true, correctTripleClick: true });\n    }\n\n    // Get selected nodes within td to handle non-p elements like h1, h2...\n    // Targeting <br> to ensure span stays inside its corresponding block node.\n    const selectedNodesInTds = [...editor.editable.querySelectorAll('.o_selected_td')]\n        .map(node => closestElement(node).querySelector('br'));\n    const selectedNodes = getSelectedNodes(editor.editable)\n        .filter(n => n.nodeType === Node.TEXT_NODE && closestElement(n).isContentEditable && (isVisibleTextNode(n) || isZWS(n)));\n    const selectedTextNodes = selectedNodes.length ? selectedNodes : selectedNodesInTds;\n\n    const selectedFieldNodes = new Set(getSelectedNodes(editor.editable)\n            .map(n =>closestElement(n, \"*[t-field],*[t-out],*[t-esc]\"))\n            .filter(Boolean));\n\n    const formatSpec = formatsSpecs[formatName];\n    for (const selectedTextNode of selectedTextNodes) {\n        const inlineAncestors = [];\n        let currentNode = selectedTextNode;\n        let parentNode = selectedTextNode.parentElement;\n\n        // Remove the format on all inline ancestors until a block or an element\n        // with a class that is not related to font size (in case the formatting\n        // comes from the class).\n        while (parentNode && (!isBlock(parentNode) && (parentNode.classList.length === 0 ||\n                [...parentNode.classList].every(cls => FONT_SIZE_CLASSES.includes(cls))))) {\n            const isUselessZws = parentNode.tagName === 'SPAN' &&\n                parentNode.hasAttribute('data-oe-zws-empty-inline') &&\n                parentNode.getAttributeNames().length === 1;\n\n            if (isUselessZws) {\n                unwrapContents(parentNode);\n            } else {\n                const newLastAncestorInlineFormat = splitAroundUntil(currentNode, parentNode);\n                removeFormat(newLastAncestorInlineFormat, formatSpec);\n                if (newLastAncestorInlineFormat.isConnected) {\n                    inlineAncestors.push(newLastAncestorInlineFormat);\n                    currentNode = newLastAncestorInlineFormat;\n                }\n            }\n\n            parentNode = currentNode.parentElement;\n        }\n\n        const firstBlockOrClassHasFormat = formatSpec.isFormatted(parentNode, formatProps);\n        if (firstBlockOrClassHasFormat && !applyStyle) {\n            formatSpec.addNeutralStyle && formatSpec.addNeutralStyle(getOrCreateSpan(selectedTextNode, inlineAncestors));\n        } else if (!firstBlockOrClassHasFormat && applyStyle) {\n            const tag = formatSpec.tagName && document.createElement(formatSpec.tagName);\n            if (tag) {\n                selectedTextNode.after(tag);\n                tag.append(selectedTextNode);\n\n                if (!formatSpec.isFormatted(tag, formatProps)) {\n                    tag.after(selectedTextNode);\n                    tag.remove();\n                    formatSpec.addStyle(getOrCreateSpan(selectedTextNode, inlineAncestors), formatProps);\n                }\n            } else if (formatName !== 'fontSize' || formatProps.size !== undefined) {\n                formatSpec.addStyle(getOrCreateSpan(selectedTextNode, inlineAncestors), formatProps);\n            }\n        }\n    }\n\n    for (const selectedFieldNode of selectedFieldNodes) {\n        if (applyStyle) {\n            formatSpec.addStyle(selectedFieldNode, formatProps);\n        } else {\n            formatSpec.removeStyle(selectedFieldNode);\n        }\n    }\n\n    if (zws) {\n        const siblings = [...zws.parentElement.childNodes];\n        if (\n            !isBlock(zws.parentElement) &&\n            selectedTextNodes.includes(siblings[0]) &&\n            selectedTextNodes.includes(siblings[siblings.length - 1])\n        ) {\n            zws.parentElement.setAttribute('data-oe-zws-empty-inline', '');\n        } else {\n            const span = document.createElement('span');\n            span.setAttribute('data-oe-zws-empty-inline', '');\n            zws.before(span);\n            span.append(zws);\n        }\n    }\n\n    if (selectedTextNodes[0] && selectedTextNodes[0].textContent === '\\u200B') {\n        setSelection(selectedTextNodes[0], 0);\n    } else if (selectedTextNodes.length) {\n        const firstNode = selectedTextNodes[0];\n        const lastNode = selectedTextNodes[selectedTextNodes.length - 1];\n        if (direction === DIRECTIONS.RIGHT) {\n            setSelection(firstNode, 0, lastNode, lastNode.length, false);\n        } else {\n            setSelection(lastNode, lastNode.length, firstNode, 0, false);\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// DOM Info utils\n//------------------------------------------------------------------------------\n\n/**\n * The following is a complete list of all HTML \"block-level\" elements.\n *\n * Source:\n * https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n *\n **/\nconst blockTagNames = [\n    'ADDRESS',\n    'ARTICLE',\n    'ASIDE',\n    'BLOCKQUOTE',\n    'DETAILS',\n    'DIALOG',\n    'DD',\n    'DIV',\n    'DL',\n    'DT',\n    'FIELDSET',\n    'FIGCAPTION',\n    'FIGURE',\n    'FOOTER',\n    'FORM',\n    'H1',\n    'H2',\n    'H3',\n    'H4',\n    'H5',\n    'H6',\n    'HEADER',\n    'HGROUP',\n    'HR',\n    'LI',\n    'MAIN',\n    'NAV',\n    'OL',\n    'P',\n    'PRE',\n    'SECTION',\n    'TABLE',\n    'UL',\n    // The following elements are not in the W3C list, for some reason.\n    'SELECT',\n    'OPTION',\n    'TR',\n    'TD',\n    'TBODY',\n    'THEAD',\n    'TH',\n];\nconst computedStyles = new WeakMap();\n/**\n * Return true if the given node is a block-level element, false otherwise.\n *\n * @param node\n */\nexport function isBlock(node) {\n    if (!node || node.nodeType !== Node.ELEMENT_NODE) {\n        return false;\n    }\n    const tagName = node.nodeName.toUpperCase();\n    // Every custom jw-* node will be considered as blocks.\n    if (\n        tagName.startsWith('JW-') ||\n        (tagName === 'T' &&\n            node.getAttribute('t-esc') === null &&\n            node.getAttribute('t-out') === null &&\n            node.getAttribute('t-raw') === null)\n    ) {\n        return true;\n    }\n    if (tagName === 'BR') {\n        // A <br> is always inline but getComputedStyle(br).display mistakenly\n        // returns 'block' if its parent is display:flex (at least on Chrome and\n        // Firefox (Linux)). Browsers normally support setting a <br>'s display\n        // property to 'none' but any other change is not supported. Therefore\n        // it is safe to simply declare that a <br> is never supposed to be a\n        // block.\n        return false;\n    }\n    // The node might not be in the DOM, in which case it has no CSS values.\n    if (!node.isConnected) {\n        return blockTagNames.includes(tagName);\n    }\n    // We won't call `getComputedStyle` more than once per node.\n    let style = computedStyles.get(node);\n    if (!style) {\n        style = node.ownerDocument.defaultView.getComputedStyle(node);\n        computedStyles.set(node, style);\n    }\n    if (style.display) {\n        return !style.display.includes('inline') && style.display !== 'contents';\n    }\n    return blockTagNames.includes(tagName);\n}\n\n/**\n * Return true if the given node appears bold. The node is considered to appear\n * bold if its font weight is bigger than 500 (eg.: Heading 1), or if its font\n * weight is bigger than that of its closest block.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isBold(node) {\n    const fontWeight = +getComputedStyle(closestElement(node)).fontWeight;\n    return fontWeight > 500 || fontWeight > +getComputedStyle(closestBlock(node)).fontWeight;\n}\n/**\n * Return true if the given node appears italic.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isItalic(node) {\n    return getComputedStyle(closestElement(node)).fontStyle === 'italic';\n}\n/**\n * Return true if the given node appears underlined.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isUnderline(node) {\n    let parent = closestElement(node);\n    while (parent) {\n        if (getComputedStyle(parent).textDecorationLine.includes('underline')) {\n            return true;\n        }\n        parent = parent.parentElement;\n    }\n    return false;\n}\n/**\n * Return true if the given node appears struck through.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isStrikeThrough(node) {\n    let parent = closestElement(node);\n    while (parent) {\n        if (getComputedStyle(parent).textDecorationLine.includes('line-through')) {\n            return true;\n        }\n        parent = parent.parentElement;\n    }\n    return false;\n}\n/**\n * Return true if the given node font-size is equal to `props.size`.\n *\n * @param {Object} props\n * @param {Node} props.node A node to compare the font-size against.\n * @param {String} props.size The font-size value of the node that will be\n *     checked against.\n * @returns {boolean}\n */\nexport function isFontSize(node, props) {\n    const element = closestElement(node);\n    return getComputedStyle(element)['font-size'] === props.size;\n}\n/**\n * Return true if the given node classlist contains `props.className`.\n *\n * @param {Object} props\n * @param {Node} node A node to compare the font-size against.\n * @param {String} props.className The name of the class.\n * @returns {boolean}\n */\nexport function hasClass(node, props) {\n    const element = closestElement(node);\n    return element.classList.contains(props.className);\n}\n/**\n * Return true if the given node appears in a different direction than that of\n * the editable ('ltr' or 'rtl').\n *\n * Note: The direction of the editable is set on its \"dir\" attribute, to the\n * value of the \"direction\" option on instantiation of the editor.\n *\n * @param {Node} node\n * @param {Element} editable\n * @returns {boolean}\n */\n export function isDirectionSwitched(node, editable) {\n    const defaultDirection = editable.getAttribute('dir');\n    return getComputedStyle(closestElement(node)).direction !== defaultDirection;\n}\n/**\n * Return true if the current selection on the editable appears as the given\n * format. The selection is considered to appear as that format if every text\n * node in it appears as that format.\n *\n * @param {Element} editable\n * @param {String} format 'bold'|'italic'|'underline'|'strikeThrough'|'switchDirection'\n * @returns {boolean}\n */\nexport function isSelectionFormat(editable, format) {\n    const selectedNodes = getTraversedNodes(editable)\n        .filter(n => n.nodeType === Node.TEXT_NODE);\n    const isFormatted = formatsSpecs[format].isFormatted;\n    return selectedNodes.length && selectedNodes.every(n => isFormatted(n, editable));\n}\n\nexport function isUnbreakable(node) {\n    if (!node || node.nodeType === Node.TEXT_NODE) {\n        return false;\n    }\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return true;\n    }\n    return (\n        isUnremovable(node) || // An unremovable node is always unbreakable.\n        ['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR', 'TH', 'TD', 'SECTION', 'DIV'].includes(node.tagName) ||\n        node.hasAttribute('t') ||\n        (node.nodeType === Node.ELEMENT_NODE &&\n            (node.nodeName === 'T' ||\n                node.getAttribute('t-if') ||\n                node.getAttribute('t-esc') ||\n                node.getAttribute('t-elif') ||\n                node.getAttribute('t-else') ||\n                node.getAttribute('t-foreach') ||\n                node.getAttribute('t-value') ||\n                node.getAttribute('t-out') ||\n                node.getAttribute('t-raw')) ||\n                node.getAttribute('t-field')) ||\n        node.classList.contains('oe_unbreakable')\n    );\n}\n\nexport function isUnremovable(node) {\n    return (\n        (node.nodeType !== Node.ELEMENT_NODE && node.nodeType !== Node.TEXT_NODE) ||\n        node.oid === 'root' ||\n        (node.nodeType === Node.ELEMENT_NODE &&\n            (node.classList.contains('o_editable') || node.getAttribute('t-set') || node.getAttribute('t-call'))) ||\n        (node.classList && node.classList.contains('oe_unremovable')) ||\n        (node.nodeName === 'SPAN' && node.parentElement && node.parentElement.getAttribute('data-oe-type') === 'monetary') ||\n        (node.ownerDocument && node.ownerDocument.defaultWindow && !ancestors(node).find(ancestor => ancestor.oid === 'root')) // Node is in DOM but not in editable.\n    );\n}\n\nexport function containsUnbreakable(node) {\n    if (!node) {\n        return false;\n    }\n    return isUnbreakable(node) || containsUnbreakable(node.firstChild);\n}\n// TODO rename this function in master: it also handles Odoo icons, not only\n// font awesome ones. Also maybe just use the ICON_SELECTOR and `matches`?\nconst iconTags = ['I', 'SPAN'];\nconst iconClasses = ['fa', 'fab', 'fad', 'far', 'oi'];\nexport function isFontAwesome(node) {\n    // See ICON_SELECTOR\n    return (\n        node &&\n        iconTags.includes(node.nodeName) &&\n        iconClasses.some(cls => node.classList.contains(cls))\n    );\n}\nexport const ICON_SELECTOR = iconTags.map(tag => {\n    return iconClasses.map(cls => {\n        return `${tag}.${cls}`;\n    }).join(', ');\n}).join(', ');\n\nexport function isZWS(node) {\n    return (\n        node &&\n        node.textContent === '\\u200B'\n    );\n}\nexport function isEditorTab(node) {\n    return (\n        node &&\n        (node.nodeName === 'SPAN') &&\n        node.classList.contains('oe-tabs')\n    );\n}\nexport function isMediaElement(node) {\n    return (\n        isFontAwesome(node) ||\n        (node.classList &&\n            (node.classList.contains('o_image') || node.classList.contains('media_iframe_video')))\n    );\n}\n/**\n * A \"protected\" node will have its mutations filtered and not be registered\n * in an history step. Some editor features like selection handling, command\n * hint, toolbar, tooltip, etc. are also disabled. Protected roots have their\n * data-oe-protected attribute set to either \"\" or \"true\". If the closest parent\n * with a data-oe-protected attribute has the value \"false\", it is not\n * protected. Unknown values are ignored.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isProtected(node) {\n    const closestProtectedElement = closestElement(node, '[data-oe-protected]');\n    if (closestProtectedElement) {\n        return [\"\", \"true\"].includes(closestProtectedElement.dataset.oeProtected);\n    }\n    return false;\n}\n\n// https://developer.mozilla.org/en-US/docs/Glossary/Void_element\nconst VOID_ELEMENT_NAMES = ['AREA', 'BASE', 'BR', 'COL', 'EMBED', 'HR', 'IMG',\n    'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR'];\n\nexport function isArtificialVoidElement(node) {\n    return isMediaElement(node) || node.nodeName === 'HR';\n}\n\nexport function isNotAllowedContent(node) {\n    return isArtificialVoidElement(node) || VOID_ELEMENT_NAMES.includes(node.nodeName);\n}\n\nexport function containsUnremovable(node) {\n    if (!node) {\n        return false;\n    }\n    return isUnremovable(node) || containsUnremovable(node.firstChild);\n}\n\nexport function getInSelection(document, selector) {\n    const selection = document.getSelection();\n    const range = selection && !!selection.rangeCount && selection.getRangeAt(0);\n    if (range) {\n        const selectorInStartAncestors = closestElement(range.startContainer, selector);\n        if (selectorInStartAncestors) {\n            return selectorInStartAncestors;\n        } else {\n            const commonElementAncestor = closestElement(range.commonAncestorContainer);\n            return commonElementAncestor && [...commonElementAncestor.querySelectorAll(selector)].find(\n                node => range.intersectsNode(node),\n            );\n        }\n    }\n}\n\n/**\n * Get the index of the given table row/cell.\n *\n * @private\n * @param {HTMLTableRowElement|HTMLTableCellElement} trOrTd\n * @returns {number}\n */\nexport function getRowIndex(trOrTd) {\n    const tr = closestElement(trOrTd, 'tr');\n    const trParent = tr && tr.parentElement;\n    if (!trParent) {\n        return -1;\n    }\n    const trSiblings = [...trParent.children].filter(child => child.nodeName === 'TR');\n    return trSiblings.findIndex(child => child === tr);\n}\n\n/**\n * Get the index of the given table cell.\n *\n * @private\n * @param {HTMLTableCellElement} td\n * @returns {number}\n */\nexport function getColumnIndex(td) {\n    const tdParent = td.parentElement;\n    if (!tdParent) {\n        return -1;\n    }\n    const tdSiblings = [...tdParent.children].filter(child => child.nodeName === 'TD' || child.nodeName === 'TH');\n    return tdSiblings.findIndex(child => child === td);\n}\n\n// This is a list of \"paragraph-related elements\", defined as elements that\n// behave like paragraphs.\nexport const paragraphRelatedElements = [\n    'P',\n    'H1',\n    'H2',\n    'H3',\n    'H4',\n    'H5',\n    'H6',\n    'PRE',\n    'BLOCKQUOTE',\n];\n\n/**\n * Return true if the given node allows \"paragraph-related elements\".\n *\n * @see paragraphRelatedElements\n * @param {Node} node\n * @returns {boolean}\n */\nexport function allowsParagraphRelatedElements(node) {\n    return isBlock(node) && !paragraphRelatedElements.includes(node.nodeName);\n}\n\n/**\n * Take a node and unwrap all of its block contents recursively. All blocks\n * (except for firstChilds) are preceded by a <br> in order to preserve the line\n * breaks.\n *\n * @param {Node} node\n */\nexport function makeContentsInline(node) {\n    let childIndex = 0;\n    for (const child of node.childNodes) {\n        if (isBlock(child)) {\n            if (childIndex && paragraphRelatedElements.includes(child.nodeName)) {\n                child.before(document.createElement('br'));\n            }\n            for (const grandChild of child.childNodes) {\n                child.before(grandChild);\n                makeContentsInline(grandChild);\n            }\n            child.remove();\n        }\n        childIndex += 1;\n    }\n}\n\n// optimize: use the parent Oid to speed up detection\nexport function getOuid(node, optimize = false) {\n    while (node && !isUnbreakable(node)) {\n        if (node.ouid && optimize) return node.ouid;\n        node = node.parentNode;\n    }\n    return node && node.oid;\n}\n/**\n * Returns true if the provided node can suport html content.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isHtmlContentSupported(node) {\n    return !closestElement(node, '[data-oe-model]:not([data-oe-field=\"arch\"]):not([data-oe-type=\"html\"]),[data-oe-translation-id]', true);\n}\n/**\n * Returns whether the given node is a element that could be considered to be\n * removed by itself = self closing tags.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nconst selfClosingElementTags = ['BR', 'IMG', 'INPUT'];\nexport function isSelfClosingElement(node) {\n    return node && selfClosingElementTags.includes(node.nodeName);\n}\n/**\n * Returns true if the given node is in a PRE context for whitespace handling.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isInPre(node) {\n    const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;\n    return (\n        !!element &&\n        (!!element.closest('pre') ||\n            getComputedStyle(element).getPropertyValue('white-space') === 'pre')\n    );\n}\nconst whitespace = `[^\\\\S\\\\u00A0\\\\u0009]`; // for formatting (no \"real\" content) (TODO: 0009 shouldn't be included)\nconst whitespaceRegex = new RegExp(`^${whitespace}*$`);\nexport function isWhitespace(value) {\n    const str = typeof value === 'string' ? value : value.nodeValue;\n    return whitespaceRegex.test(str);\n}\n/**\n * Returns whether removing the given node from the DOM will have a visible\n * effect or not.\n *\n * Note: TODO this is not handling all cases right now, just the ones the\n * caller needs at the moment. For example a space text node between two inlines\n * will always return 'true' while it is sometimes invisible.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isVisible(node) {\n    return !!node && (\n        (node.nodeType === Node.TEXT_NODE && isVisibleTextNode(node)) ||\n        isSelfClosingElement(node) ||\n        hasVisibleContent(node)\n    );\n}\nexport function hasVisibleContent(node) {\n    return [...(node?.childNodes || [])].some(n => isVisible(n));\n}\nconst visibleCharRegex = /[^\\s\\u200b]|[\\u00A0\\u0009]$/; // contains at least a char that is always visible (TODO: 0009 shouldn't be included)\nexport function isVisibleTextNode(testedNode) {\n    if (!testedNode || !testedNode.length || testedNode.nodeType !== Node.TEXT_NODE) {\n        return false;\n    }\n    if (visibleCharRegex.test(testedNode.textContent) || (isInPre(testedNode) && isWhitespace(testedNode))) {\n        return true;\n    }\n    if (testedNode.textContent === '\\u200B') {\n        return false;\n    }\n    // The following assumes node is made entirely of whitespace and is not\n    // preceded of followed by a block.\n    // Find out contiguous preceding and following text nodes\n    let preceding;\n    let following;\n    // Control variable to know whether the current node has been found\n    let foundTestedNode;\n    const currentNodeParentBlock = closestBlock(testedNode);\n    if (!currentNodeParentBlock) {\n        return false;\n    }\n    const nodeIterator = document.createNodeIterator(currentNodeParentBlock);\n    for (let node = nodeIterator.nextNode(); node; node = nodeIterator.nextNode()) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            // If we already found the tested node, the current node is the\n            // contiguous following, and we can stop looping\n            // If the current node is the tested node, mark it as found and\n            // continue.\n            // If we haven't reached the tested node, overwrite the preceding\n            // node.\n            if (foundTestedNode) {\n                following = node;\n                break;\n            } else if (testedNode === node) {\n                foundTestedNode = true;\n            } else {\n                preceding = node;\n            }\n        } else if (isBlock(node)) {\n            // If we found the tested node, then the following node is irrelevant\n            // If we didn't, then the current preceding node is irrelevant\n            if (foundTestedNode) {\n                break;\n            } else {\n                preceding = null;\n            }\n        } else if (foundTestedNode && !isWhitespace(node)) {\n            // <block>space<inline>text</inline></block> -> space is visible\n            following = node;\n            break;\n        }\n    }\n    while (following && !visibleCharRegex.test(following.textContent)) {\n        following = following.nextSibling;\n    }\n    // Missing preceding or following: invisible.\n    // Preceding or following not in the same block as tested node: invisible.\n    if (\n        !(preceding && following) ||\n        currentNodeParentBlock !== closestBlock(preceding) ||\n        currentNodeParentBlock !== closestBlock(following)\n    ) {\n        return false;\n    }\n    // Preceding is whitespace or following is whitespace: invisible\n    return visibleCharRegex.test(preceding.textContent);\n}\n\nexport function parentsGet(node, root = undefined) {\n    const parents = [];\n    while (node) {\n        parents.unshift(node);\n        if (node === root) {\n            break;\n        }\n        node = node.parentNode;\n    }\n    return parents;\n}\n\nexport function commonParentGet(node1, node2, root = undefined) {\n    if (!node1 || !node2) {\n        return null;\n    }\n    const n1p = parentsGet(node1, root);\n    const n2p = parentsGet(node2, root);\n    while (n1p.length > 1 && n1p[1] === n2p[1]) {\n        n1p.shift();\n        n2p.shift();\n    }\n    // Check  in case at least one of them is not in the DOM.\n    return n1p[0] === n2p[0] ? n1p[0] : null;\n}\n\nexport function getListMode(pnode) {\n    if (pnode.tagName == 'OL') return 'OL';\n    return pnode.classList.contains('o_checklist') ? 'CL' : 'UL';\n}\n\nexport function createList(mode) {\n    const node = document.createElement(mode == 'OL' ? 'OL' : 'UL');\n    if (mode == 'CL') {\n        node.classList.add('o_checklist');\n    }\n    return node;\n}\n\nexport function insertListAfter(afterNode, mode, content = []) {\n    const list = createList(mode);\n    afterNode.after(list);\n    list.append(\n        ...content.map(c => {\n            const li = document.createElement('LI');\n            li.append(...[].concat(c));\n            return li;\n        }),\n    );\n    return list;\n}\n\nexport function toggleClass(node, className) {\n    node.classList.toggle(className);\n    if (!node.className) {\n        node.removeAttribute('class');\n    }\n}\n\n/**\n * Returns whether or not the given node is a BR element which does not really\n * act as a line break, but as a placeholder for the cursor or to make some left\n * element (like a space) visible.\n *\n * @param {HTMLBRElement} brEl\n * @returns {boolean}\n */\nexport function isFakeLineBreak(brEl) {\n    return !(getState(...rightPos(brEl), DIRECTIONS.RIGHT).cType & (CTYPES.CONTENT | CTGROUPS.BR));\n}\n/**\n * Checks whether or not the given block has any visible content, except for\n * a placeholder BR.\n *\n * @param {HTMLElement} blockEl\n * @returns {boolean}\n */\nexport function isEmptyBlock(blockEl) {\n    if (!blockEl || blockEl.nodeType !== Node.ELEMENT_NODE) {\n        return false;\n    }\n    if (isFontAwesome(blockEl) || visibleCharRegex.test(blockEl.textContent)) {\n        return false;\n    }\n    if (blockEl.querySelectorAll('br').length >= 2) {\n        return false;\n    }\n    const nodes = blockEl.querySelectorAll('*');\n    for (const node of nodes) {\n        // There is no text and no double BR, the only thing that could make\n        // this visible is a \"visible empty\" node like an image.\n        if (node.nodeName != 'BR' && (isSelfClosingElement(node) || isFontAwesome(node))) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Checks whether or not the given block element has something to make it have\n * a visible height (except for padding / border).\n *\n * @param {HTMLElement} blockEl\n * @returns {boolean}\n */\nexport function isShrunkBlock(blockEl) {\n    return (\n        isEmptyBlock(blockEl) &&\n        !blockEl.querySelector('br') &&\n        blockEl.nodeName !== \"IMG\"\n    );\n}\n\n/**\n * @param {string} [value]\n * @returns {boolean}\n */\nexport function isColorGradient(value) {\n    // FIXME duplicated in @web_editor/utils.js\n    return value && value.includes('-gradient(');\n}\n\n/**\n * Finds the font size to display for the current selection. We cannot rely\n * on the computed font-size only as font-sizes are responsive and we always\n * want to display the desktop (integer when possible) one.\n *\n * @private\n * @todo probably move `getCSSVariableValue` and `convertNumericToUnit` as\n *       odoo-editor utils.\n * @param {Selection} sel The current selection.\n * @returns {Float} The font size to display.\n */\nexport function getFontSizeDisplayValue(sel, getCSSVariableValue, convertNumericToUnit) {\n    const tagNameRelatedToFontSize = [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"];\n    const styleClassesRelatedToFontSize = [\"display-1\", \"display-2\", \"display-3\", \"display-4\"];\n    const closestStartContainerEl = closestElement(sel.getRangeAt(0).startContainer);\n    const closestFontSizedEl = closestStartContainerEl.closest(`\n        [style*='font-size'],\n        ${FONT_SIZE_CLASSES.map(className => `.${className}`)},\n        ${styleClassesRelatedToFontSize.map(className => `.${className}`)},\n        ${tagNameRelatedToFontSize}\n    `);\n    let remValue;\n    if (closestFontSizedEl) {\n        const useFontSizeInput = closestFontSizedEl.style.fontSize;\n        if (useFontSizeInput) {\n            // Use the computed value to always convert to px. However, this\n            // currently does not check that the inline font-size is the one\n            // actually having an effect (there could be an !important CSS rule\n            // forcing something else).\n            // TODO align with the behavior of the rest of the editor snippet\n            // options.\n            return parseFloat(getComputedStyle(closestStartContainerEl).fontSize);\n        }\n        // It's a class font size or a hN tag. We don't return the computed\n        // font size because it can be different from the one displayed in\n        // the toolbar because it's responsive.\n        const fontSizeClass = FONT_SIZE_CLASSES.find(\n            className => closestFontSizedEl.classList.contains(className));\n        let fsName;\n        if (fontSizeClass) {\n            fsName = fontSizeClass.substring(0, fontSizeClass.length - 3); // Without -fs\n        } else {\n            fsName = styleClassesRelatedToFontSize.find(\n                    className => closestFontSizedEl.classList.contains(className))\n                || closestFontSizedEl.tagName.toLowerCase();\n        }\n        remValue = parseFloat(getCSSVariableValue(`${fsName}-font-size`));\n    }\n    // It's default font size (no font size class / style).\n    if (remValue === undefined) {\n        remValue = parseFloat(getCSSVariableValue(\"font-size-base\"));\n    }\n    const pxValue = convertNumericToUnit(remValue, \"rem\", \"px\");\n    return pxValue || parseFloat(getComputedStyle(closestStartContainerEl).fontSize);\n}\n\n//------------------------------------------------------------------------------\n// DOM Modification\n//------------------------------------------------------------------------------\n\n/**\n * Splits a text node in two parts.\n * If the split occurs at the beginning or the end, the text node stays\n * untouched and unsplit. If a split actually occurs, the original text node\n * still exists and become the right part of the split.\n *\n * Note: if split after or before whitespace, that whitespace may become\n * invisible, it is up to the caller to replace it by nbsp if needed.\n *\n * @param {Node} textNode\n * @param {number} offset\n * @param {DIRECTIONS} originalNodeSide Whether the original node ends up on left\n * or right after the split\n * @returns {number} The parentOffset if the cursor was between the two text\n *          node parts after the split.\n */\nexport function splitTextNode(textNode, offset, originalNodeSide = DIRECTIONS.RIGHT) {\n    let parentOffset = childNodeIndex(textNode);\n\n    if (offset > 0) {\n        parentOffset++;\n\n        if (offset < textNode.length) {\n            const left = textNode.nodeValue.substring(0, offset);\n            const right = textNode.nodeValue.substring(offset);\n            if (originalNodeSide === DIRECTIONS.LEFT) {\n                const newTextNode = document.createTextNode(right);\n                textNode.after(newTextNode);\n                textNode.nodeValue = left;\n            } else {\n                const newTextNode = document.createTextNode(left);\n                textNode.before(newTextNode);\n                textNode.nodeValue = right;\n            }\n        }\n    }\n    return parentOffset;\n}\n\n/**\n * Split the given element at the given offset. The element will be removed in\n * the process so caution is advised in dealing with its reference. Returns a\n * tuple containing the new elements on both sides of the split.\n *\n * @param {Element} element\n * @param {number} offset\n * @returns {[Element, Element]}\n */\nexport function splitElement(element, offset) {\n    const before = element.cloneNode();\n    const after = element.cloneNode();\n    let index = 0;\n    for (const child of [...element.childNodes]) {\n        index < offset ? before.appendChild(child) : after.appendChild(child);\n        index++;\n    }\n    // e.g.: <p>Test/banner</p> + ENTER <=> <p>Test</p><div class=\"o_editor_banner>...</div><p><br></p>\n    const blockEl = closestBlock(after);\n    if (blockEl) {\n        fillEmpty(blockEl);\n    }\n    element.before(before);\n    element.after(after);\n    element.remove();\n    return [before, after];\n}\n\n/**\n * Split around the given elements, until a given ancestor (included). Elements\n * will be removed in the process so caution is advised in dealing with their\n * references. Returns the new split root element that is a clone of\n * limitAncestor or the original limitAncestor if no split occured.\n *\n * @see splitElement\n * @param {Node[] | Node} elements\n * @param {Node} limitAncestor\n * @returns {[Node, Node]}\n */\nexport function splitAroundUntil(elements, limitAncestor) {\n    elements = Array.isArray(elements) ? elements : [elements];\n    const firstNode = elements[0];\n    const lastNode = elements[elements.length - 1];\n    if ([firstNode, lastNode].includes(limitAncestor)) {\n        return limitAncestor;\n    }\n    let before = firstNode.previousSibling;\n    let after = lastNode.nextSibling;\n    let beforeSplit, afterSplit;\n    if (!before && !after && elements[0] !== limitAncestor) {\n        return splitAroundUntil(elements[0].parentElement, limitAncestor);\n    }\n    // Split up ancestors up to font\n    while (after && after.parentElement !== limitAncestor) {\n        afterSplit = splitElement(after.parentElement, childNodeIndex(after))[0];\n        after = afterSplit.nextSibling;\n    }\n    if (after) {\n        afterSplit = splitElement(limitAncestor, childNodeIndex(after))[0];\n        limitAncestor = afterSplit;\n    }\n    while (before && before.parentElement !== limitAncestor) {\n        beforeSplit = splitElement(before.parentElement, childNodeIndex(before) + 1)[1];\n        before = beforeSplit.previousSibling;\n    }\n    if (before) {\n        beforeSplit = splitElement(limitAncestor, childNodeIndex(before) + 1)[1];\n    }\n    return beforeSplit || afterSplit || limitAncestor;\n}\n\nexport function insertText(sel, content) {\n    if (sel.anchorNode.nodeType === Node.TEXT_NODE) {\n        const pos = [sel.anchorNode.parentElement, splitTextNode(sel.anchorNode, sel.anchorOffset)];\n        setSelection(...pos, ...pos, false);\n    }\n    const txt = document.createTextNode(content || '#');\n    const restore = prepareUpdate(sel.anchorNode, sel.anchorOffset);\n    sel.getRangeAt(0).insertNode(txt);\n    restore();\n    setSelection(...boundariesOut(txt), false);\n    return txt;\n}\n\n/**\n * Remove node from the DOM while preserving their contents if any.\n *\n * @param {Node} node\n * @returns {Node[]}\n */\nexport function unwrapContents(node) {\n    const contents = [...node.childNodes];\n    for (const child of contents) {\n        node.parentNode.insertBefore(child, node);\n    }\n    node.parentNode.removeChild(node);\n    return contents;\n}\n\n/**\n * Add a BR in the given node if its closest ancestor block has nothing to make\n * it visible, and/or add a zero-width space in the given node if it's an empty\n * inline unremovable so the cursor can stay in it.\n *\n * @param {HTMLElement} el\n * @returns {Object} { br: the inserted <br> if any,\n *                     zws: the inserted zero-width space if any }\n */\nexport function fillEmpty(el) {\n    const fillers = {};\n    const blockEl = closestBlock(el);\n    if (isShrunkBlock(blockEl)) {\n        const br = document.createElement('br');\n        blockEl.appendChild(br);\n        fillers.br = br;\n    }\n    if (!isVisible(el) && !el.hasAttribute(\"data-oe-zws-empty-inline\")) {\n        // As soon as there is actual content in the node, the zero-width space\n        // is removed by the sanitize function.\n        const zws = document.createTextNode('\\u200B');\n        el.appendChild(zws);\n        el.setAttribute(\"data-oe-zws-empty-inline\", \"\");\n        fillers.zws = zws;\n        const previousSibling = el.previousSibling;\n        if (previousSibling && previousSibling.nodeName === \"BR\") {\n            previousSibling.remove();\n        }\n        setSelection(zws, 0, zws, 0);\n    }\n    return fillers;\n}\n/**\n * Takes a selection (assumed to be collapsed) and insert a zero-width space at\n * its anchor point. Then, select that zero-width space.\n *\n * @param {Selection} selection\n * @returns {Node} the inserted zero-width space\n */\nexport function insertAndSelectZws(selection) {\n    const offset = selection.anchorOffset;\n    const zws = insertText(selection, '\\u200B');\n    splitTextNode(zws, offset);\n    selection.getRangeAt(0).selectNode(zws);\n    return zws;\n}\n\nexport function setTagName(el, newTagName) {\n    if (el.tagName === newTagName) {\n        return el;\n    }\n    const n = document.createElement(newTagName);\n    if (el.nodeName !== 'LI') {\n        const attributes = el.attributes;\n        for (const attr of attributes) {\n            n.setAttribute(attr.name, attr.value);\n        }\n    }\n    while (el.firstChild) {\n        n.append(el.firstChild);\n    }\n    if (el.tagName === 'LI') {\n        el.append(n);\n    } else {\n        el.parentNode.replaceChild(n, el);\n    }\n    return n;\n}\n/**\n * Moves the given subset of nodes of a source element to the given destination.\n * If the source element is left empty it is removed. This ensures the moved\n * content and its destination surroundings are restored (@see restoreState) to\n * the way there were.\n *\n * It also reposition at the right position on the left of the moved nodes.\n *\n * @param {HTMLElement} destinationEl\n * @param {number} destinationOffset\n * @param {HTMLElement} sourceEl\n * @param {number} [startIndex=0]\n * @param {number} [endIndex=sourceEl.childNodes.length]\n * @returns {Array.<HTMLElement, number} The position at the left of the moved\n *     nodes after the move was done (and where the cursor was returned).\n */\nexport function moveNodes(\n    destinationEl,\n    destinationOffset,\n    sourceEl,\n    startIndex = 0,\n    endIndex = sourceEl.childNodes.length,\n) {\n    if (selfClosingElementTags.includes(destinationEl.nodeName)) {\n        throw new Error(`moveNodes: Invalid destination element ${destinationEl.nodeName}`);\n    }\n\n    const nodes = [];\n    for (let i = startIndex; i < endIndex; i++) {\n        nodes.push(sourceEl.childNodes[i]);\n    }\n\n    if (nodes.length) {\n        const restoreDestination = prepareUpdate(destinationEl, destinationOffset);\n        const restoreMoved = prepareUpdate(\n            ...leftPos(sourceEl.childNodes[startIndex]),\n            ...rightPos(sourceEl.childNodes[endIndex - 1]),\n        );\n        const fragment = document.createDocumentFragment();\n        nodes.forEach(node => fragment.appendChild(node));\n        const posRightNode = destinationEl.childNodes[destinationOffset];\n        if (posRightNode) {\n            destinationEl.insertBefore(fragment, posRightNode);\n        } else {\n            destinationEl.appendChild(fragment);\n        }\n        restoreDestination();\n        restoreMoved();\n    }\n\n    if (!nodeSize(sourceEl)) {\n        const restoreOrigin = prepareUpdate(...boundariesOut(sourceEl));\n        sourceEl.remove();\n        restoreOrigin();\n    }\n\n    // Return cursor position, but don't change it\n    const firstNode = nodes.find(node => !!node.parentNode);\n    return firstNode ? leftPos(firstNode) : [destinationEl, destinationOffset];\n}\n/**\n * Remove ouid of a node and it's descendants in order to allow that tree\n * to be moved into another parent.\n */\nexport function resetOuids(node) {\n    node.ouid = undefined;\n    for (const descendant of descendants(node)) {\n        descendant.ouid = undefined;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Prepare / Save / Restore state utilities\n//------------------------------------------------------------------------------\n\nconst prepareUpdateLockedEditables = new Set();\n/**\n * Any editor command is applied to a selection (collapsed or not). After the\n * command, the content type on the selection boundaries, in both direction,\n * should be preserved (some whitespace should disappear as went from collapsed\n * to non collapsed, or converted to &nbsp; as went from non collapsed to\n * collapsed, there also <br> to remove/duplicate, etc).\n *\n * This function returns a callback which allows to do that after the command\n * has been done.\n *\n * Note: the method has been made generic enough to work with non-collapsed\n * selection but can be used for an unique cursor position.\n *\n * @param {HTMLElement} el\n * @param {number} offset\n * @param {...(HTMLElement|number)} args - argument 1 and 2 can be repeated for\n *     multiple preparations with only one restore callback returned. Note: in\n *     that case, the positions should be given in the document node order.\n * @param {Object} [options]\n * @param {boolean} [options.allowReenter = true] - if false, all calls to\n *     prepareUpdate before this one gets restored will be ignored.\n * @param {string} [options.label = <random 6 character string>]\n * @param {boolean} [options.debug = false] - if true, adds nicely formatted\n *     console logs to help with debugging.\n * @returns {function}\n */\nexport function prepareUpdate(...args) {\n    const closestRoot = args.length && ancestors(args[0]).find(ancestor => ancestor.oid === 'root');\n    const isPrepareUpdateLocked = closestRoot && prepareUpdateLockedEditables.has(closestRoot);\n    const hash = (Math.random() + 1).toString(36).substring(7);\n    const options = {\n        allowReenter: true,\n        label: hash,\n        debug: false,\n        ...(args.length && args[args.length - 1] instanceof Object ? args.pop() : {}),\n    };\n    if (options.debug) {\n        console.log(\n            '%cPreparing%c update: ' + options.label +\n            (options.label === hash ? '' : ` (${hash})`) +\n            '%c' + (isPrepareUpdateLocked ? ' LOCKED' : ''),\n            'color: cyan;',\n            'color: white;',\n            'color: red; font-weight: bold;',\n        );\n    }\n    if (isPrepareUpdateLocked) {\n        return () => {\n            if (options.debug) {\n                console.log(\n                    '%cRestoring%c update: ' + options.label +\n                    (options.label === hash ? '' : ` (${hash})`) +\n                    '%c LOCKED',\n                    'color: lightgreen;',\n                    'color: white;',\n                    'color: red; font-weight: bold;',\n                );\n            }\n        };\n    }\n    if (!options.allowReenter && closestRoot) {\n        prepareUpdateLockedEditables.add(closestRoot);\n    }\n    const positions = [...args];\n\n    // Check the state in each direction starting from each position.\n    const restoreData = [];\n    let el, offset;\n    while (positions.length) {\n        // Note: important to get the positions in reverse order to restore\n        // right side before left side.\n        offset = positions.pop();\n        el = positions.pop();\n        const left = getState(el, offset, DIRECTIONS.LEFT);\n        const right = getState(el, offset, DIRECTIONS.RIGHT, left.cType);\n        if (options.debug) {\n            const editable = el && closestElement(el, '.odoo-editor-editable');\n            const oldEditableHTML = editable && editable.innerHTML.replaceAll(' ', '_').replaceAll('\\u200B', 'ZWS') || '';\n            left.oldEditableHTML = oldEditableHTML;\n            right.oldEditableHTML = oldEditableHTML;\n        }\n        restoreData.push(left, right);\n    }\n\n    // Create the callback that will be able to restore the state in each\n    // direction wherever the node in the opposite direction has landed.\n    return function restoreStates() {\n        if (options.debug) {\n            console.log(\n                '%cRestoring%c update: ' + options.label +\n                (options.label === hash ? '' : ` (${hash})`),\n                'color: lightgreen;',\n                'color: white;',\n            );\n        }\n        for (const data of restoreData) {\n            restoreState(data, options.debug);\n        }\n        if (!options.allowReenter && closestRoot) {\n            prepareUpdateLockedEditables.delete(closestRoot);\n        }\n    };\n}\n/**\n * Retrieves the \"state\" from a given position looking at the given direction.\n * The \"state\" is the type of content. The functions also returns the first\n * meaninful node looking in the opposite direction = the first node we trust\n * will not disappear if a command is played in the given direction.\n *\n * Note: only work for in-between nodes positions. If the position is inside a\n * text node, first split it @see splitTextNode.\n *\n * @param {HTMLElement} el\n * @param {number} offset\n * @param {DIRECTIONS} direction @see DIRECTIONS.LEFT @see DIRECTIONS.RIGHT\n * @param {CTYPES} [leftCType]\n * @returns {Object}\n */\nexport function getState(el, offset, direction, leftCType) {\n    const leftDOMPath = leftLeafOnlyNotBlockPath;\n    const rightDOMPath = rightLeafOnlyNotBlockPath;\n\n    let domPath;\n    let inverseDOMPath;\n    const whitespaceAtStartRegex = new RegExp('^' + whitespace + '+');\n    const whitespaceAtEndRegex = new RegExp(whitespace + '+$');\n    const reasons = [];\n    if (direction === DIRECTIONS.LEFT) {\n        domPath = leftDOMPath(el, offset, reasons);\n        inverseDOMPath = rightDOMPath(el, offset);\n    } else {\n        domPath = rightDOMPath(el, offset, reasons);\n        inverseDOMPath = leftDOMPath(el, offset);\n    }\n\n    // TODO I think sometimes, the node we have to consider as the\n    // anchor point to restore the state is not the first one of the inverse\n    // path (like for example, empty text nodes that may disappear\n    // after the command so we would not want to get those ones).\n    const boundaryNode = inverseDOMPath.next().value;\n\n    // We only traverse through deep inline nodes. If we cannot find a\n    // meanfingful state between them, that means we hit a block.\n    let cType = undefined;\n\n    // Traverse the DOM in the given direction to check what type of content\n    // there is.\n    let lastSpace = null;\n    for (const node of domPath) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            const value = node.nodeValue;\n            // If we hit a text node, the state depends on the path direction:\n            // any space encountered backwards is a visible space if we hit\n            // visible content afterwards. If going forward, spaces are only\n            // visible if we have content backwards.\n            if (direction === DIRECTIONS.LEFT) {\n                if (!isWhitespace(value)) {\n                    if (lastSpace) {\n                        cType = CTYPES.SPACE;\n                    } else {\n                        const rightLeaf = rightLeafOnlyNotBlockPath(node).next().value;\n                        const hasContentRight = rightLeaf && !whitespaceAtStartRegex.test(rightLeaf.textContent);\n                        cType = !hasContentRight && whitespaceAtEndRegex.test(node.textContent) ? CTYPES.SPACE : CTYPES.CONTENT;\n                    }\n                    break;\n                }\n                if (value.length) {\n                    lastSpace = node;\n                }\n            } else {\n                leftCType = leftCType || getState(el, offset, DIRECTIONS.LEFT).cType;\n                if (whitespaceAtStartRegex.test(value)) {\n                    const leftLeaf = leftLeafOnlyNotBlockPath(node).next().value;\n                    const hasContentLeft = leftLeaf && !whitespaceAtEndRegex.test(leftLeaf.textContent);\n                    const rct = !isWhitespace(value)\n                        ? CTYPES.CONTENT\n                        : getState(...rightPos(node), DIRECTIONS.RIGHT).cType;\n                    cType =\n                        leftCType & CTYPES.CONTENT && rct & (CTYPES.CONTENT | CTYPES.BR) && !hasContentLeft\n                            ? CTYPES.SPACE\n                            : rct;\n                    break;\n                }\n                if (!isWhitespace(value)) {\n                    cType = CTYPES.CONTENT;\n                    break;\n                }\n            }\n        } else if (node.nodeName === 'BR') {\n            cType = CTYPES.BR;\n            break;\n        } else if (isVisible(node)) {\n            // E.g. an image\n            cType = CTYPES.CONTENT;\n            break;\n        }\n    }\n\n    if (cType === undefined) {\n        cType = reasons.includes(PATH_END_REASONS.BLOCK_HIT)\n            ? CTYPES.BLOCK_OUTSIDE\n            : CTYPES.BLOCK_INSIDE;\n    }\n\n    return {\n        node: boundaryNode,\n        direction: direction,\n        cType: cType, // Short for contentType\n    };\n}\nconst priorityRestoreStateRules = [\n    // Each entry is a list of two objects, with each key being optional (the\n    // more key-value pairs, the bigger the priority).\n    // {direction: ..., cType1: ..., cType2: ...}\n    // ->\n    // {spaceVisibility: (false|true), brVisibility: (false|true)}\n    [\n        // Replace a space by &nbsp; when it was not collapsed before and now is\n        // collapsed (one-letter word removal for example).\n        { cType1: CTYPES.CONTENT, cType2: CTYPES.SPACE | CTGROUPS.BLOCK },\n        { spaceVisibility: true },\n    ],\n    [\n        // Replace a space by &nbsp; when it was content before and now it is\n        // a BR.\n        { direction: DIRECTIONS.LEFT, cType1: CTGROUPS.INLINE, cType2: CTGROUPS.BR },\n        { spaceVisibility: true },\n    ],\n    [\n        // Replace a space by &nbsp; when it was content before and now it is\n        // a BR (removal of last character before a BR for example).\n        { direction: DIRECTIONS.RIGHT, cType1: CTGROUPS.CONTENT, cType2: CTGROUPS.BR },\n        { spaceVisibility: true },\n    ],\n    [\n        // Replace a space by &nbsp; when it was visible thanks to a BR which\n        // is now gone.\n        { direction: DIRECTIONS.RIGHT, cType1: CTGROUPS.BR, cType2: CTYPES.SPACE | CTGROUPS.BLOCK },\n        { spaceVisibility: true },\n    ],\n    [\n        // Remove all collapsed spaces when a space is removed.\n        { cType1: CTYPES.SPACE },\n        { spaceVisibility: false },\n    ],\n    [\n        // Remove spaces once the preceeding BR is removed\n        { direction: DIRECTIONS.LEFT, cType1: CTGROUPS.BR },\n        { spaceVisibility: false },\n    ],\n    [\n        // Remove space before block once content is put after it (otherwise it\n        // would become visible).\n        { cType1: CTGROUPS.BLOCK, cType2: CTGROUPS.INLINE | CTGROUPS.BR },\n        { spaceVisibility: false },\n    ],\n    [\n        // Duplicate a BR once the content afterwards disappears\n        { direction: DIRECTIONS.RIGHT, cType1: CTGROUPS.INLINE, cType2: CTGROUPS.BLOCK },\n        { brVisibility: true },\n    ],\n    [\n        // Remove a BR at the end of a block once inline content is put after\n        // it (otherwise it would act as a line break).\n        {\n            direction: DIRECTIONS.RIGHT,\n            cType1: CTGROUPS.BLOCK,\n            cType2: CTGROUPS.INLINE | CTGROUPS.BR,\n        },\n        { brVisibility: false },\n    ],\n    [\n        // Remove a BR once the BR that preceeds it is now replaced by\n        // content (or if it was a BR at the start of a block which now is\n        // a trailing BR).\n        {\n            direction: DIRECTIONS.LEFT,\n            cType1: CTGROUPS.BR | CTGROUPS.BLOCK,\n            cType2: CTGROUPS.INLINE,\n        },\n        { brVisibility: false, extraBRRemovalCondition: brNode => isFakeLineBreak(brNode) },\n    ],\n];\nfunction restoreStateRuleHashCode(direction, cType1, cType2) {\n    return `${direction}-${cType1}-${cType2}`;\n}\nconst allRestoreStateRules = (function () {\n    const map = new Map();\n\n    const keys = ['direction', 'cType1', 'cType2'];\n    for (const direction of Object.values(DIRECTIONS)) {\n        for (const cType1 of Object.values(CTYPES)) {\n            for (const cType2 of Object.values(CTYPES)) {\n                const rule = { direction: direction, cType1: cType1, cType2: cType2 };\n\n                // Search for the rules which match whatever their priority\n                const matchedRules = [];\n                for (const entry of priorityRestoreStateRules) {\n                    let priority = 0;\n                    for (const key of keys) {\n                        const entryKeyValue = entry[0][key];\n                        if (entryKeyValue !== undefined) {\n                            if (\n                                typeof entryKeyValue === 'boolean'\n                                    ? rule[key] === entryKeyValue\n                                    : rule[key] & entryKeyValue\n                            ) {\n                                priority++;\n                            } else {\n                                priority = -1;\n                                break;\n                            }\n                        }\n                    }\n                    if (priority >= 0) {\n                        matchedRules.push([priority, entry[1]]);\n                    }\n                }\n\n                // Create the final rule by merging found rules by order of\n                // priority\n                const finalRule = {};\n                for (let p = 0; p <= keys.length; p++) {\n                    for (const entry of matchedRules) {\n                        if (entry[0] === p) {\n                            Object.assign(finalRule, entry[1]);\n                        }\n                    }\n                }\n\n                // Create an unique identifier for the set of values\n                // direction - state 1 - state2 to add the rule in the map\n                const hashCode = restoreStateRuleHashCode(direction, cType1, cType2);\n                map.set(hashCode, finalRule);\n            }\n        }\n    }\n\n    return map;\n})();\n/**\n * Restores the given state starting before the given while looking in the given\n * direction.\n *\n * @param {Object} prevStateData @see getState\n * @param {boolean} debug=false - if true, adds nicely formatted\n *     console logs to help with debugging.\n * @returns {Object|undefined} the rule that was applied to restore the state,\n *     if any, for testing purposes.\n */\nexport function restoreState(prevStateData, debug=false) {\n    const { node, direction, cType: cType1, oldEditableHTML } = prevStateData;\n    if (!node || !node.parentNode) {\n        // FIXME sometimes we want to restore the state starting from a node\n        // which has been removed by another restoreState call... Not sure if\n        // it is a problem or not, to investigate.\n        return;\n    }\n    const [el, offset] = direction === DIRECTIONS.LEFT ? leftPos(node) : rightPos(node);\n    const { cType: cType2 } = getState(el, offset, direction);\n\n    /**\n     * Knowing the old state data and the new state data, we know if we have to\n     * do something or not, and what to do.\n     */\n    const ruleHashCode = restoreStateRuleHashCode(direction, cType1, cType2);\n    const rule = allRestoreStateRules.get(ruleHashCode);\n    if (debug) {\n        const editable = closestElement(node, '.odoo-editor-editable');\n        console.log(\n            '%c' + node.textContent.replaceAll(' ', '_').replaceAll('\\u200B', 'ZWS') + '\\n' +\n            '%c' + (direction === DIRECTIONS.LEFT ? 'left' : 'right') + '\\n' +\n            '%c' + ctypeToString(cType1) + '\\n' +\n            '%c' + ctypeToString(cType2) + '\\n' +\n            '%c' + 'BEFORE: ' + (oldEditableHTML || '(unavailable)') + '\\n' +\n            '%c' + 'AFTER:  ' + (editable ? editable.innerHTML.replaceAll(' ', '_').replaceAll('\\u200B', 'ZWS') : '(unavailable)') + '\\n',\n            'color: white; display: block; width: 100%;',\n            'color: ' + (direction === DIRECTIONS.LEFT ? 'magenta' : 'lightgreen') + '; display: block; width: 100%;',\n            'color: pink; display: block; width: 100%;',\n            'color: lightblue; display: block; width: 100%;',\n            'color: white; display: block; width: 100%;',\n            'color: white; display: block; width: 100%;',\n            rule,\n        );\n    }\n    if (Object.values(rule).filter(x => x !== undefined).length) {\n        const inverseDirection = direction === DIRECTIONS.LEFT ? DIRECTIONS.RIGHT : DIRECTIONS.LEFT;\n        enforceWhitespace(el, offset, inverseDirection, rule);\n    }\n    return rule;\n}\n/**\n * Enforces the whitespace and BR visibility in the given direction starting\n * from the given position.\n *\n * @param {HTMLElement} el\n * @param {number} offset\n * @param {number} direction @see DIRECTIONS.LEFT @see DIRECTIONS.RIGHT\n * @param {Object} rule\n * @param {boolean} [rule.spaceVisibility]\n * @param {boolean} [rule.brVisibility]\n */\nexport function enforceWhitespace(el, offset, direction, rule) {\n    let domPath, whitespaceAtEdgeRegex;\n    if (direction === DIRECTIONS.LEFT) {\n        domPath = leftLeafOnlyNotBlockPath(el, offset);\n        whitespaceAtEdgeRegex = new RegExp(whitespace + '+$');\n    } else {\n        domPath = rightLeafOnlyNotBlockPath(el, offset);\n        whitespaceAtEdgeRegex = new RegExp('^' + whitespace + '+');\n    }\n\n    const invisibleSpaceTextNodes = [];\n    let foundVisibleSpaceTextNode = null;\n    for (const node of domPath) {\n        if (node.nodeName === 'BR') {\n            if (rule.brVisibility === undefined) {\n                break;\n            }\n            if (rule.brVisibility) {\n                node.before(document.createElement('br'));\n            } else {\n                if (!rule.extraBRRemovalCondition || rule.extraBRRemovalCondition(node)) {\n                    node.remove();\n                }\n            }\n            break;\n        } else if (node.nodeType === Node.TEXT_NODE && !isInPre(node)) {\n            if (whitespaceAtEdgeRegex.test(node.nodeValue)) {\n                // If we hit spaces going in the direction, either they are in a\n                // visible text node and we have to change the visibility of\n                // those spaces, or it is in an invisible text node. In that\n                // last case, we either remove the spaces if there are spaces in\n                // a visible text node going further in the direction or we\n                // change the visiblity or those spaces.\n                if (!isWhitespace(node)) {\n                    foundVisibleSpaceTextNode = node;\n                    break;\n                } else {\n                    invisibleSpaceTextNodes.push(node);\n                }\n            } else if (!isWhitespace(node)) {\n                break;\n            }\n        } else {\n            break;\n        }\n    }\n\n    if (rule.spaceVisibility === undefined) {\n        return;\n    }\n    if (!rule.spaceVisibility) {\n        for (const node of invisibleSpaceTextNodes) {\n            // Empty and not remove to not mess with offset-based positions in\n            // commands implementation, also remove non-block empty parents.\n            node.nodeValue = '';\n            const ancestorPath = closestPath(node.parentNode);\n            let toRemove = null;\n            for (const pNode of ancestorPath) {\n                if (toRemove) {\n                    toRemove.remove();\n                }\n                if (pNode.childNodes.length === 1 && !isBlock(pNode)) {\n                    pNode.after(node);\n                    toRemove = pNode;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    const spaceNode = foundVisibleSpaceTextNode || invisibleSpaceTextNodes[0];\n    if (spaceNode) {\n        let spaceVisibility = rule.spaceVisibility;\n        // In case we are asked to replace the space by a &nbsp;, disobey and\n        // do the opposite if that space is currently not visible\n        // TODO I'd like this to not be needed, it feels wrong...\n        if (\n            spaceVisibility &&\n            !foundVisibleSpaceTextNode &&\n            getState(...rightPos(spaceNode), DIRECTIONS.RIGHT).cType & CTGROUPS.BLOCK &&\n            getState(...leftPos(spaceNode), DIRECTIONS.LEFT).cType !== CTYPES.CONTENT\n        ) {\n            spaceVisibility = false;\n        }\n        spaceNode.nodeValue = spaceNode.nodeValue.replace(whitespaceAtEdgeRegex, spaceVisibility ? '\\u00A0' : '');\n    }\n}\n\n/**\n * Takes a color (rgb, rgba or hex) and returns its hex representation. If the\n * color is given in rgba, the background color of the node whose color we're\n * converting is used in conjunction with the alpha to compute the resulting\n * color (using the formula: `alpha*color + (1 - alpha)*background` for each\n * channel).\n *\n * @param {string} rgb\n * @param {HTMLElement} [node]\n * @returns {string} hexadecimal color (#RRGGBB)\n */\nexport function rgbToHex(rgb = '', node = null) {\n    if (rgb.startsWith('#')) {\n        return rgb;\n    } else if (rgb.startsWith('rgba')) {\n        const values = rgb.match(/[\\d\\.]{1,5}/g) || [];\n        const alpha = parseFloat(values.pop());\n        // Retrieve the background color.\n        let bgRgbValues = [];\n        if (node) {\n            let bgColor = getComputedStyle(node).backgroundColor;\n            if (bgColor.startsWith('rgba')) {\n                // The background color is itself rgba so we need to compute\n                // the resulting color using the background color of its\n                // parent.\n                bgColor = rgbToHex(bgColor, node.parentElement);\n            }\n            if (bgColor && bgColor.startsWith('#')) {\n                bgRgbValues = (bgColor.match(/[\\da-f]{2}/gi) || []).map(val => parseInt(val, 16));\n            } else if (bgColor && bgColor.startsWith('rgb')) {\n                bgRgbValues = (bgColor.match(/[\\d\\.]{1,5}/g) || []).map(val => parseInt(val));\n            }\n        }\n        bgRgbValues = bgRgbValues.length ? bgRgbValues : [255, 255, 255]; // Default to white.\n\n        return (\n            '#' +\n            values.map((value, index) => {\n                const converted = Math.floor(alpha * parseInt(value) + (1 - alpha) * bgRgbValues[index]);\n                const hex = parseInt(converted).toString(16);\n                return hex.length === 1 ? '0' + hex : hex;\n            }).join('')\n        );\n    } else {\n        return (\n            '#' +\n            (rgb.match(/\\d{1,3}/g) || [])\n                .map(x => {\n                    x = parseInt(x).toString(16);\n                    return x.length === 1 ? '0' + x : x;\n                })\n                .join('')\n        );\n    }\n}\n\nexport function parseHTML(document, html) {\n    const fragment = document.createDocumentFragment();\n    const parser = new document.defaultView.DOMParser();\n    const parsedDocument = parser.parseFromString(html, 'text/html');\n    fragment.replaceChildren(...parsedDocument.body.childNodes);\n    return fragment;\n}\n\n/**\n * Take a string containing a size in pixels, return that size as a float.\n *\n * @param {string} sizeString\n * @returns {number}\n */\nexport function pxToFloat(sizeString) {\n    return parseFloat(sizeString.replace('px', ''));\n}\n\n/**\n * Returns position of a range in form of object (end\n * position of a range in case of non-collapsed range).\n *\n * @param {HTMLElement} el element for which range postion will be calculated\n * @param {Document} document\n * @param {Object} [options]\n * @param {Number} [options.marginRight] right margin to be considered\n * @param {Number} [options.marginBottom] bottom margin to be considered\n * @param {Number} [options.marginTop] top margin to be considered\n * @param {Number} [options.marginLeft] left margin to be considered\n * @param {Function} [options.getContextFromParentRect] to get context rect from parent\n * @returns {Object | undefined}\n */\nexport function getRangePosition(el, document, options = {}) {\n    const selection = document.getSelection();\n    if (!selection.rangeCount) return;\n    const range = selection.getRangeAt(0);\n\n    const marginRight = options.marginRight || 20;\n    const marginBottom = options.marginBottom || 20;\n    const marginTop = options.marginTop || 10;\n    const marginLeft = options.marginLeft || 10;\n\n    let offset;\n    if (range.endOffset - 1 > 0) {\n        const clonedRange = range.cloneRange();\n        clonedRange.setStart(range.endContainer, range.endOffset - 1);\n        clonedRange.setEnd(range.endContainer, range.endOffset);\n        const rect = clonedRange.getBoundingClientRect();\n        offset = { height: rect.height, left: rect.left + rect.width, top: rect.top };\n        clonedRange.detach();\n    }\n\n    if (!offset || offset.height === 0) {\n        const clonedRange = range.cloneRange();\n        const shadowCaret = document.createTextNode('|');\n        clonedRange.insertNode(shadowCaret);\n        clonedRange.selectNode(shadowCaret);\n        const rect = clonedRange.getBoundingClientRect();\n        offset = { height: rect.height, left: rect.left, top: rect.top };\n        shadowCaret.remove();\n        clonedRange.detach();\n    }\n\n    const leftMove = Math.max(0, offset.left + el.offsetWidth + marginRight - window.innerWidth);\n    if (leftMove && offset.left - leftMove > marginLeft) {\n        offset.left -= leftMove;\n    } else if (offset.left - leftMove < marginLeft) {\n        offset.left = marginLeft;\n    }\n\n    if (options.parentContextRect) {\n        offset.left += options.parentContextRect.left;\n        offset.top += options.parentContextRect.top;\n    }\n\n    if (\n        offset.top - marginTop + offset.height + el.offsetHeight > window.innerHeight &&\n        offset.top - el.offsetHeight - marginBottom > 0\n    ) {\n        offset.top -= el.offsetHeight;\n    } else {\n        offset.top += offset.height;\n    }\n\n    if (offset) {\n        offset.top += window.scrollY;\n        offset.left += window.scrollX;\n    }\n\n    return offset;\n}\n\nexport const isNotEditableNode = node =>\n    node.getAttribute &&\n    node.getAttribute('contenteditable') &&\n    node.getAttribute('contenteditable').toLowerCase() === 'false';\n\nexport const leftLeafFirstPath = createDOMPathGenerator(DIRECTIONS.LEFT);\nexport const leftLeafOnlyNotBlockPath = createDOMPathGenerator(DIRECTIONS.LEFT, {\n    leafOnly: true,\n    stopTraverseFunction: isBlock,\n    stopFunction: isBlock,\n});\nexport const leftLeafOnlyInScopeNotBlockEditablePath = createDOMPathGenerator(DIRECTIONS.LEFT, {\n    leafOnly: true,\n    inScope: true,\n    stopTraverseFunction: node => isNotEditableNode(node) || isBlock(node),\n    stopFunction: node => isNotEditableNode(node) || isBlock(node),\n});\n\nexport const rightLeafOnlyNotBlockPath = createDOMPathGenerator(DIRECTIONS.RIGHT, {\n    leafOnly: true,\n    stopTraverseFunction: isBlock,\n    stopFunction: isBlock,\n});\n\nexport const rightLeafOnlyPathNotBlockNotEditablePath = createDOMPathGenerator(DIRECTIONS.RIGHT, {\n    leafOnly: true,\n});\nexport const rightLeafOnlyInScopeNotBlockEditablePath = createDOMPathGenerator(DIRECTIONS.RIGHT, {\n    leafOnly: true,\n    inScope: true,\n    stopTraverseFunction: node => isNotEditableNode(node) || isBlock(node),\n    stopFunction: node => isNotEditableNode(node) || isBlock(node),\n});\nexport const rightLeafOnlyNotBlockNotEditablePath = createDOMPathGenerator(DIRECTIONS.RIGHT, {\n    leafOnly: true,\n    stopTraverseFunction: node => isNotEditableNode(node) || isBlock(node),\n    stopFunction: node => isBlock(node) && !isNotEditableNode(node),\n});\n//------------------------------------------------------------------------------\n// Miscelaneous\n//------------------------------------------------------------------------------\nexport function peek(arr) {\n    return arr[arr.length - 1];\n}\n/**\n * Check user OS\n * @returns {boolean}\n */\nexport function isMacOS() {\n    return window.navigator.userAgent.includes('Mac');\n}\n\n/**\n * Remove zero-width spaces from the provided node and its descendants.\n *\n * @param {Node} node\n */\nexport function cleanZWS(node) {\n    [node, ...descendants(node)]\n        .filter(node => node.nodeType === Node.TEXT_NODE && node.nodeValue.includes('\\u200B'))\n        .forEach(node => node.nodeValue = node.nodeValue.replace(/\\u200B/g, ''));\n}\n"], "file": "/web/assets/1/438f7ea/web_studio.report_assets.js", "sourceRoot": "../../../../"}