)]}'
{"version": 3, "sources": ["/room/static/src/room_booking/room_booking_form/room_booking_form.js", "/room/static/src/room_booking/room_booking_remaining_time.js", "/room/static/src/room_booking/room_booking_view/room_booking_view.js", "/room/static/src/room_booking/room_display_time.js", "/room/static/src/room_booking/useInterval.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClXA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvTA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/** @odoo-module **/\n\nimport { scrollTo } from \"@web/core/utils/scrolling\";\n\nimport { Component, onWillUpdateProps, useEffect, useRef, useState } from \"@odoo/owl\";\n\nexport class RoomBookingForm extends Component {\n    static template = \"room.RoomBookingForm\";\n    static props = {\n        createBooking: Function,\n        bookings: Object,\n        bookingToEdit: { type: Object, optional: true },\n        cancel: Function,\n        editBooking: Function,\n        bookingName: { type: String, optional: true },\n    };\n\n    setup() {\n        this.root = useRef(\"root\");\n        // If editing the current booking, show the current date as start otherwise the start\n        // time slot would be hidden and we would not be able to change the start date\n        this.state = useState({\n            selectedDay: this.props.bookingToEdit\n                ? luxon.DateTime.max(\n                      this.props.bookingToEdit.interval.start.startOf(\"day\"),\n                      this.today,\n                  )\n                : this.today,\n            bookingStart: this.props.bookingToEdit\n                ? luxon.DateTime.max(this.props.bookingToEdit.interval.start, luxon.DateTime.now())\n                : undefined,\n            bookingEnd: this.props.bookingToEdit?.interval.end,\n            bookingName: this.props.bookingToEdit?.name || this.props.bookingName,\n        });\n\n        /**\n         * View the selected booking to edit\n         */\n        onWillUpdateProps((nextProps) => {\n            if (nextProps.bookingToEdit !== this.props.bookingToEdit) {\n                // If editing the current booking, show the current date as start otherwise the\n                // start time slot would be hidden and we would not be able to change the start\n                // date\n                this.state.selectedDay = luxon.DateTime.max(\n                    nextProps.bookingToEdit.interval.start.startOf(\"day\"),\n                    this.today,\n                );\n                this.state.bookingStart = luxon.DateTime.max(\n                    nextProps.bookingToEdit.interval.start,\n                    luxon.DateTime.now(),\n                );\n                this.state.bookingEnd = nextProps.bookingToEdit.interval.end;\n                this.state.bookingName = nextProps.bookingToEdit.name;\n            }\n        });\n\n        /**\n         * Show the selected start or the \"8am\" slot at the top of the scheduler when changing day\n         */\n        useEffect(\n            () => {\n                const slot = this.root.el.querySelector(\n                    `#slot${\n                        this.state.bookingStart?.startOf(\"day\").equals(this.state.selectedDay)\n                            ? this.state.bookingStart.toFormat(\"HHmm\")\n                            : \"0800\"\n                    }`,\n                );\n                if (slot) {\n                    scrollTo(slot, { isAnchor: true });\n                }\n            },\n            () => [this.state.selectedDay],\n        );\n    }\n\n    //----------------------------------------------------------------------\n    // Formats\n    //----------------------------------------------------------------------\n\n    get dayFormat() {\n        return { weekday: \"short\", day: \"numeric\" };\n    }\n\n    get durationFormat() {\n        return \"h:mm\";\n    }\n\n    get monthFormat() {\n        return { year: \"numeric\", month: \"long\" };\n    }\n\n    get timeFormat() {\n        return luxon.DateTime.TIME_SIMPLE;\n    }\n\n    //----------------------------------------------------------------------\n    // Getters\n    //----------------------------------------------------------------------\n\n    /**\n     * Return the bookings grouped by date.\n     * This getter is a fix allowing the view to be reactive to booking updates received through\n     * the bus.\n     */\n    get bookingsByDate() {\n        return this.computeBookingsByDate(this.props.bookings, this.props.bookingToEdit?.id);\n    }\n\n    /**\n     * Return the formatted month of the selected week.\n     */\n    get formattedMonth() {\n        return this.weekInterval.toLocaleString(this.monthFormat);\n    }\n\n    /**\n     * Compute the slots to display given the selected date, booking start and booking end.\n     * Each slot represents an interval of 30 minutes.\n     * Slots are objects with the following properties:\n     * - {luxon.DateTime} start: start datetime of the slot\n     * - {Boolean} isInSelectedInterval: if the slot is between the selected start and end dates\n     * - {Boolean} canBeEndDate: if the slot can be selected as the end date\n     * - {Boolean} isBooked: if the slot is already booked\n     * - {String} description: Description to show in the slot the duration of the booking for\n     *            the slots that can be selected as end date\n     */\n    get slots() {\n        const intervals = [];\n        const isToday = this.state.selectedDay.equals(this.today);\n        // If the day selected is the current day, the first slot starts at the current time\n        if (isToday) {\n            let firstSlotTime = luxon.DateTime.now();\n            if (this.state.bookingStart && this.state.bookingStart < firstSlotTime) {\n                // Make sure that the selected start is shown\n                firstSlotTime = this.state.bookingStart;\n            }\n            intervals.push(\n                luxon.Interval.fromDateTimes(\n                    firstSlotTime,\n                    firstSlotTime\n                        .plus({ minutes: 30 - (firstSlotTime.minute % 30) })\n                        .startOf(\"minute\"),\n                ),\n            );\n        }\n        // Fill with remaining intervals of the day, or with all intervals of the day\n        const remainingInterval = luxon.Interval.fromDateTimes(\n            intervals[0]?.end || this.state.selectedDay,\n            this.state.selectedDay.plus({ day: 1 }),\n        );\n        intervals.push(...remainingInterval.splitBy({ minutes: 30 }));\n\n        const bookings = this.bookingsByDate[this.state.selectedDay.toISODate()] || [];\n        let bookingIdx = 0;\n        let isBooked = false;\n        let isInSelectedInterval = false;\n        let canBeEndDate = false;\n        // Bookings created from backend could span several days, so we need to make\n        // sure that all slots between the start and end are marked as selected,\n        // even if the start is not in the selected day\n        if (\n            this.props.bookingToEdit &&\n            this.props.bookingToEdit.interval.start < this.state.selectedDay &&\n            this.props.bookingToEdit.interval.end > this.state.selectedDay\n        ) {\n            isInSelectedInterval = true;\n            canBeEndDate = true;\n        }\n        const slots = [];\n        for (const interval of intervals) {\n            const slot = {\n                start: interval.start,\n                isInSelectedInterval,\n                canBeEndDate,\n            };\n            if (this.state.bookingEnd && interval.contains(this.state.bookingEnd)) {\n                // Slot is the selected end (first condition in case start and stop are\n                // in the same slot)\n                isInSelectedInterval = false;\n            } else if (this.state.bookingStart && interval.contains(this.state.bookingStart)) {\n                // Slot is the selected start\n                slot.isInSelectedInterval = true;\n                // Following slots until the next booking can be selected as end date\n                canBeEndDate = true;\n                // Following slots until the selected end date are in the selected interval\n                isInSelectedInterval = Boolean(this.state.bookingEnd);\n            } else if (canBeEndDate && !isInSelectedInterval) {\n                // Show the duration of the booking if this slot was used as end date\n                slot.description = interval.start\n                    .diff(this.state.bookingStart)\n                    .toFormat(this.durationFormat);\n            }\n            if (bookings[bookingIdx]?.overlaps(interval) && !isBooked) {\n                // Slot contains the start of a booking\n                isBooked = true;\n                canBeEndDate = false;\n            }\n            slot.isBooked = isBooked;\n            if (isBooked && interval.end >= bookings[bookingIdx].end) {\n                // Slot contains the end of the booking\n                isBooked = false;\n                bookingIdx++;\n            }\n            slots.push(slot);\n        }\n        // Add midnight slot if the last time slot can be used as end of the booking\n        if (this.state.bookingStart && canBeEndDate) {\n            const midnight = this.state.selectedDay.plus({ day: 1 });\n            const isEnd = this.state.bookingEnd?.equals(midnight);\n            slots.push({\n                start: midnight,\n                canBeEndDate,\n                isInSelectedInterval: isEnd,\n                description: isEnd\n                    ? false\n                    : midnight.diff(this.state.bookingStart).toFormat(this.durationFormat),\n            });\n        }\n        return slots;\n    }\n\n    get today() {\n        return luxon.DateTime.now().startOf(\"day\");\n    }\n\n    get weekInterval() {\n        return luxon.Interval.fromDateTimes(\n            this.state.selectedDay.startOf(\"week\"),\n            this.state.selectedDay.endOf(\"week\"),\n        );\n    }\n\n    /**\n     * Return the days (as intervals) of the selected week\n     */\n    get weekIntervalDays() {\n        return this.weekInterval.splitBy({ day: 1 });\n    }\n\n    //----------------------------------------------------------------------\n    // Methods\n    //----------------------------------------------------------------------\n\n    /**\n     * Return the bookings grouped by date\n     * @returns {Object} bookingsByDate\n     */\n    computeBookingsByDate(bookings, bookingToEditId) {\n        return bookings.reduce((bookingsByDate, booking) => {\n            // If editing a booking, do not consider it as booked\n            if (bookingToEditId === booking.id) {\n                return bookingsByDate;\n            }\n            const intervals = [];\n            let { start, end } = booking.interval;\n            if (start.startOf(\"day\").equals(end.startOf(\"day\"))) {\n                intervals.push(booking.interval);\n            } else {\n                // Case a user creates a booking spanning multiple days from backend\n                while (start.startOf(\"day\") < end.startOf(\"day\")) {\n                    const nextDay = start.plus({ days: 1 }).startOf(\"day\");\n                    intervals.push(luxon.Interval.fromDateTimes(start, nextDay));\n                    start = nextDay;\n                }\n                intervals.push(luxon.Interval.fromDateTimes(start, end));\n            }\n            for (const interval of intervals) {\n                const date = interval.start.toISODate();\n                if (!(date in bookingsByDate)) {\n                    bookingsByDate[date] = [];\n                }\n                bookingsByDate[date].push(interval);\n            }\n            return bookingsByDate;\n        }, {});\n    }\n\n    //----------------------------------------------------------------------\n    // Handlers\n    //----------------------------------------------------------------------\n\n    /**\n     * Create a new booking or edit the bookingToEdit if one is given.\n     * If we are editing the ongoing booking and only changed the end date,\n     * we keep the start date as it is (instead of replacing it with the\n     * \"selected\" start which is the first slot since the real start slot is\n     * not shown anymore)\n     */\n    confirm() {\n        if (this.props.bookingToEdit) {\n            this.props.editBooking(\n                this.props.bookingToEdit.id,\n                this.state.bookingName,\n                this.props.bookingToEdit.interval.start < luxon.DateTime.now() &&\n                    this.state.bookingStart < luxon.DateTime.now()\n                    ? this.props.bookingToEdit.interval.start\n                    : this.state.bookingStart,\n                this.state.bookingEnd,\n            );\n        } else {\n            this.props.createBooking(\n                this.state.bookingName,\n                this.state.bookingStart,\n                this.state.bookingEnd,\n            );\n        }\n    }\n\n    /**\n     * Show the slots for the week following the current one\n     */\n    onNextWeekClick() {\n        this.state.selectedDay = this.state.selectedDay.plus({ week: 1 });\n    }\n\n    /**\n     * Show the slots for the week preceding the current one\n     */\n    onPreviousWeekClick() {\n        const day = this.state.selectedDay.minus({ week: 1 });\n        this.state.selectedDay = day < this.today ? this.today : day;\n    }\n\n    /**\n     * Handle a click on a slot.\n     * @param {Object} slot\n     * @param {luxon.DateTime} slot.start\n     * @param {Boolean} slot.canBeEndDate\n     * @param {Boolean} slot.isBooked\n     */\n    onSlotClick(slot) {\n        if (!this.state.bookingStart) {\n            if (!slot.isBooked) {\n                // Select start date\n                this.state.bookingStart = slot.start;\n            }\n        } else {\n            if (slot.start.equals(this.state.bookingStart)) {\n                // Clear selected dates\n                this.state.bookingStart = null;\n                this.state.bookingEnd = null;\n            } else if (slot.canBeEndDate) {\n                if (this.state.bookingEnd && slot.start.equals(this.state.bookingEnd)) {\n                    // Clear selected end date\n                    this.state.bookingEnd = null;\n                } else {\n                    // Select end date\n                    this.state.bookingEnd = slot.start;\n                }\n            } else if (!slot.isBooked) {\n                // Keep end date if choosing a start date before the current\n                // one and if there is no booking between the two\n                if (\n                    !slot.start.hasSame(this.state.bookingStart, \"day\") ||\n                    slot.start > this.state.bookingStart ||\n                    this.bookingsByDate[this.state.selectedDay.toISODate()]?.some((booking) =>\n                        booking.overlaps(\n                            luxon.Interval.fromDateTimes(slot.start, this.state.bookingStart),\n                        ),\n                    )\n                ) {\n                    this.state.bookingEnd = null;\n                }\n                // Select other start\n                this.state.bookingStart = slot.start;\n            }\n        }\n    }\n}\n", "/** @odoo-module **/\n\nimport { useInterval } from \"@room/room_booking/useInterval\";\n\nimport { Component, onWillUpdateProps, useState, xml } from \"@odoo/owl\";\n\nexport class RoomBookingRemainingTime extends Component {\n    static template = xml`\n        <div class=\"o_room_remaining_time mt-5 w-100 rounded py-3 bg-black-25 display-4 text-center text-white\"\n             t-out=\"state.remainingTime.toFormat('hh:mm:ss')\"/>\n    `;\n    static props = {\n        endTime: { type: Object },\n    };\n\n    setup() {\n        this.state = useState({ remainingTime: this.props.endTime.diffNow() });\n        // Update the remaining time every second\n        useInterval(() => {\n            const remainingTime = this.props.endTime.diffNow();\n            // Prevent flicker (could show -1s for a split second)\n            if (remainingTime >= 0) {\n                this.state.remainingTime = remainingTime;\n            }\n        }, 1000);\n        // When there are 2 consecutive bookings, make sure the remaining time is updated\n        // immediately (because the booking title and sidebar update immediately)\n        onWillUpdateProps((nextProps) => {\n            this.state.remainingTime = nextProps.endTime.diffNow();\n        });\n    }\n}\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport { deserializeDateTime, serializeDateTime } from \"@web/core/l10n/dates\";\nimport { redirect } from \"@web/core/utils/urls\";\nimport { registry } from \"@web/core/registry\";\nimport { RoomBookingForm } from \"@room/room_booking/room_booking_form/room_booking_form\";\nimport { RoomBookingRemainingTime } from \"@room/room_booking/room_booking_remaining_time\";\nimport { RoomDisplayTime } from \"@room/room_booking/room_display_time\";\nimport { useInterval } from \"@room/room_booking/useInterval\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nimport {\n    Component,\n    markup,\n    onWillStart,\n    onWillUnmount,\n    useExternalListener,\n    useState,\n} from \"@odoo/owl\";\n\n// Time (in ms, so 2 minutes) after which the user is considered inactive\n// and the app goes back to the main screen\nconst INACTIVITY_TIMEOUT = 120000;\n\nexport class RoomBookingView extends Component {\n    static components = {\n        RoomBookingForm,\n        RoomBookingRemainingTime,\n        RoomDisplayTime,\n    };\n    static props = {\n        accessToken: String,\n        bookableBgColor: String,\n        bookedBgColor: String,\n        description: String,\n        id: Number,\n        name: String,\n    };\n    static template = \"room.RoomBookingView\";\n\n    setup() {\n        this.manageRoomUrl = `/room/${this.props.accessToken}`;\n        this.state = useState({\n            bookings: [],\n            bookingName: undefined,\n            bookingToEdit: undefined,\n            currentBooking: null,\n            currentDate: this.now.startOf(\"day\"),\n            scheduleBooking: false,\n            scheduleBookingQuickCreate: false,\n        });\n        // Show bookings updates in live\n        this.busService = this.env.services.bus_service;\n        this.busService.addChannel(\"room_booking#\" + this.props.accessToken);\n        this.busService.subscribe(\"booking/create\", (bookings) => {\n            bookings.forEach((booking) => this.addBooking(booking));\n        });\n        this.busService.subscribe(\"booking/delete\", (bookings) => {\n            bookings.forEach((booking) => this.removeBooking(booking.id));\n        });\n        this.busService.subscribe(\"booking/update\", (bookings) => {\n            bookings.forEach((booking) => this.udpateBooking(booking));\n        });\n        this.busService.subscribe(\"reload\", (url) => redirect(url));\n        this.rpc = useService(\"rpc\");\n        this.notificationService = useService(\"notification\");\n        this.dialogService = useService(\"dialog\");\n        onWillStart(this.loadBookings);\n\n        // Every second, check if a booking started/ended\n        useInterval(this.refreshBookingView.bind(this), 1000);\n\n        // If the user is inactive for more than the  INACTIVITY_TIMEOUT, reset the view\n        [\"pointerdown\", \"keydown\"].forEach((event) =>\n            useExternalListener(window, event, () => {\n                browser.clearTimeout(this.inactivityTimer);\n                this.inactivityTimer = browser.setTimeout(() => {\n                    this.resetBookingForm();\n                }, INACTIVITY_TIMEOUT);\n            }),\n        );\n        onWillUnmount(() => browser.clearTimeout(this.inactivityTimer));\n    }\n\n    //----------------------------------------------------------------------\n    // Formats\n    //----------------------------------------------------------------------\n\n    get timeFormat() {\n        return luxon.DateTime.TIME_SIMPLE;\n    }\n\n    get dateFormat() {\n        return luxon.DateTime.DATE_HUGE;\n    }\n\n    //----------------------------------------------------------------------\n    // Getters\n    //----------------------------------------------------------------------\n\n    /**\n     * Return the background color of the main view which depends on the\n     * room's availability\n     */\n    get bgColor() {\n        return (\n            (this.state.currentBooking ? this.props.bookedBgColor : this.props.bookableBgColor) +\n            \"DD\"\n        );\n    }\n\n    /**\n     * Return the next booking\n     * @returns {Object} booking\n     */\n    get nextBooking() {\n        return this.state.currentBooking ? this.state.bookings[1] : this.state.bookings[0];\n    }\n\n    get now() {\n        return luxon.DateTime.now();\n    }\n\n    /**\n     * @returns {string} Raw HTML of the description\n     */\n    get roomDescription() {\n        return markup(this.props.description);\n    }\n\n    //----------------------------------------------------------------------\n    // Methods\n    //----------------------------------------------------------------------\n\n    /**\n     * Shows a confirmation dialog to delete the given booking\n     * @param {Number} bookingId\n     */\n    deleteBooking(bookingId) {\n        this.dialogService.add(ConfirmationDialog, {\n            body: _t(\"Are you sure you want to delete this booking?\"),\n            confirmLabel: _t(\"Delete\"),\n            confirm: () => this.rpc(`${this.manageRoomUrl}/booking/${bookingId}/delete`),\n            cancel: () => {},\n        });\n    }\n\n    /**\n     * Edit the given booking with the given values\n     * @param {Number} bookingId\n     * @param {String} name\n     * @param {luxon.DateTime} start\n     * @param {luxon.DateTime} end\n     */\n    editBooking(bookingId, name, start, end) {\n        this.rpc(`${this.manageRoomUrl}/booking/${bookingId}/update`, {\n            name,\n            start_datetime: serializeDateTime(start),\n            stop_datetime: serializeDateTime(end),\n        });\n        this.resetBookingForm();\n    }\n\n    /**\n     * Load the existing bookings for the room.\n     * New bookings will be received through the busService.\n     */\n    async loadBookings() {\n        const bookings = await this.rpc(`${this.manageRoomUrl}/get_existing_bookings`);\n        for (const booking of bookings) {\n            this.addBooking(booking);\n        }\n        this.refreshBookingView();\n    }\n\n    /**\n     * Book the room for the given duration\n     * @param {Number} duration (in minutes)\n     */\n    quickCreateBooking(duration) {\n        this.scheduleBooking(\n            this.state.bookingName,\n            this.now,\n            this.now.plus({ minutes: duration }),\n        );\n    }\n\n    /**\n     * Update the current status of the room (booked or available), and remove\n     * the booking of the list of bookings if it is finished.\n     */\n    refreshBookingView() {\n        // Check if current booking is finished\n        if (this.state.currentBooking?.interval.end < this.now) {\n            this.removeBooking(this.state.currentBooking.id);\n        }\n        const currentBooking =\n            this.state.bookings[0]?.interval.start < this.now ? this.state.bookings[0] : null;\n        // Check if next booking has started or if current booking has been rescheduled\n        if (this.state.currentBooking?.interval.end !== currentBooking?.interval.end) {\n            this.state.currentBooking = currentBooking;\n        }\n        // Update the currentDate that is used in the sidebar\n        if (this.state.currentDate.day !== this.now.startOf(\"day\").day) {\n            this.state.currentDate = this.now.startOf(\"day\");\n        }\n    }\n\n    /**\n     * Get back to the main view\n     */\n    resetBookingForm() {\n        this.state.scheduleBooking = false;\n        this.state.scheduleBookingQuickCreate = false;\n        this.state.bookingToEdit = undefined;\n        this.state.bookingName = undefined;\n    }\n\n    /**\n     * Schedule a booking for the given time range\n     * @param {String} name\n     * @param {luxon.DateTime} start\n     * @param {luxon.DateTime} end\n     */\n    scheduleBooking(name, start, end) {\n        this.resetBookingForm();\n        this.rpc(`${this.manageRoomUrl}/booking/create`, {\n            name: name || _t(\"Public Booking\"),\n            start_datetime: serializeDateTime(start),\n            stop_datetime: serializeDateTime(end),\n        });\n    }\n\n    //----------------------------------------------------------------------\n    // Bus Methods\n    //----------------------------------------------------------------------\n\n    /**\n     * Add a booking to the list of bookings, keeping the list sorted by start date\n     * @param {Object} newBooking\n     * @param {Number} newBooking.id\n     * @param {String} newBooking.start_datetime\n     * @param {String} newBooking.stop_datetime\n     * @param {String} newBooking.name\n     */\n    addBooking(newBooking) {\n        newBooking = {\n            id: newBooking.id,\n            name: newBooking.name,\n            interval: luxon.Interval.fromDateTimes(\n                deserializeDateTime(newBooking.start_datetime),\n                deserializeDateTime(newBooking.stop_datetime),\n            ),\n        };\n        // Do not add bookings that are already finished\n        if (newBooking.interval.end < this.now) {\n            return;\n        }\n        const newBookingInsertIdx = this.state.bookings.findIndex(\n            (booking) => booking.interval.start > newBooking.interval.start,\n        );\n        if (newBookingInsertIdx === -1) {\n            this.state.bookings.push(newBooking);\n        } else {\n            this.state.bookings.splice(newBookingInsertIdx, 0, newBooking);\n        }\n        // If the new booking has already started (eg. book now), refresh the view\n        if (newBooking.interval.start < this.now) {\n            this.refreshBookingView();\n        }\n    }\n\n    /**\n     * Remove a booking from the list of bookings\n     * @param {Number} bookingId\n     */\n    removeBooking(bookingId) {\n        const bookingIdx = this.state.bookings.findIndex((booking) => booking.id === bookingId);\n        if (bookingIdx !== -1) {\n            this.state.bookings.splice(bookingIdx, 1);\n            // Refresh view if the booking deleted was the current one\n            if (this.state.currentBooking?.id === bookingId) {\n                this.refreshBookingView();\n            }\n        }\n        // Leave form view if booking being edited has been deleted\n        if (this.state.bookingToEdit?.id === bookingId) {\n            this.resetBookingForm();\n            this.notificationService.add(_t(\"The booking you were editing has been deleted.\"));\n        }\n    }\n\n    /**\n     * Update the given booking with the new values. For simplicity, the existing booking\n     * is replaced by the new one so that order is maintained if the start date changed.\n     * @param {Object} booking\n     * @param {Number} booking.id\n     * @param {String} booking.start_datetime\n     * @param {String} booking.stop_datetime\n     * @param {String} booking.name\n     */\n    udpateBooking(booking) {\n        this.removeBooking(booking.id);\n        this.addBooking(booking);\n    }\n}\n\nregistry.category(\"public_components\").add(\"room.room_booking_view\", RoomBookingView);\n", "/** @odoo-module **/\n\nimport { useInterval } from \"@room/room_booking/useInterval\";\n\nimport { Component, useState, xml } from \"@odoo/owl\";\n\nexport class RoomDisplayTime extends Component {\n    static template = xml`<div class=\"d-flex flex-column justify-content-center\"><span class=\"display-6\" t-out=\"state.currentTime.toFormat('T')\"/><span class=\"smaller\" t-out=\"state.currentTime.toFormat('DDDD')\"/></div>`;\n\n    setup() {\n        this.state = useState({ currentTime: luxon.DateTime.now() });\n        // Update the current time every second\n        useInterval(() => (this.state.currentTime = luxon.DateTime.now()), 1000);\n    }\n}\n", "/** @odoo-module **/\n\nimport { browser } from \"@web/core/browser/browser\";\n\nimport { onMounted, onWillUnmount } from \"@odoo/owl\";\n\n/**\n * Creates an interval that will call the given callback every\n * `duration` ms.\n * @param {Function} callback\n * @param {Number} duration\n */\nexport function useInterval(callback, duration) {\n    let interval;\n    onMounted(() => (interval = browser.setInterval(callback, duration)));\n    onWillUnmount(() => browser.clearInterval(interval));\n}\n"], "file": "/web/assets/1/ce5864d/room.assets_room_booking.js", "sourceRoot": "../../../../"}